Сборник рецептов
Предисловие
C++ работает практически на любой платформе и используется в бесчисленном количестве приложений. Если вы купили или собираетесь купить эту книгу, вы, вероятно, являетесь программистом, инженером или исследователем, пишущим одно из таких приложений. Но независимо от того, что и для какой платформы вы пишете, велика вероятность, что вам придется снова решать многие из тех же проблем, которые уже решены другими программистами на C++ много лет назад. В этой книге мы будем решать многие из часто встречающихся проблем и объяснять каждое из решений.
Независимо от того, программируете ли вы на C++ уже много лет или используете его недавно, вы, скорее всего, знакомы с фрагментами, которые приходится переписывать для каждого нового проекта: арифметика и синтаксический анализ дат и времени, манипуляции со строками и текстом, работа с файлами, синтаксический анализ XML, использование стандартных контейнеров и т.п. Решения для всех таких проблем приведены в этой книге. Для некоторых случаев (например, арифметические операции с датами и временем) стандартная библиотека почти не содержит поддержки. Для других (например, работа со строками) стандартная библиотека содержит функционально богатые классы, но они не могут делать все, и решения некоторых очень часто встречающихся задач оказываются громоздкими.
Формат очень прост. Каждый рецепт содержит описание проблемы и код решения, а большинство содержит последующее обсуждение. Мы попытались быть прагматиками и решать проблемы, не слишком отклоняясь от цели, но во многих случаях имеются связанные проблемы, решение которых также очень полезно (или просто интересно), и мы приводим одну или две страницы пояснений.
Эта книга посвящена решению общих проблем с С++, но не является книгой для изучения С++. Мы предполагаем, что вы, по крайней мере, обладаете базовыми знаниями C++ и объектно-ориентированного программирования. В частности, будет полезно, если вы знакомы, по крайней мере, с:
• наследованием и виртуальными функциями С++;
• стандартной библиотекой;
• компонентами Standard Template Library (стандартной библиотекой шаблонов) (контейнерами, итераторами и алгоритмами);
• шаблонами.
Для чтения этой книги нет строгих предварительных требований, но наличие базовых знаний окажется весьма кстати.
О примерах
При создании наших примеров кода мы стремились к простоте, переносимости и производительности. Разработка каждого решения использовала сходный метод: если возможно, использовался стандартный C++ (язык или библиотека); если невозможно, то в качестве замены использовался стандарт де-факто. Например, многие из рецептов, относящихся к строкам, применяют стандартный класс string, а большинство математических и научных рецептов используют стандартные численные типы, контейнеры и шаблоны. Стандартная библиотека имеет мощную поддержку в этих областях, так что стандартных возможностей более чем достаточно. Однако C++ либо имеет слабую стандартную поддержку, либо не имеет ее вовсе в части многопоточности или синтаксического анализа XML. Таким образом, мы используем поддержку многопоточности, предоставляемую библиотекой Boost Threads, а для функциональности синтаксического анализа XML-парсер (parser) Xerces.
Часто в C++ имеется множество способов сделать одно и то же, что дает разработчикам определенную гибкость, но и приводит к спорам. Большая часть примеров иллюстрирует наилучшее общее решение, которое мы смогли найти, но это не означает, что не существует еще лучшего решения. Если есть альтернативные решения, которые оказываются лучшими в одних случаях, но не являются таковыми в других (возможно, решение, использующее стандартную библиотеку, некрасиво или неинтуитивно — в этом случае мы показываем альтернативное решение с использованием Boost), мы представляем альтернативные решения, чтобы показать вам различные имеющиеся решения.
Большое количество примеров используют шаблоны. Если у вас нет опыта в написании шаблонов, вам следует получить его как можно скорее. В этой книге очень мало вводного материала по шаблонам, за исключением двух рецептов в главе 8: 8.11 и 8.12. Большая часть интересных разработок на C++ относится к области метапрограммирования с использованием шаблонов и методического проектирования.
В момент написания этой книги в сообществе C++ происходят большие изменения. Первый технический отчет (называемый TR1) более или менее стабилен. Он стандартизирует набор функций, которые будут добавлены в следующую версию стандарта С++. Не существует требования поддержки его реализациями стандартной библиотеки, но многие поставщики уже начали реализовывать TR1, и можно ожидать, что скоро эти функции появятся в поставляемых компиляторах. Многие из библиотек из TR1 впервые появились в проекте Boost.
Мы активно используем библиотеки из Boost. Boost — это набор рецензируемых переносимых библиотек с открытым кодом, который заполняет многие пробелы в стандартной библиотеке. Текущая версия в момент написания книги 1.32, и скоро должна появиться версия 1.33. В примерах мы приводим много указаний на конкретные библиотеки Boost. Для получения дополнительной информации по Boost посетите Web-сайт проекта по адресу www.boost.org.
Соглашения, принятые в этой книге
В этой книге используются следующие типографские соглашения.
Курсив
Указывает на новые термины, URL, адреса e-mail, имена файлов, расширения файлов, пути, директории, утилиты Unix, команды и параметры командной строки.
<...>
В угловые скобки заключены элементы, которые требуется указать в командах и параметрах командной строки, и они выделены курсивом.
Шрифт постоянной ширины
Указывает код или его фрагменты. Например, шрифтом постоянной ширины набраны имена классов, методов и другие подобные элементы, при их появлении в тексте.
Жирный шрифт постоянной ширины
Показывает ввод пользователя в примерах ввода-вывода.
Курсив постоянной ширины
Указывает задаваемые пользователем элементы в примерах синтаксиса.
Указывает на подсказки, советы или общие замечания.
Указывает на предупреждения или предостережения.
Использование примеров кода
Целью этой книги является помощь в вашей работе. Вы можете использовать код этой книги в ваших программах и документации. Вам не требуется обращаться к нам за разрешением, если вы не воспроизводите значительные фрагменты кода. Например, написание программы, которая использует несколько небольших кусков кода из этой книги, не требует разрешения. Продажа или распространение CD-ROM с примерами книг O'Reilly требует разрешения. Ответы на вопросы с помощью цитат из этой книги и цитирования кода не требуют разрешения. Встраивание значительного количества примеров кода из этой книги в вашу документацию к продукту требует разрешения.
Мы приветствуем, но не требуем полного указания источника. Обычно указание источника включает название, автора, издателя и ISBN. Например: «C++ Cookbook by D. Ryan Stephens, Christopher Diggins, Jonathan Turkanis, and Jeff Cogswell. Copyright 2006 O'Reilly Media, Inc., 0-596-00761-2».
Если вы полагаете, что использование вами примеров кода выходит за рамки личного пользования или подпадает под один из требующих разрешения вариантов, указанных выше, свяжитесь с нами по адресу permissions@oreilly.com.
Комментарии и вопросы
Пожалуйста, направляйте комментарии и вопросы по этой книге издателю:
O'Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
(800) 998-9938 (в США и Канаде)
(707) 829-0515 (международная или местная поддержка)
(707) 829-0104 (факс)
Для этой книги имеется Web-страница, на которой приводятся все исправления, примеры и дополнительная информация. Эта страница находится по адресу:
http://www.oreilly.com/catalog/cplusplusckbk
Чтобы высказать комментарий или задать технический вопрос по этой книге, отправьте электронное письмо по адресу:
bookquestions@oreilly.com
Для получения дополнительной информации о нашей книге, ссылок, содержимого Resource Centers и сети O'Reilly Network посетите наш Web-сайт:
http://www.oreilly.com
Safari Enabled
Когда вы на обложке вашей любимой технической книги видите пиктограмму Safari® Enabled, это означает что книга доступна в сети через O'Reilly Network Safari Bookshelf.
Safari предлагает решение лучшее, чем электронные книги. Это виртуальная библиотека, которая позволяет вам с легкостью выполнять поиск по тысячам лучших технических книг, использовать примеры кода из них, скачивать главы и быстро находить ответы, получая наиболее точную и современную информацию. Попробуйте сделать это по адресу http://safari.oreilly.com.
Благодарности
От Д. Райана Стивенса (D. Ryan Stephens)
Наиболее важными людьми, которых я хочу поблагодарить, являются моя жена Дафна (Daphne) и мои дети Джесс (Jesse), Паскаль (Pascal) и Хлоя (Chloe). Написание книги это тяжелый труд, но еще важнее, что он отнимает много времени, и моя семья поддерживала меня и стойко терпела мою работу допоздна.
Я также благодарю технических редакторов, сделавших эту книгу лучше, чем она могла бы быть. Как и во многих других случаях, всегда полезно иметь вторую, третью и четвертую пару глаз, которые оценят ясность изложения и его правильность. Большое спасибо Дэну Саксу (Dan Saks), Уве Шниткер (Uwe Schnitker) и Дэвиду Тизу (David Theese).
Наконец, я должен поблагодарить моего редактора Джонатана Генника (Jonathan Gennick) за его всегда полезные советы по вопросам грамматики, стиля изложения и за философскую поддержку.
От Кристофера Диггинса (Christopher Diggins)
Я хочу поблагодарить Криса Ангера (Kris Unger), Джонатана Турканиса (Jonathan Turkanis), Джонатана Генника (Jonathan Gennick) и Райана Стивенса (Ryan Stephens) за их полезные предложения и критику, которые помогли мне писать лучше, чем я мог. Отдельное большое спасибо моей жене Мелани Карбонно (Melanie Charbonneau) за то, что она сделала мою жизнь светлее.
От Джонатана Турканиса (Jonathan Turkanis)
Так как мои главы затрагивают так много различных коммерческих продуктов и проектов с открытыми кодами и по каждому из них у меня было так много вопросов, мой список благодарностей необычно велик.
Во-первых, позвольте мне поблагодарить Рона Лихти (Ron Liechty), Говарда Хиннанта (Howard Hinnant) и инженеров в Metrowerks за их ответы на все мои вопросы и предоставление мне нескольких версий CodeWarrior.
Также я хочу поблагодарить разработчиков Boost.Build, особенно Владимира Пруса (Vladimir Prus), Рене Ривера (Rene Rivera) и Девида Абрамса (David Abrahams) — не только за ответы на мои вопросы, но также и за сборку системы компиляции Boost, которая сама по себе стала наиболее важным источником информации в главе 1.
Кроме того, спасибо Вальтеру Брайту (Walter Bright) из Digital Mars; Грегу Комю (Greg Comeau) из Comeau Computing; Пи Джей Плагеру (Р. J. Plauger) из Dinkumware; Колину Лапласу (Colin Laplace) из Bloodshed Software; Эду Малрою (Ed Mulroy) и Павлу Возенилеку (Pavel Vozenilek) из группы новостей borland.public.*; Арноду Дебене (Arnaud Debaene) и Игорю Тандетнику (Igor Tandetnik) из microsoft.public.vc.languages; Эрни Бойду (Earnie Boyd), Грегу Чикаресу (Greg Chicares), Адибу Тарабену (Adib Taraben), Джону Ванденбергу (John Vandenberg) и Леннарту Боргману (Lennart Borgman) из списка рассылки MinGW/MSYS; Кристоферу Фейлору (Christopher Faylor), Ларри Холлу (Larry Hall), Игорю Петчански (Igor Pechtchanski), Джошуа Даниелю Франклину (Joshua Daniel Franklin) и Дэйву Корну (Dave Korn) из списка Cygwin; Майку Стампу (Mike Stump) и Джефри Китингу (Geoffrey Keating) из списка разработчиков GCC; Марку Гудхенду (Mark Goodhand) из DecisionSoft и Дэвиду Н. Бертони (David N. Bertoni) из apache.org.
Я также в долгу перед Робертом Мекленбургом (Robert Mecklenburg), чье третье издание книги Managing Projects with GNU make (O'Reilly) дало основу моему знакомству с GNU make.
Кроме того, Владимир Прус (Vladimir Prus), Мэтью Вилсон (Matthew Wilson), Райан Стивенc (Ryan Stephens) и Кристофер Диггинс (Christopher Diggins) выполнили подробный анализ ранних черновиков моих текстов.
Наконец, я должен поблагодарить моего редактора Джонатана Генника (Jonathan Gennick), мою жену Дженнифер (Jennifer) и моего деда Луиса С. Гудмэна (Louis S. Goodman), научившего меня писать.
Глава 1
Сборка приложений на C++
1.0. Введение в сборку
Эта глава содержит рецепты по преобразованию исходного кода на C++ в исполняемые программы и библиотеки. При изучении этих рецептов вы узнаете об основных инструментах, используемых при сборке приложений на С++, различных типах двоичных файлов, используемых в этом процессе, и системах, предназначенных для упрощения управления процессом сборки.
Если посмотреть на названия рецептов в этой главе, то можно получить впечатление, что я снова и снова решаю одни и те же проблемы. И это будет правильно. Это происходит потому, что имеется большое количество способов сборки приложений С++, и хотя я не могу описать их все, я пытаюсь описать несколько наиболее важных методов. В первой десятке рецептов я показываю, как различными методами выполнять три базовые задачи - собирать статические библиотеки, собирать динамические библиотеки и собирать исполняемые файлы. Рецепты сгруппированы по методам; сначала я рассматриваю сборку из командной строки, затем с помощью системы Boost (Boost.Build), затем с помощью интегрированной среды разработчика (Integrated Development Environment (IDE), и наконец, с помощью GNU make.
Прежде чем вы начнете читать рецепты, обязательно прочтите следующие вводные разделы. Я объясню некоторую базовую терминологию, дам обзор инструментов командной строки, систем сборки и IDE, описываемых в этой главе, и покажу примеры исходного кода.
Даже если вы будете использовать систему сборки или IDE, вы должны начать с чтения рецептов по сборке из командной строки: эти рецепты представляют некоторые важные концепции, которые потребуются для понимания материала в дальнейшей части этой главы.
Базовая терминология
Три базовых инструмента, используемых для сборки приложений С++, — это компилятор, компоновщик и архиватор (или библиотекарь). Набор этих программ и, возможно, других инструментов называется инструментарием.
Компилятор принимает на входе исходные файлы на C++ и создает объектные файлы, которые содержат смесь исполняемого машинного кода и символьных ссылок на функции и данные. Архиватор на входе принимает набор объектных файлов и создает статическую библиотеку, или архив, который просто является подборкой объектных файлов, собранных для удобства использования вместе. Компоновщик принимает на входе набор объектных файлов и библиотек и разрешает их символьные ссылки, создавая либо исполняемый файл, либо динамическую библиотеку. Грубо говоря, компоновщик выполняет работу по сопоставлению каждого использования символа с его определением. Когда создается исполняемый файл или динамическая библиотека, то говорят, что они компонуются (линкуются) используемые при их построении библиотеки называются прилинкованными.
Исполняемый файл, или приложение, — это просто любая программа, которая может выполняться операционной системой. Динамическая библиотека, также называемая совместно используемой библиотекой, похожа на исполняемый файл, за исключением того, что она не может исполняться самостоятельно. Она состоит из тела машинного кода, которое загружается в память после запуска приложения, и может использоваться одним или несколькими приложениями. В Windows динамические библиотеки также называются динамически подключаемыми библиотеками (dynamic link libraries (DLL)).
Объектные файлы и статические библиотеки, от которых зависит исполняемый файл, требуются только при сборке исполняемого файла. Однако динамические библиотеки, от которых зависит исполняемый файл, должны иметься в системе пользователя при запуске исполняемого файла.
Таблица 1.1 приводит расширения файлов, обычно связанные с этими четырьмя базовыми типами файлов в Microsoft Windows и Unix. Когда я упоминаю файл, имеющий в Windows и Unix различные расширения, я иногда опускаю расширение, если оно ясно из контекста.
Табл. 1.1. Расширения файлов в Windows и Unix
Тип файла	Windows	Mac OS X	Другие Unix
Объектные файлы	.obj	.o	.o
Статические библиотеки	.lib	.a	.a
Динамические библиотеки	.dll	.dylib	.so
Исполняемые файлы	.exe	Нет расширения	Нет расширения
В этой главе, когда я говорю Unix, я также имею в виду и Linux.
При сборке примеров из этой главы ваши инструменты будут создавать большое количество вспомогательных файлов с расширениями, не приведенными в табл. 1.1. Если я не указываю другого, вы можете игнорировать эти файлы. Если вы действительно хотите знать, для чего они нужны, обратитесь к документации по вашему инструментарию.
IDE и системы сборки
Компилятор, компоновщик и архиватор — это инструменты командной строки, что означает, что они предназначены для запуска из оболочки, такой как bash в Unix или cmd.exe в Microsoft Windows. Имена входных и выходных файлов, а также вся остальная необходимая настроечная информация передаются в компилятор, компоновщик и архиватор как текст в командной строке. Однако вызов этих команд вручную довольно утомителен. Даже для небольших проектов может быть сложно запомнить параметры командной строки для каждого инструмента и порядок, в котором исходные и двоичный файлы проекта должны компилироваться и компоноваться. При изменении одного исходного файла вы должны определить, какие объектные файлы требуется перекомпилировать, какие статические библиотеки требуется обновить и какие исполняемые файлы или динамические библиотеки требуется перекомпоновать. Если вы пересоберете больше файлов, чем требуется, вы зря потратите время, а если пересоберете не все требуемые, то получите ошибки при сборке или неработоспособное приложение. В случае больших проектов на С++, которые могут включать тысячи отдельных файлов, включая исходные файлы, объектные файлы, библиотеки и исполняемые файлы, сборка из командной строки просто невозможна.
Имеется два основных подхода к сборке больших приложений на С++.
• IDE предоставляет графический интерфейс для организации набора исходных файлов и описания двоичных файлов, которые из них должны быть сгенерированы. После указания этой информации вы можете сгенерировать двоичные файлы просто выбрав в меню или на панели инструментов соответствующую команду. IDE отвечает за определение порядка генерации двоичных файлов, вызов инструментов, необходимых для их генерации, и опций командной строки, которые требуется передать в эти инструменты. Когда вы изменяете один или несколько исходных файлов вы можете указать IDE сгенерировать только устаревшие двоичные файлы.
IDE организуют исходные файлы в наборы, которые называются проектами. Проекты IDE обычно связаны с единственным двоичным файлом или несколькими вариантами одного двоичного файла, такими как отладочная и окончательная сборки приложения. Большинство IDE позволяет пользователю организовать проекты в группы, которые называются группами проектов или решениями, и указать зависимости между проектами в группе.
• Система сборки предоставляет формат текстового файла для описания набора исходных и генерируемых из них двоичных файлов, а также инструмент сборки, который читает эти текстовые файлы и генерирует двоичные файлы, вызывая соответствующие инструменты командной строки. Обычно эти текстовые файлы создаются и редактируются с помощью текстового редактора, а инструмент сборки вызывается из командной строки. Однако некоторые системы сборки предоставляют для редактирования этих файлов и вызова инструмента сборки графический интерфейс.
В то время как IDE организует файлы в проекты, система сборки организует файлы в цели. Большинство целей соответствует генерируемым двоичным файлам, другие соответствуют действиям, выполняемым инструментом сборки, таким как установка приложения.
Наиболее часто в качестве инструмента сборки используется утилита make; текстовые файлы, на которых она основана, называются makefile (make-файл). Хотя имеется множество версий make, в этой главе я обсуждаю GNU make — наиболее мощную и переносимую инкарнацию make. GNU make — это очень гибкий инструмент, который может использоваться не только для сборки приложений на С++. Он также имеет целый ряд преимуществ и широко используется и хорошо понимается разработчиками. К сожалению, заставить GNU make сделать именно то, что вам требуется, может оказаться не так просто, особенно в случае сложных проектов, использующих различные инструментарии. По этой причине я также описываю Boost.Build — мощную и расширяемую систему сборки, изначально предназначенную для сборки приложений на С++.
За подробным исследованием GNU make обратитесь к книге Роберта Мекленбурга (Robert Mecklenburg) Managing Projects with GNU make, Third Edition (издательство O'Reilly).
Boost.Build была разработана членами проекта Boost C++ Libraries. Она уже несколько лет используется большим сообществом разработчиков и постоянно активно совершенствуется. Boost.Build использует инструмент сборки, который называется bjam, и текстовые файлы, которые называются Jamfile (Jam-файлы). Ее самой сильной стороной является простота, с которой она позволяет управлять сложными проектами, предназначенными для нескольких платформ и содержащими несколько сборочных конфигураций. Хотя Boost.Build изначально создавалась как расширение системы сборки Perforce's Jam, она с тех пор подверглась значительной переработке. В момент сдачи этой книги в печать разработчики Boost.Build готовили официальный релиз второй основной версии этой системы сборки, и именно она описывается в этой главе
Обзор инструментария
В этой главе я буду обсуждать семь наборов инструментов командной строки: GCC, Visual C++, Intel, Metrowerks, Borland, Comeau и Digital Mars. Таблица 1.2 показывает имена инструментов командной строки из различных инструментариев, а табл. 1.3 показывает, где они расположены в вашей системе, если они установлены. Имена инструментов для Windows используют суффикс .exe, который требуется для исполняемых файлов Windows. Для инструментария, доступного как для Windows, так и для Unix, я заключаю этот суффикс в квадратные скобки.
Табл. 1.2. Имена инструментов командной строки в различном инструментарии
Инструментарий	Компилятор	Компоновщик	Архиватор
GCC	g++[.exe]	g++	ar[.exe] ranlib[.exe]
Visual C++	cl.exe	link.exe	lib.exe
Intel (Windows)	icl.exe	xilink.exe	xilib.exe
Intel (Linux)	lcpc	icpc	arranlib
Metrowerks	mwcc[.exe]	mwld[.exe]	mwld[.exe]
Comeau	como[.exe]	como[.exe]	Зависит от инструментария
Borland	bcc32.exe	bcc32.exe ilink32.exe	tlib.exe
Digital Mars	dmc.exe	link.exe	lib.exe
Табл. 1.3. Расположение ваших инструментов командной строки
Инструментарий	Расположение
GCC (Unix)	Обычно /usr/bin или /usr/local/bin
GCC (Cygwin)	Поддиректория bin установки Cygwin
GCC (MinGW)	Поддиректория bin установки MinGW
Visual C++	Поддиректория VC/bin установки Visual Studio¹
Intel (Windows)	Поддиректория Bin установки компилятора Intel
Intel (Linux)	Поддиректория bin установки компилятора Intel
Metrowerks	Поддиректория Other Metrowerks Tools/Command Line Tools установки CodeWarrior
Comeau	Поддиректория bin установки Comeau
Borland	Поддиректория Bin установки C++Builder, C++BuilderX или инструментов командной строки Borland
¹ В предыдущих версиях Visual Studio директория VC называлась VC98 или Vc7.
Пусть количество инструментария вас не пугает - вам не требуется изучать их все. В большинстве случаев можно просто пропустить материал, который не относится к вашему инструментарию. Однако, если вы хотите узнать немного о другом инструментарии, прочтите разделы о Visual C++ и GCC, так как это основной инструментарий для Windows и Unix.
Теперь давайте посмотрим на каждый из этих семи наборов.
GNU Compiler Collection (GCC)
GCC — это набор компиляторов для большого количества языков, включая С и С++. Следует заметить, что он является проектом с открытыми исходными кодами, доступен почти для всех имеющихся в природе платформ и обладает высокой степенью соответствия стандарту языка С++. Это основной компилятор для многих платформ Unix, он также широко используется в Microsoft Windows. Даже если GCC не является вашим основным инструментарием, вы можете многое узнать, используя его для компиляции своего кода. Также, если вы думаете, что знаете способ улучшить язык C++, проверьте свою идею на базе кода GCC.
GCC поставляется вместе с libstdc++ — хорошей реализацией с открытыми кодами стандартной библиотеки С++. Также он может использоваться совместно со стандартной библиотекой C++ с открытыми исходниками STLPort и со стандартной библиотекой Dinkumware
Чтобы узнать, где взять GCC, обратитесь к рецепту 1.1.
Примеры GCC в этой главе были протестированы с GCC 3.4.3 и GCC 4.0.0 на GNU/Linux (Fedora Core 3), с GCC 4.0.0 на Mac OS X (Darwin 8.2.0) и с GCC 3.4.2 (MinGW) и 3.4.4 (Cygwin) на Windows 2000 Professional.
Visual C++
Инструментарий Microsoft является главным на платформе Windows. Хотя до сих пор широко используются некоторые старые версии, лучше всего соответствуют стандарту самые последние версии. Также он может создавать хорошо оптимизированный код. Инструменты Microsoft распространяются вместе со средами разработки Visual C++ и Visual Studio, которые обсуждаются в следующем разделе. В момент написания этой книги они также были доступны в составе Visual C++ Toolkit 2003, который можно бесплатно скачать с www.microsoft.com.
Visual C++ поставляется в комплекте с модифицированной версией реализации стандартной библиотеки C++ Dinkumware. Стандартная библиотека C++ Dinkumware является одной из наиболее эффективных и наиболее полно соответствующих стандарту коммерческих реализаций. Она доступна на различных платформах и поддерживает многие из наборов инструментов, описываемых в этой главе.
Примеры Visual C++ в этой главе были протестированы с Microsoft Visual Studio .NET 2003 и Microsoft Visual Studio 2005 (Beta 2) (См. табл. 1.4.)
Табл. 1.4. Версии Microsoft Visual Studio
Название продукта	Версия IDE	Версия компилятора
Microsoft Visual Studio	6.0	1200
Microsoft Visual Studio .NET	7.0	1300
Microsoft Visual Studio .NET 2003	7.1	1310
Microsoft Visual Studio 2005 (Beta 2)	8.0	1400
Intel
Intel производит несколько компиляторов С++, предназначенных для использования со своими процессорами. Они отличаются генерацией очень быстрого кода — возможно, самого быстрого, доступного для архитектуры Intel. Основанные на интерфейсной части C++ производства Edison Design Group (EDG), они также очень хорошо соответствуют стандарту.
Компилятор Intel C++ для Windows используется совместно со средой разработки Microsoft's Visual C++ или Visual Studio, которая требуется для его правильного функционирования. Этот компилятор разработан с учетом совместимости с Visual С++: он может использоваться как дополнение к среде разработки Visual С++, может генерировать код, который на двоичном уровне совместим с кодом, генерируемым компилятором Visual С++, он предлагает многие из таких же опций командной строки, что и компилятор Visual C++, и, если вы не указали не делать этого, даже эмулирует некоторые из ошибок Microsoft. Коммерческую версию компилятора Intel C++ для Windows можно приобрести по адресу www.intel.com. Также имеется академическая версия по более низкой цене.
В то время как компилятор Intel для Windows разработан с учетом совместимости с компилятором Visual С++, компилятор Intel для Linux разработан с учетом совместимости с GCC. Для работы ему требуется GCC, он поддерживает многие опции GCC и по умолчанию реализует некоторые из расширений GCC. Коммерческую версию компилятора Intel C++ для Linux можно приобрести по адресу www.intel.com. Некоммерческая версия доступна для бесплатного скачивания.
В Windows компилятор Intel использует стандартную библиотеку Dinkumware, поставляемую вместе с Visual С++. В Linux он использует libstdc++.
Примеры Intel в этой главе были протестированы с компилятором Intel C++ Compiler 9.0 for Linux на GNU/Linux (Fedora Core 3) и с Intel C++ Compiler 9.0 for Windows на Windows 2000 Professional.
Metrowerks
Инструменты командной строки Metrowerks, распространяемые вместе со средой разработки CodeWarrior, относятся к числу лучших как с точки зрения соответствия стандарту, так и с точки зрения эффективности генерируемого кода. Они также поставляются вместе с MSL — превосходной реализацией стандартной библиотеки C++ от Metrowerks. До недавнего времени Metrowerks разрабатывала инструменты для Windows, Mac OS и некоторых встраиваемых платформ. Однако в 2004 году Metrowerks продала свои технологии компилятора и отладчика для Intel х86 фирме Nokia и прекратила выпуск линии продуктов CodeWarrior для Windows. В 2005 году, после того как Apple Computer анонсировала планы по переходу на процессоры Intel, Metrowerks объявила, что будущая версия CodeWarrior 10 для Mac OS будет, скорее всего, последней для этой платформы. В будущем Metrowerks сосредоточит свое внимание на разработке для встраиваемых систем на основе чипов производства Freescale Semiconductor.
К тому моменту, как вы будете читать эти строки, Metrowerks станет частью Freescale Semiconductor, и имя Metrowerks больше не будет связано с линейкой продуктов CodeWarrior. Однако я буду использовать имя Metrowerks, так как пока не ясно, каково будет ее имя в дальнейшем.
Примеры Metrowerks в этой главе были протестированы с CodeWarrior 9.6 и 10.0 (Beta) on Mac OS X (Darwin 8.2.0) и с CodeWarrior 9.4 на Windows 2000 Professional.
Borland
Инструменты командной строки Borland когда-то считались очень хорошими. Однако к сентябрю 2005 года последнее обновление насчитывало уже три года и представляло собой только незначительные улучшения предыдущей версии, которая была выпущена в 2000 году. В результате теперь инструменты Borland являются несколько устаревшими. В 2003 году Borland анонсировала планы по серьезному редизайну компилятора С++, используя интерфейсную часть EGD. К сожалению, в течение прошедшего времени Borland не делала больше никаких новых анонсов. Однако инструменты командной строки Borland остаются важны, так как все еще широко используются.
В настоящее время самая последняя версия инструментов командной строки Borland может быть приобретена в составе сред разработки C++Builder или C++BuilderX, описываемых в следующем разделе, или в составе доступной для бесплатной закачки персональной редакции C++BuilderX.
Инструментарий Borland поставляется с двумя стандартными библиотеками С++: STLPort и устаревшей версией стандартной библиотеки Rogue Wave. Также Borland разрабатывает версию инструментов, которые будут поставляться со стандартной библиотекой Dinkumware.
Примеры Borland в этой главе были протестированы с Borland C++ Builder 6.0 (версия компилятора 5.6.4) на Windows 2000 Professional
Comeau
Компилятор Comeau широко известен своим полным соответствием стандарту С++. Кроме реализации самых последних версий языка C++ он поддерживает несколько версий С и большое количество ранних диалектов С++. Он также является одним из самых дешевых, стоя на настоящий момент $50.
Аналогично компилятору Intel Comeau использует интерфейс EDG и требует для корректной работы отдельного компилятора С. В отличие от Intel, Comeau может использовать в качестве внутреннего интерфейса различные компиляторы С.
Comeau доступен для Microsoft Windows и для многих видов Unix. Если для вашей платформы Comeau недоступен, вы можете оплатить Comeau Computing создание отдельной версии, но это значительно дороже. Заказать компилятор Comeau можно по адресу www.comeaucomputing.com.
При обсуждении Comeau в Unix я буду в качестве внутреннего компилятора подразумевать GCC. При обсуждении Comeau в Windows я попробую указать, как опции командной строки зависят от используемого компилятора. Но так как Comeau может использоваться с большим количеством других компиляторов, не всегда возможно дать исчерпывающую информацию.
Comeau поставляется с libcomo — реализацией стандартной библиотеки С++, основанной на стандартной библиотеке Silicon Graphics. Также он может использовать стандартную библиотеку Dinkumware.
Примеры Comeau в этой главе предполагают, что используется libcomo и что компилятор настроен так, что он автоматически находит libcomo. Примеры были проверены с Comeau 4.3 3 и libcomo 31, используя GCC 3.4.3 на GNU/Linux (Fedora Core 3) и используя Visual C++ .NET 2003 на Windows 2000 Professional. (См. табл 1.4.)
Digital Mars
Digital Mars — это компилятор С++, написанный Вальтером Брайтом (Walter Bright). Его можно бесплатно скачать с www.digitalmars.com, а за небольшую сумму можно заказать CD, содержащий компилятор Digital Mars, IDE и некоторые полезные инструменты. Бесплатная версия компилятора может компилировать все примеры Digital Mars из этой главы, за исключением тех, которые требуют динамическую версию рабочей библиотеки, доступную только на CD.
Digital Mars — это очень быстрый компилятор, создающий сильно оптимизированный код. К сожалению, у него есть некоторые проблемы с компиляцией кода, использующего расширенные идиомы шаблонов. К счастью, Вальтер Брайт очень быстро отвечает на сообщения об ошибках и стремится сделать Digital Mars соответствующим стандарту.
Digital Mars поставляется с двумя стандартными библиотеками: портом стандартной библиотеки STLPort и более старой "стандартной библиотекой, которая не соответствует стандарту и неполна. В целях обратной совместимости STLPort должен явно подключаться пользователем. Все примеры Digital Mars в этой главе используют стандартную библиотеку STLPort.
Примеры Digital Mars в этой главе были проверены с Digital Mars 8.45 на Windows 2000 Professional.
Обзор IDE
В этой главе я описываю четыре IDE: Microsoft Visual С++, Metrowerks CodeWarrior, Borland C++Builder и Bloodshed Software Dev-C++. Есть большое количество различных IDE, не охватываемых мной, — примерами являются Apple Xcode и Eclipse Project, — но рассмотрение этих четырех IDE должно дать вам достаточно материала для начала изучения других IDE.
Как и в случае с инструментами командной строки, вы можете пропустить материал, не относящийся к вашей IDE.
Visual C++
Microsoft Visual C++ — это главная среда разработки C++ для Microsoft Windows. Она доступна как отдельное приложение или как часть набора Visual Studio и поставляется в комплекте с большим набором инструментов для разработки под Windows. Для переносимой разработки на C++ наиболее важными ее качествами являются
• высокое соответствие компилятора стандарту С++;
• стандартная библиотека C++ Dinkumware;
• хороший визуальный отладчик;
• менеджер проектов, который отслеживает зависимости между проектами.
Широко используются несколько версий Visual Studio. Так как названия различных версий могут сбить с толку, я перечислил наиболее широко используемые версии в табл. 1.4.
Первая версия Visual С++, включающая первоклассные компилятор и стандартную библиотеку, находится в третьей строке табл. 1.4. Все предшествующие версии имеют серьезные проблемы с реализацией стандарта.
CodeWarrior
CodeWarrior — это кросс-платформенная среда разработки Metrowerks. Она имеет большинство таких же функций, что и Visual С++, включая:
• высокое соответствие компилятора стандарту С++;
• превосходную стандартную библиотеку C++;
• хороший визуальный отладчик;
• менеджер проектов, который отслеживает зависимости между проектами.
Одной из сильных сторон CodeWarrior традиционно являлось большое количество платформ, для которых он был доступен, однако, как было сказано в предыдущем разделе, его линия для Windows была закрыта, а линия для Macintosh будет закрыта в скором будущем. Однако он остается важной платформой для разработки встраиваемых систем.
При обсуждении CodeWarrior IDE я предполагаю, что вы используете CodeWarrior 10 для Mac OS X. CodeWarrior IDE для других платформ очень похожа на эту версию.
C++Builder
C++Builder — это среда разработки Borland для приложений Microsoft Windows. Одной из ее привлекательных черт является поддержка библиотеки Borland's Visual Component Library. Однако для переносимой (мобильной) разработки на C++ наиболее важными ее качествами являются:
• проверенный временем компилятор С++;
• стандартная библиотека STLPort;
• хороший визуальный отладчик;
• менеджер проектов с ограниченной способностью управлять зависимостями проектов.
Я описываю C++Builder, потому что он широко используется и у него есть большое сообщество преданных пользователей.
C++Builder не следует путать с C++BuilderX — кросс-платформенной средой разработки, выпущенной Borland в 2003 году. Хотя C++BuilderX является полезным инструментом разработки, он не имел коммерческого успеха и неизвестно, будет ли Borland выпускать его новые версии.
Dev-C++
Bloodshed Software Dev-C++ — это бесплатная среда разработки C++ для Windows, использующая порт MinGW GCC, описанный в рецепте 1.1. Он содержит вполне удобный текстовый редактор и визуальный интерфейс для отладчика GNU.
Dev-C++ предлагает неполный графический интерфейс для многочисленных опций командной строки GCC: во многих случаях пользователи должны настраивать свои проекты, вводя в текстовые поля опции командной строки. Кроме того, его менеджер проектов может управлять только одним проектом, а визуальный отладчик ненадежен. Несмотря на эти ограничения, Dev-C++ поддерживается большим сообществом пользователей, включая студентов многих университетов. Это хорошая среда для того, кто хочет изучить С++, но не имеет никаких инструментов для разработки на С++.
John, Paul, George, and Ringo
Co времен, когда в 1978 году Брайан Керниган (Brian Kernighan) и Деннис Ритчи (Dennis Ritchie) опубликовали книгу The С Programming Language (Язык программирования С), стало традицией начинать изучение нового языка программирования с написания, компиляции и запуска небольшой программки, которая печатает в консоли «Hello, World!» («Привет, мир!»). Так как эта глава описывает статические и динамические библиотеки, а также исполняемые файлы, мне потребуется несколько более сложный пример.
Примеры 1.1, 1.2 и 1.3 представляют исходный код приложения hellobeatles, которое выводит текст
John, Paul, George, and Ringo
на консоль. Это приложение можно написать в виде единого исходного файла, но я разбил его на три модуля: статическую библиотеку libjohnpaul, динамическую библиотеку libgeorgeringo и исполняемый файл hellobeatles. Более того, хотя каждая из этих библиотек могла бы быть легко реализована как один заголовочный файл и один файл .cpp, я, чтобы проиллюстрировать компиляцию и компоновку проектов, содержащих более одного исходного файла, разбил реализацию на несколько исходных файлов.
Прежде чем вы начнете прорабатывать рецепты в этой главе, создайте четыре расположенные на одном уровне директории johnpaul, georgeringo, hellobeatles и binaries. В первые три директории поместите исходные файлы из примеров 1.1, 1.2 и 1.3. Четвертая директория будет использоваться для двоичных файлов, генерируемых IDE.
Исходный код libjohnpaul представлен в примере 1.1. Открытый интерфейс libjohnpaul состоит из одной функции johnpaul(), объявленной в заголовочном файле johnpaul.hpp. Функция johnpaul() отвечает за печать:
John, Paul,
на консоль. Реализация johnpaul() разбита на два. исходных файла — john.cpp и paul.cpp, каждый из которых отвечает за печать одного имени.
Пример 1.1. Исходный код libjohnpaul
johnpaul/john.hpp
#ifndef JOHN_HPP_INCLUDED
#define JOHN_HPP_INCLUDED
void john(); // Печатает "John, "
#endif // JOHN _HPP_INCLUDED
johnpaul/john.cpp
#include <iostream>
#include "john.hpp"
void john() {
 std::cout << "John, ";
}
johnpaul/paul.hpp
#ifndef PAUL_HPP_INCLUDED
#define PAUL_HPP_INCLUDED
void paul(); // Печатает " Paul, "
#endif // PAUL_HPP_INCLUDED
johnpaul/paul.cpp
#include <iostream>
#include "paul.hpp"
void paul() {
 std::cout << "Paul, ";
}
johnpaul/johnpaul.hpp
#ifndef JOHNPAUL_HPP_INCLUDED
#define JOHNPAUL_HPP_INCLUDED
void johnpaul(); // Печатает "John, Paul, "
#endif // JOHNPAUL_HPP_INCLUDED
johnpaul/johnpaul.cpp
#include "john.hpp"
#include "paul.hpp"
#include "johnpaul.hpp"
void johnpaul() {
 john();
 paul();
}
Исходный код libgeorgeringo представлен в примере 1.2. Открытый интерфейс libgeorgeringo состоит из одной функции georgeringo(), объявленной в заголовочном файле georgeringo.hpp. Как вы могли догадаться, функция georgeringo() отвечает за печать:
George, and Ringo
на консоль. И снова реализация georgeringo() разделена на два исходных файла — george.cpp и ringo.cpp.
Пример 1.2. Исходный код libgeorgeringo
georgeringo/george.hpp
#ifndef GEORGE_HPP_INCLUDED
#define GEORGE_HPP_INCLUDED
void george(); // Печатает "George, "
#endif // GEORGE_HPP_INCLUDED
georgeringo/george.cpp
#include <iostream>
#include "george.hpp"
void george()
 std::cout << "George, ";
}
georgeringo/ringo.hpp
#ifndef RINGO_HPP_INCLUDED
#define RINGO_HPP_INCLUDED
void ringo(); // Печатает "and Ringo\n"
#endif // RINGO_HPP_INCLUDED
georgeringo/ringo.cpp
#include <iostream>
#include "ringo.hpp"
void ringo() {
 std::cout << "and Ringo\n";
}
georgeringo/georgeringo.hpp
#ifndef GEORGERINGO_HPP_INCLUDED
#define GEORGERINGO_HPP_INCLUDED
// определите GEORGERINGO_DLL при сборке libgeorgeringo.dll
#if defined(_WIN32) && !defined(__GNUC__)
#ifdef GEORGERINGO_DLL
# define GEORGERINGO_DECL __declspec(dllexport)
#else
# define GEORGERINGO_DECL __declspec(dllimport)
#endif
#endif // WIN32
#ifndef GEORGERINGO_DECL
# define GEORGERINGO_DECL
#endif
// Печатает "George, and Ringo\n"
#ifdef __MWERKS__
# pragma export on
#endif
GEORGERINGO_DECL void georgeringo();
#ifdef __MWERKS__
# pragma export off
#endif
#endif // GEORGERINGO_HPP_INCLUDED
georgeringo/georgeringo.cpp
#include "george.hpp"
#include "ringo.hpp"
#include "georgeringo.hpp"
void georgeringo() {
 george();
 ringo();
}
Заголовок georgeringo.hpp содержит несколько сложных директив препроцессора. Если вы их не понимаете, не страшно. Я объясню их в рецепте 1.4.
Наконец, исходный код исполняемого файла hellobeatles представлен в примере 1.3. Он состоит из единственного исходного файла hellobeatles.cpp, который просто включает заголовки johnpaul.hpp и georgeringo.hpp и вызывает функцию johnpaul(), а вслед за ней — функцию georgeringo().
Пример 1.3. Исходный код hellobeatles
hellobeatles/ hellobeatles.cpp
#include "johnpaul/johnpaul.hpp"
#include "georgeringo/georgeringo.hpp"
int main() {
 // Печатает "John, Paul, George, and Ringo\n"
 johnpaul();
 georgeringo();
}
1.1. Получение и установка GCC
Проблема
Вы хотите получить GCC — свободно распространяемый компилятор GNU C/С++.
Решение
Решение зависит от вашей операционной системы.
Windows
Установите MinGW, Cygwin или оба.
Чтобы установить MinGW, посетите страницу MinGW по адресу www.mingw.org и проследуйте по ссылкам до страницы загрузки MinGW. Скачайте последнюю версию программы установки MinGW, которая должна иметь имя MinGW-<версия>.exe.
Далее запустите программу установки. Она попросит вас указать, куда вы хотите установить MinGW. Также она может спросить, какие пакеты вы хотите установить, - как минимум вы должны установить gcc-core, gcc-g++, binutils и среду выполнения MinGW, но можно установить и другие. По окончании установки вы сможете запустить из командной строки Windows gcc, g++, ar, ranlib, dlltool и некоторые другие инструменты GNU. Вам может потребоваться добавить директорию bin установки MinGW в переменную среды окружения PATH, с тем чтобы эти инструменты в командной строке вызывались по их имени, без указания полного пути к ним.
Чтобы установить Cygwin, посетите страницу Cygwin по адресу www.cygwin.com и для загрузки программы установки Cygwin проследуйте по ссылке Install Cygwin Now. Далее запустите программу установки. Она попросит вас выбрать несколько опций, таких как путь, куда следует устанавливать Cygwin.
Я подробно описываю процесс установки Cygwin, потому что он может оказаться несколько запутанным, в зависимости от того, что вы хотите установить. К тому моменту, как вы будете читать эту книгу, этот процесс может измениться, и, если это произойдет, он, возможно, станет проще.
Наиболее важным выбором является выбор пакетов. Если у вас достаточно места на диске и высокоскоростное соединение с Интернетом, я рекомендую устанавливать все пакеты. Чтобы сделать это, щелкните на слове Default (По умолчанию) рядом со словом All (Все) в верхней части иерархии пакетов. После паузы (возможно, продолжительной) слово Default должно измениться на Install (Установить).
Если места на диске недостаточно или у вас медленное соединение с Интернетом, можете выбрать меньшее количество пакетов. Чтобы выбрать только инструменты разработки, щелкните на слове Default рядом со словом Devel. После паузы (возможно, продолжительной) слово Default должно измениться на Install. Для выбора еще меньшего набора пакетов раскройте список пакетов для разработки, щелкнув на пиктограмме + рядом со словом Devel. Выберите пакеты gcc-core, gcc-g++ и make, щелкнув на слове Skip (Пропустить) напротив каждого из этих пакетов, в результате чего это слово сменится на Install.
По окончании выбора пакетов нажмите на Finish (Готово). Когда программа установки завершит работу, директория установки Cygwin должна содержать файл cygwin.bat. Запуск этого сценария приведет к отображению оболочки Cygwin — среды с командной строкой, из которой можно запускать gcc, g++, ar, ranlib, dlltool, make и любые другие установленные вами утилиты. Процесс установки добавляет поддиректорию bin установки Cygwin в переменную среды окружения PATH, так что запускать эти утилиты можно также и из оболочки Windows cmd.exe. Однако вы увидите, что оболочка Cygwin — порт оболочки bash — гораздо удобнее для запуска утилит GNU.
Unix
Введя в командной строке g++ -v, проверьте, установлен ли в вашей системе GCC. Если GCC установлен и если доступна поддержка языка С++, эта команда должна напечатать сообщение, похожее на следующее.
Using built-in specs.
Target: powerpc-apple-darwin8
Configured with /private/var/tmp/gcc/gcc-5026.obj~19/src/configure
--disable-checking --prefix=/usr ...
Если GCC не установлен или если он установлен без поддержки С++, вы должны самостоятельно установить его. Обычно это сложный процесс, который зависит от вашей платформы. Среди прочего вам потребуется установить пакеты GNU make и GNU binutils. Подробные инструкции доступны по адресу gcc.gnu.org/install.
Если вы используете Mac OS X, то простейшим способом получения GCC является скачивание с Web-сайта Apple среды разработки Xcode и следование простым инструкциям ее установки. В настоящий момент Xcode доступен по адресу developer.apple.com/tools.
Если вы используете Linux, то какая-то версия GCC уже должна быть установлена. Чтобы проверить номер версии, введите g++ -v. Текущая версия GCC — это 4.0.0. Если ваша версия сильно устарела, используйте систему управления пакетами, применяемую в вашем дистрибутиве Linux, и установите наиболее новую.
Обсуждение
Cygwin и MinGW представляют очень разные подходы к портированию инструментов GNU в Windows. Cygwin — это амбициозный проект, стремящийся воспроизвести Unix-подобную среду, работающую под Windows. Он предоставляет уровень совместимости с Unix, что позволяет компилировать и выполнять под Windows программы, написанные для Unix. Следовательно, для Cygwin доступно огромное количество утилит Unix. Даже если вы не разрабатываете для Unix, вы, возможно, скоро станете считать, что вам необходимы инструменты Cygwin.
MinGW, что означает «Minimalist GNU for Windows» (минимальный GNU для Windows), предоставляет минимальную среду для сборки исполняемых файлов для Windows с помощью GCC. Среди других вещей MinGW включает порт GCC, порт архиватора и компоновщика GNU и порт отладчика GNU GDB. Он также включает MSYS — среду командной строки, способную выполнять make-файлы GNU и сценарии configure. MSYS будет обсуждаться в рецепте 1.14.
Одно из важных различий между Cygwin и MinGW относится к лицензированию. За некоторыми исключениями вы можете распространять двоичные файлы, скомпилированные с помощью порта MinGW GCC, под любой удобной вам лицензией. С другой стороны, двоичные файлы, собранные с помощью порта Cygwin GCC, по умолчанию подпадают под действие лицензии GNU General Public License (GPL). Если вы хотите распространять программы, скомпилированные в Cygwin, не делая их исходники открытыми, вы должны приобрести лицензию у Red Hat. За полным описанием обратитесь к Web-сайтам Cygwin и MinGW.
Смотри также
Рецепт 1.14.
1.2. Сборка простого приложения «Hello, World» из командной строки
Проблема
Вы хотите собрать простую программу «Hello, World», подобную приведенной в примере 1.4.
Пример 1.4. Простая программа «Hello, World»
hello.cpp
#include <iostream>
int main() {
 std.:cout << "Hello, World!\n";
}
Решение
Выполните следующие шаги.
1. Установите все переменные среды окружения, необходимые для вашего инструментария.
2. Введите команду, которая говорит компилятору скомпилировать и скомпоновать вашу программу.
Сценарии для установки переменных среды окружения перечислены в табл 1.5. Эти сценарии расположены в той же директории, что и инструменты командной строки (табл. 1.3), Если ваш инструментарий в табл. 1.5 не указан, пропустите первый шаг. В противном случае, если вы используете Windows, запустите соответствующий сценарий из командной строки, а если используете Unix, то укажите его в качестве источника переменных окружения.
Табл. 1.5. Сценарии для установки переменных среды окружения, необходимые для инструментов командной строки
Инструментарий	Сценарий
Visual C++	vcvars32.bat
Intel (Windows)	iclvars.bat¹
Intel (Linux)	iccvars.sh или iccvars.csh
Metrowerks (Mac OS X)	iccvars.sh или mwvars.csh²
Metrowerks (Windows)	cwenv.bat
Comeau	Тот же, что и для используемого базового инструментария
¹ В предыдущих версиях компилятора Intel этот сценарий назывался iccvars.bat.
² В версиях CodeWarrior до 10.0 имелся единственный сценарий csh с именем mwvars.
Команды для компиляции и компоновки hello.cpp приведены в табл. 1.6. Для корректной работы эти команды требуют, чтобы ваша текущая директория была директорией, содержащей hello.cpp, и чтобы директория, в которой находится компилятор командной строки, была указана в переменной среды PATH. Если на шаге 1 вы запустили сценарий, то последнее требование будет удовлетворено автоматически. Также возможно, что директорию, содержащую инструменты командной строки, в переменную PATH добавил инсталлятор при установке инструментария. В противном случае вы можете либо добавить эту директорию в переменную PATH, как показано в табл. 1.7, либо указать в командной строке полный путь к файлу.
Табл. 1.6. Команды для компиляции и компоновки hello.cpp за один шаг
Инструментарий	Командная строка
GCC	g++ -o hello hello.cpp
Visual C++	cl -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cpp
Intel (Windows)	id -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cpp
Intel (Linux)	icpc -o hello hello.cpp
Metrowerks	mwcc -wchar_t on -cwd include -o hello hello.cpp
Comeau	como -o hello hello.cpp
Borland	bcc32 -q -ehello hello.cpp
Digital Mars	dmc -Ae -Ar -l<dmcroot>/stlport/stlport -o hello hello.cpp
Табл. 1.7. Добавление директории в переменную среды окружения PATH для одной сессии работы с командной строкой
Оболочка	Командная строка
bash, sh, ksh (Unix)	export PATH=<directory>:$PATH
csh, tsch (Unix)	setenv PATH <directory>:$PATH
cmd.exe (Windows)	set PATH=<direcfory>;%PATH%
Например, при использовании Microsoft Visual Studio .NET 2003 и установке ее по стандартному пути на диск С перейдите в директорию, содержащую hello.cpp, и введите показанные ниже команды.
> "C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\bin\vcvars32.bat"
Setting environment for using Microsoft Visual Studio .NET 2003 tools.
(If you have another version of Visual Studio or Visual C++ installed
and wish to use its tools from the command line, run vcvars32.bat for
that version.)
> cl -nologo -EHsn -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cpp hello
hello.cpp
hello
Теперь программу можно запустить.
> hello
Hello World!
Аналогично при использовании Intel 9.0 для Linux и установке его по стандартному пути /opt/intel/cc/9.0 откройте оболочку bash, перейдите в директорию, содержащую hello.cpp, и введите команды:
$ . /opt/intel/cc/9.0/bin/iccvars.sh
$ icpc -о hello hello.cpp
$ ./hello
Hello, World!
Обсуждение
Переменные среды окружения — это пары строк, поддерживаемые системой и доступные для работающих приложений. Инструменты командной строки часто используют переменные среды, для того чтобы узнать некоторые подробности о вашей системе и для получения настроечной информации, которую в противном случае пришлось бы вводить в командной строке. Переменная среды, с которой вы чаще всего будете сталкиваться, — это PATH, которая хранит перечень директорий, в которых операционная система ищет имя исполняемого файла, введенного в командной строке в виде простого имени без указания полного пути к нему. В Windows в директориях из переменной PATH также ищутся динамические библиотеки при их загрузке.
Инструменты командной строки используют переменные среды как в Unix, так и в Windows, но в Unix обычно есть системный компилятор С++, и переменные среды для его работы обычно по умолчанию устанавливаются в правильные значения. Однако в Windows традиционно имелось несколько конкурирующих компиляторов С++. Например, два различных компилятора будут, скорее всего, искать стандартные заголовочные файлы и библиотеки в различных местах. Следовательно, для Windows инструментарий часто предоставляет сценарии, которые устанавливают несколько переменных среды, в которых записано расположение заголовочных файлов и библиотек, а также другая информация.
Один из способов использовать такой сценарий — запускать его из командной строки перед вызовом какого-либо инструмента командной строки, как я продемонстрировал для Visual C++ и для Intel 9.0 для Linux. Также можно сделать установки переменных среды постоянными, с тем чтобы не приходилось каждый раз при запуске сессии командной строки запускать этот сценарий. Как это сделать, зависит от вашей операционной системы и вашей оболочки. Однако изменение постоянных значений переменных среды является плохой идеей, так как некоторые наборы инструментов могут содержать инструменты с одинаковыми именами, что приведет к вызову в процессе сборки неправильного инструмента. Например, если у вас установлено несколько версий Visual С++, вы должны быть уверены, что перед использованием инструментов командной строки вы запустили правильную версию vcvars32.bat. Другим примером является то, что Visual C++ и Digital Mars содержат инструменты с именами link.exe и lib.exe.
Теперь давайте посмотрим на командные строки в табл. 1.7. Помните, что вам требуется обратить внимание только на ту строку, которая соответствует вашему инструментарию. В общем случае информация, передаваемая компилятору, делится на четыре категории.
• Имя (имена) входного (исходного) файла (файлов).
• Имя (имена) выходного файла (файлов).
• Пути поиска файлов.
• Общая конфигурационная информация.
В табл. 1.6 указан только один входной файл hello.cpp, и он передается компилятору с помощью указания его имени в командной строке. Не имеет значения, в каком месте строки находится имя входного файла, при условии, что оно не находится в середине другой опции командной строки. В табл. 1.7 я поместил hello.cpp в самый конец командной строки.
Также в ней присутствует один выходной файл — hello.exe или hello, в зависимости от операционной системы. Однако в этом случае способ передачи имени файла компилятору зависит от инструментария. Большая часть инструментов для указания выходного файла использует -о <file>, но Visual C++ и Intel для Windows используют -Fe<file>, a Borland использует -e<file>. Заметьте, что указывать расширение исполняемого файла не обязательно.
Единственная информация в табл. 1.7, относящаяся к третьей категории — путям поиска файлов, — имеется в строке для Digital Mars. Так как библиотека STLPort не является встроенной стандартной библиотекой Digital Mars, компилятору с помощью опции -I требуется сообщить, где искать заголовочные файлы STLPort. Заголовочные файлы STLPort расположены в поддиректории /stlport/stlport установки Digital Mars. В табл. 1.7 я указал эту директорию с помощью опции <dmcroot>/stlport/stlport. За дополнительной информацией об опции -I обратитесь к рецепту 1.5.
Большая часть опций командной строки в табл. 1.7 относится к четвертой категории: общей конфигурационной информации. Эти опции не относятся к какому-либо отдельному файлу, а включают или отключают определенные функции компилятора.
• Опции -nologo (Visual C++ и Intel для Windows) и -q (Borland) говорят компилятору не печатать в консоли свои название и версию. Это делает вывод компилятора более простым для чтения.
• Опции -EHsc (Visual C++ и Intel для Windows) и -Ае (Digital Mars) говорят компилятору включить обработку исключений С++.
• Опции -GR (Visual C++ и Intel для Windows) и -Ar (Digital Mars) говорят компилятору включить информацию времени исполнения (RTTI).
• Опции -Zc:wchar_t (Visual C++ и Intel для Windows) и -wchar_t (Metrowerks) говорят компилятору распознавать wchar_t как встроенный тип.
• Опция -Zc:forScope (Visual C++ и Intel для Windows) говорит компилятору задействовать современные правила для областей видимости циклов for.
• Опция -cwd include (Metrowerks) говорит компилятору начинать поиск включенного заголовка с директории исходного файла, содержащего директиву include. Это поведение по умолчанию для всех инструментов, кроме Metrowerks.
Далее давайте рассмотрим второе решение нашей проблемы. Вместо того чтобы компилировать и компоновать с помощью одной команды, второй шаг можно разбить на две части.
2a. Введите команду, говорящую компилятору скомпилировать программу в объектный файл без компоновки.
2b. Введите команду, говорящую компоновщику создать исполняемый файл из объектных файлов, созданных на шаге 2a.
В нашем простом случае нет причин для раздельной компиляции и компоновки. Однако раздельная компиляция и компоновка требуются достаточно часто, так что важно, чтобы вы знали, как это делается. Например, при создании статической библиотеки вы должны скомпилировать файлы без компоновки, а затем передать готовые объектные файлы в архиватор.
Команды для компиляции и компоновки в два этапа представлены в табл. 1.8 и 1.9. В некоторых случаях я устанавливаю для объектного файла расширение o[bj], указывающее, что одна и та же командная строка годится и для Windows, и для Unix, за исключением расширения объектного файла.
Табл. 1.8. Команды для компиляции hello.cpp без компоновки
Инструментарий	Командная строка
GCC	g++ --c -o hello.o hello.cpp
Visual C++	cl -с -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fohello hello.cpp
Intel (Windows)	icl -с -nologo -EHsc -GR -Zc:forScope Zc:wchar_t -Fohello hello.cpp
Intel (Linux)	icpc -с о hello.о hello.cpp
Metrowerks	mwcc -c -wchar_t on -cwd include -o hello.o[bj] hello.cpp
Comeau	como -с -o hello.o[bj] hello.cpp
Borland	bcc32 -c -q -o hello.obj hello.cpp
Digital Mars	dmc -c -Ae -Ar -l<dmcroot>/stlport/stlport -o hello.obj hello.cpp
Табл. 1.9. Команды для компоновки hello.exe или hello
Инструментарий	Командная строка
GCC	g++ -о hello hello.o
Visual C++	link -nologo -out:hello.exe hello.obj
Intel (Windows)	xilink -nologo -out:hello.exe hello.obj
Intel (Linux)	icpc -o hello hello.o
Metrowerks	mwld -o hello hello.o[bj]
Comeau	como --no_prelink_verbose -о hello hello.o[bj]
Borland	bcc32 -q -ehello hello.cpp
Digital Mars	link -noi hello.obj, hello.exe,NUL,user32.lib kernel32.lib
Например, чтобы собрать исполняемый файл hello с помощью инструментария GCC, перейдите в директорию, содержащую hello.cpp, и введите следующие команды.
$ g++ -с -о hello.о hello.cpp
$ g++ -о hello hello.о
Теперь программу можно запустить вот так.
$ ./hello Hello, World!
Таблица 1.9 почти идентична табл. 1.6. Имеется только два различия. Во-первых, используется опция -с, говорящая компилятору скомпилировать без компоновки. Во-вторых, указанный выходной файл является объектным файлом hello.obj или hello.o, а не исполняемым. Большая часть компиляторов для указания выходного файла использует опцию -о <file>, но Visual C++ и Intel для Windows используют опцию -Fo<file>. Кроме того, все компиляторы, за исключением Visual C++ и Intel для Windows, требуют, чтобы было указано расширение объектного файла.
Теперь все командные строки в табл. 1.9 должны быть просты и понятны, так что я сделаю только два замечания.
• Компоновщик Digital Mars имеет необычный синтаксис, содержащий шесть полей, разделенных запятыми, которые используются для указания различных типов входных файлов. Сейчас вам требуется знать только то, что первое поле предназначено для объектных файлов, а второе — для выходного файла. Опция -noi говорит компоновщику выполнить компоновку с учетом регистра, что необходимо для программ на C++.
• Компоновщик Borland ilink32.exe использует синтаксис, похожий на Digital Mars. Чтобы упростить командную строку, я использовал для выполнения этапа компоновки компилятор bcc32.exe. Внутри себя bcc32.exe вызывает ilink32.exe.
Смотри также
Рецепты 1.7 и 1.15.
1.3. Сборка статической библиотеки из командной строки
Проблема
Вы хотите использовать свои инструменты командной строки для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.
Решение
Во-первых, используйте компилятор для компиляции исходных файлов в объектные файлы. Если ваши исходные файлы включают заголовочные файлы, расположенные в других директориях, то для указания компилятору, где искать эти заголовочные файлы, вам может потребоваться использовать опцию -I. За дополнительной информацией обратитесь к рецепту 1.5. Во-вторых, для объединения объектных файлов в статическую библиотеку используйте архиватор.
Чтобы скомпилировать каждый из трех исходных файлов из примера 1.1, используйте командные строки из табл. 1.8, изменив соответственно имена входного и выходного файлов. Чтобы объединить результирующие объектные файлы в статическую библиотеку, используйте команды, приведенные в табл. 1.10.
Табл. 1.10. Команды для создания архива libjohnpaul.lib или libjohnpaul.а
Инструментарий	Командная строка
GCC (Unix) Intel (Linux) Comeau (Unix)	ar ru libjohnpaul.a john.c paul.о johnpaul.o ranlib libjohnpaul.a
GCC (Windows)	ar ru libjohnpaul.a john.o paul.o johnpaul.о
Visual C++	lib -nologo -out:libjohnpaul.lib john.obj paul.obj johnpaul.obj
Comeau (with Visual С++)
Intel (Windows)	xilib -nologo/out:libjohnpaul.lib john.obj paul.obj johnpaul.obj
Metrowerks (Windows)	mwld -library -o libjohnpaul.lib john.obj paul.obj johnpaul.obj
Metrowerks (Mac OS X)	mwld -library -o libjohnpaul.a john.о paul.o johnpaul.о
Borland	tlib libjohnpaul lib /u /a /C +john +paul +johnpaul
Digital Mars	lib -c -n libjohnpaul.lib john.obj paul.obj johnpaul.obj
Например, чтобы скомпилировать john.cpp, paul.cpp и johnpaul.cpp в объектные файлы с помощью GCC, перейдите в директорию johnpaul и введите следующие команды, создающие объектные файлы john.о, paul.о и johnpaul.о:
$ g++ -с -о john.o john.cpp
$ g++ -с -о paul.o paul.cpp
$ g++ -с -о johnpaul.о johnpaul.cpp
Теперь скомпонуйте эти объектные файлы в статическую библиотеку следующим образом.
$ ar ru libjohnpaul.a john.o paul.o johnpaul.о
$ ranlib libjohnpaul.а
Обсуждение
При использовании GCC в Unix для создания статической библиотеки вы используете две отдельные команды: во-первых, вы вызываете архиватор ar, а затем вызываете инструмент с именем ranlib. Опция ru говорит ar добавить указанные объектные файлы в указанный архив, если в нем отсутствуют члены с такими же именами, а обновить существующий член архива только в том случае, если указанный объектный файл новее, чем существующий член архива. Традиционно после создания или обновления архива использовался инструмент ranlib, который создает или обновляет таблицу символов архива, т.е. указатель символов, которые присутствуют в содержащихся в архиве объектных файлах. Сегодня на многих системах архиватор ar самостоятельно заботится об обновлении таблицы символов, так что запуск ranlib необязателен. В частности, это верно для версии GNU ar. Однако на некоторых системах компилятор GCC может использоваться в сочетании с не-GNU-версией ar, и по этой причине для безопасности лучше запустить ranlib.
Как вы можете видеть в табл. 1.10, архиватор Borland tlib использует несколько необычный синтаксис: знак «плюс» перед объектными файлами говорит tlib добавить объектные файлы в библиотеку. Остальные командные строки должны быть вам понятны без пояснений.
В некоторых наборах инструментов в качестве архиватора может использоваться компоновщик, если ему передать соответствующую опцию командной строки. В других наборах должен использоваться отдельный архиватор.
Смотри также
Рецепты 1.8, 1.11 и 1.16.
1.4. Сборка динамической библиотеки из командной строки
Проблема
Вы хотите использовать свои инструменты командной строки для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.
Решение
Выполните следующие шаги.
1. Используйте компилятор для компиляции исходных файлов в объектные файлы. Если вы используете Windows, то для определения макросов, необходимых для организации экспорта символов динамической библиотеки, используйте опцию -D. Например, чтобы собрать динамическую библиотеку из примера 1.2, вы должны определить макрос GEORGERINGO_DLL. Если вы собираете библиотеку, написанную кем-то другим, то макросы, которые требуется определить, должны быть описаны в инструкции по установке.
2. Используйте компоновщик для создания из объектных файлов, созданных на шаге 1, динамической библиотеки.
Если динамическая библиотека зависит от других библиотек, то компилятору требуется сказать, где искать заголовочные файлы этих библиотек, а компоновщику требуется указать имена этих библиотек и их расположение. Этот вопрос подробно обсуждается в рецепте 1.5.
Основные команды для выполнения первого шага приведены в табл. 1.8 Вы должны соответственно изменить имена входных и выходных файлов. Команды для выполнения второго шага приведены в табл. 1.11. Если вы используете инструментарий, который поставляется как со статическим, так и с динамическим вариантами библиотек времени исполнения, укажите компилятору и компоновщику использовать динамический вариант, как описано в рецепте 1.23.
Табл. 1.11. Команды для создания динамической библиотеки libgeorgeringo.so, libgeorgeringo.dll или libgeorgeringo.dylib
Инструментарии	Командная строка
GCC	g++ -shared -fPIC -o libgeorgeringo.so george.o ringo.с georgeringo.о
GCC (Mac OS X)	g++ -dynamclib -fPIC -o libgeorgeringo.dylib george.o ringo.о georgeringo.o
GCC (Cygwin)	g++ -shared -o libgeorgeringo.dll -Wl,--out-implib,libgeorgeringo.dll,a -Wl,--export- all-symbols -Wl,--enable-auto-image-base george.o ringo.o georgeringo.o
GCC (MinGW)	g++ -shared -о libgeorgeringo.dll -Wl,-out-implib,libgeorgeringo.a -Wl,--export-all- symbols, -Wl,--enable-auto-image-base george.о ringo.о georgeringo.o
Visual C++	link -nologo -dll -out:libgeorgeringo.dll -implib:libgeorgeringo.lib george.obj ringo.obj georgeringo.obj
Intel (Windows)	xilink -nologo -dll -out:libgeorgeringo.dll -implib:libgeorgeringo.lib george.obj ringo.obj georgeringo.obj
Intel (Linux)	g++ -shared -fPIC -lrt -o libgeorgeringo.so george.o ringo.о georgeringo.o georgeringo.obj
Metrowerks (Windows)	mwld -shared -export dllexport -runtime dm -o libgeorgeringo.dll implib libgeorgeringo.lib george.obj ringo.obj georgeringo.obj
Metrowerks (Mac OS X)	mwld -shared -export pragma -o libgeorgeringo.dylib george.o ringo.о georgeringo.о
CodeWarrior 10.0 (Mac OS X)¹	Сверьтесь с документацией Metrowerks
Borland	bcc32 -q -WD -WR -elibgeorgeringo.dll george.obj ringo.obj georgeringo.obj implib -c libgeorgeringo.lib libgeorgeringo.dll
Digital Mars	dmc -WD -L/implib:libgeorgeringo.lib -о libgeorgeringo.dll george.obj ringo.obj georgeringo.obj user32.lib kernel32.lib
¹ CodeWarrior 10.0 для Mac OS X будет содержать динамический вариант своих библиотек. При сборке libgeorgeringo.dylib следует использовать именно их. (См. рецепт 1.23.)
По состоянию на сентябрь 2005 года инструментарий Comeau не поддерживал сборку динамических библиотек в Unix или Windows. Однако Comeau Computing работает над поддержкой динамических библиотек, и ожидается, что к концу 2005 года эта поддержка будет реализована для некоторых платформ Unix, включая Linux.
Например, чтобы скомпилировать исходные файлы из примера 1.2 в объектные файлы с помощью компилятора Borland, предполагая, что директория, в которой находятся инструменты Borland, включена в переменную PATH, перейдите в директорию georgeringo и введите следующие команды.
> bcc32 -с -a -WR -о george.obj george.cpp
george.cpp:
> bcc32 -c -q -WR -o ringo.obj ringo.cpp
ringo.cpp:
> bcc32 -c -q -WR -DGERORGERINGO_DLL -o georgeringo.obj georgeringo.cpp
georgeringo.cpp:
Здесь опция компилятора -WR используется для указания того, что применяется динамический вариант рабочей библиотеки. Эти три команды сгенерируют объектные файлы george.obj, ringo.obj и georgeringo.obj. Затем введите команду:
> bcc32 -q -WD -WR -elibgeorgeringo.dll george.obj ringo.obj georgeringo.obj
Она сгенерирует динамическую библиотеку libgeorgeringo.dll. Наконец, введите команду:
> implib -с libgeorgeringo.lib libgeorgeringo.dll
Она сгенерирует библиотеку импорта libgeorgeringo.lib.
Обсуждение
То, как обрабатываются динамические библиотеки, в основном зависит от операционной системы и инструментария. С точки зрения программиста, два наиболее значительных отличия — это:
Видимость символов
Динамические библиотеки могут содержать определения классов, функции и данные. На некоторых платформах все такие символы автоматически доступны для кода, использующего динамическую библиотеку, а другие системы предлагают программистам различные возможности управления доступом к этим символам. Наличие возможности определить, какие символы и в каком случае должны быть видны, очень полезно, так как дает программисту возможность более явного управления внешним интерфейсом его библиотеки и часто приводит к более высокой производительности. Однако она также делает более сложными сборку и использование динамических библиотек.
В случае с большинством инструментариев для Windows, чтобы символ, определенный в динамической библиотеке, был доступен коду, использующему эту библиотеку, он должен быть явно экспортирован при сборке динамической библиотеки и импортирован при сборке исполняемого файла или другой динамической библиотеки, использующей эту библиотеку. Некоторые инструменты для Unix также предлагают такие возможности. Это верно для последних версий GCC для некоторых платформ, для Metrowerks на Mac OS X и для Intel для Linux. Однако в некоторых случаях нет никакого выбора, кроме как сделать все символы видимыми.
Передача библиотек компоновщику
В Unix динамическая библиотека может быть указана как входной файл компоновщика при компоновке кода, использующего эту динамическую библиотеку. В Windows, кроме случаев использования GCC, динамические библиотеки не указываются напрямую как вход компоновщика, а вместо этого используется библиотека импорта или файл определения модуля.
Библиотеки импорта и файлы определения модулей
Библиотеки импорта, грубо говоря, являются статическими библиотеками, содержащими информацию, необходимую для вызова функций, содержащихся в DLL, во время исполнения. Нет необходимости знать, как они работают, надо только знать, как их создавать и использовать. Большинство компоновщиков создает библиотеки импорта автоматически при сборке DLL, но в некоторых случаях может оказаться необходимо использовать отдельный инструмент, который называется библиотекарь импорта (import librarian). В табл. 1.11 с целью избежать запутанного синтаксиса командной строки, требуемого компоновщиком Borland ilink32.exe, я использовал библиотекарь импорта Borland implib.exe.
Файл определения модуля, или файл .def — это текстовый файл, который описывает функции и данные, экспортируемые из DLL. Файл .def может быть написан вручную или автоматически сгенерирован каким-либо инструментом. Пример файла .def для библиотеки libgeorgeringo.dll показан в примере 1.5.
Пример 1.5. Файл определения модуля для libgeorgeringo.dll
LIBRARY LIBGEORGERINGO.DLL
EXPORTS
 Georgeringo @1
Экспорт символов из DLL
Имеется два стандартных метода экспорта символов из Windows DLL.
• Использование атрибута __declspec(dllexport) в заголовочных файлах DLL и сборка библиотеки импорта, предназначенной для применения при сборке кода, использующего эту DLL.
Атрибут __dеclspec(dllexport) должен указываться в начале объявления экспортируемой функции или данных, вслед за какими-либо спецификаторами сборки, и сразу за ним должно следовать ключевое слово class или struct для экспортируемого класса. Это проиллюстрировано в примере 1.6. Заметьте, что __declspec(dllexport) не является частью языка С++; это расширение языка, реализованное для большинства компиляторов для Windows.
• Создание файла .def, описывающего функции и данные, экспортируемые из динамической библиотеки.
Пример 1.6. Использование атрибута __declspec(dllexport)
__declspec(dllexport) int m = 3; // Экспортируемое определение данных
extern __declspec(dllexport) int n; // Экспортируемое объявление данных
__declspec(dllexport) void f(); // Экспортируемое объявление функции class
__declspec(dllexport) c { // Экспортируемое определение класса
 /* ... */
};
Использование файла .def имеет несколько преимуществ — например, он может позволить осуществлять доступ к функциям в DLL по номеру, а не по имени, что сокращает размер DLL. Он также устраняет необходимость запутанных директив препроцессора, таких как показанные в примере 1.2 в заголовочном файле georgeringo.hpp. Однако он также имеет и несколько серьезных недостатков. Например, файл .def не может использоваться для экспорта классов. Более того, можно забыть обновить свой файл .def при добавлении, удалении или изменении функций в вашей DLL. Таким образом, я рекомендую вам всегда использовать __declspec(dllexport). Чтобы изучить полный синтаксис файлов .def, а также научиться их использовать, обратитесь к документации по своему инструментарию.
Импорт символов из DLL
Как есть два способа экспорта символов из DLL, так есть и два способа импорта символов.
• В заголовочных файлах, включенных в исходный код, использующий DLL, используйте атрибут __declspec(dllimport) и при сборке этого кода передайте библиотеку импорта компоновщику.
• При сборке кода, использующего DLL, укажите файл .def.
Как и в случае с экспортом символов, я рекомендую вместо файлов .def использовать в вашем исходном коде атрибут __declspec(dllimport). Атрибут __declspec(dllimport) используется точно так же, как и атрибут __declspec(dllexport), обсуждавшийся ранее. Аналогично __declspec(dllexport) атрибут __declspec(dllimport) не является частью языка С++, а является расширением языка, реализованным для большинства компиляторов для Windows.
Если вы выбрали использование __declspec(dllexport) и __declspec(dllimport), вы должны убедиться, что при сборке DLL использовали __declspec(dllexport), а при компиляции кода, использующего эту DLL, использовали __declspec(dllimport). Одним из подходов является использование двух наборов заголовочных файлов: одного для сборки DLL, а другого для компиляции кода, использующего эту DLL. Однако это неудобно, так как сложно одновременно сопровождать две отдельные версии одних и тех же заголовочных файлов.
Вместо этого обычно используют определение макроса, который при сборке DLL расширяется как __declspec(dllexport), а в противном случае — как __declspec(dllimport). В примере 1.2 я использовал для этой цели макроопределение GEORGERINGO_DECL. В Windows, если определен символ GEORGERINGO_SOURCE, то GEORGERINGO_DECL раскрывается как __declspec(dllexport), а в противном случае — как __declspec(dllimport). Описанный результат вы получите, определив GEORGERINGO_SOURCE при сборке DLL libgeorgeringo.dll, но не определяя его при компиляции кода, использующего libgeorgeringo.dll.
Сборка DLL с помощью GCC
Порты GCC Cygwin и MinGW, обсуждавшиеся в рецепте 1.1, работают с DLL по-другому, нежели остальные инструменты для Windows. При сборке DLL с помощью GCC по умолчанию экспортируются все функции, классы и данные. Это поведение можно изменить, использовав опцию компоновщика --no-export-all-symbols, применив в исходных файлах атрибут __declspec(dllexport) или используя файл .def. В каждом из этих трех случаев, если вы не используете опцию --export-all-symbols, чтобы заставить компоновщик экспортировать все символы, экспортируются только те функции, классы и данные, которые помечены атрибутом __declspec(dllexport) или указаны в файле .def.
Таким образом, инструментарий GCC можно использовать для сборки DLL двумя способами: как обычный инструментарий Windows, экспортирующий символы явно с помощью __declspec, или как инструментарий Unix, автоматически экспортирующий все символы[1]. В примере 1.2 и табл. 1.11 я использовал последний метод. Если вы выберете этот метод, вы должны в целях предосторожности использовать опцию --export-all-symbols — на тот случай, если у вас окажутся заголовки, содержащие __declspec(dllexport).
GCC отличается от других инструментов для Windows и еще в одном: вместо того чтобы передавать компоновщику библиотеку импорта, связанную с DLL, вы можете передать саму DLL. Это обычно быстрее, чем использование библиотеки импорта. Однако это может привести к проблемам, так как в одной и той же системе может существовать несколько версий одной DLL, и вы должны быть уверены, что компоновщик выберет правильную версию. В табл. 1.11 при демонстрации того, как создавать библиотеки импорта с помощью GCC, я решил не использовать эту возможность.
В случае с Cygwin библиотека импорта для DLL xxx.dll обычно называется xxx.dll.a, в то время как в случае с MinGW она обычно называется xxx.a. Это просто вопрос соглашения.
Опция -fvisibility в GCC 4.0
Последние версии GCC на некоторых платформах, включая Linux и Mac OS X, дают программистам возможность более тонкого управления экспортом символов из динамических библиотек: опция командной строки -fvisibility используется для указания видимости символов динамической библиотеки по умолчанию, а специальный атрибут, аналогичный __declspec(dllexport) в Windows, используется в исходном коде для изменения видимости символов по отдельности. Опция -fvisibility имеет несколько различных значений, но два наиболее интересных — это default и hidden. Грубо говоря, видимость default означает, что символ доступен для кода других модулей, а видимость hidden означает, что не доступен. Чтобы включить выборочный экспорт символов, укажите в командной строке -fvisibility=hidden и используйте атрибут visibility (видимость) для пометки символов как видимых, как показано в примере 1.7.
Пример 1.7. Использование атрибута visibility с опцией командной строки -fvisibility=hidden
extern __attribute__((visibility("default"))) int m; // экспортируется
extern int n; // не экспортируется
__attribute__((visibility("default"))) void f(); // экспортируется
void g(); // не экспортируется
struct __attribute__((visibility("default"))) S { }; // экспортируется
struct T { }; //не экспортируется
В примере 1.7 атрибут __attribute__((visibility("default"))) играет ту же роль, что и __declspec(dllexport) в коде Windows.
Использование атрибута visibility представляет те же проблемы, что и использование __declspec(dllexport) и __declspec(dllimport), так как вам требуется, чтобы этот атрибут присутствовал при сборке общей библиотеки и отсутствовал при компиляции кода, использующего эту общую библиотеку, и чтобы он полностью отсутствовал на платформах, его не поддерживающих. Как и в случае с __declspec(dllexport) и __declspec(dllimport), эта проблема решается с помощью препроцессора. Например, вы можете изменить заголовочный файл georgeringo.hpp из примера 1.2 так, чтобы использовать атрибут видимости, следующим образом.
georgeringo/georgeringo.hpp
#ifndef GEORGERINGO_HPP_INCLUDED
#define GEORGERINGO_HPP_INCLUDED
// определите GEORGERINGO_DLL при сборке libgeorgeringo
#if defined(_WIN32) && !defined(__GNUC__)
#ifdef GEORGERINGO_DLL
#define GEORGERINGO_DECL __declspec(dllexport)
#else
#define GEORGERINGO_DECL __declspec(dllimport)
#endif
#else // Unix
# if defined(GEORGERINGO_DLL) && defined(HAS_GCC_VISIBILITY)
# define GEORGERINGO_DECL __attribute__((visibility("default")))
# else
#define GEORGERINGO_DECL
#endif
# endif
// Печатает "George, and Ringo\n"
GEORGERINGO_DECL void georgeringo();
#endif // GEORGERINGO_HPP_INCLUDED
Чтобы заставить это работать, вы должны при сборке в системах, поддерживающих опцию -fvisibility, определить макрос HAS_GCC_VISIBILITY.
Последние версии компилятора Intel для Linux также поддерживают опцию -fvisibility.
Видимость символов в Metrowerks для Mac OS X
Metrowerks для Mac OS X предоставляет несколько опций для экспорта символов из динамической библиотеки. При использовании IDE CodeWarrior вы можете использовать файл экспорта символов, который играет роль файла .def в Windows. Вы также можете экспортировать все символы с помощью опции -export all, что при сборке из командной строки является поведением по умолчанию. Я рекомендую метод, использующий для пометки в вашем исходном коде экспортируемых функций #pragma export, и указание в командной строке -export pragma при сборке динамической библиотеки. Использование #pragma export иллюстрируется в примере 1.2: просто вызовите #pragma export on в ваших заголовочных файлах сразу перед группой функций, которые требуется экспортировать, а сразу после нее — #pragma export off. Если вы хотите, чтобы ваш код работал с инструментарием, отличным от Metrowerks, вы должны поместить обращения к #pragma export между директивами #ifdef/#endif, как показано в примере 1.2.
Опции командной строки
Давайте кратко посмотрим на опции, использованные в табл. 1.11. Каждая строка команды определяет:
• имя (имена) входного файла (файлов): george.obj, ringo.obj и georgeringo.obj;
• имя создаваемой динамической библиотеки;
• в Windows имя библиотеки импорта.
Кроме того, компоновщик требует опции, которая говорит ему создать динамическую библиотеку, а не исполняемый файл. Большинство компоновщиков используют опцию -shared, но Visual C++ и Intel для Windows используют -dll, Borland и Digital Mars используют -WD, a GCC для Mac OS X использует -dynamiclib.
Несколько опций в табл. 1.11 способствуют более эффективному использованию динамических библиотек во время выполнения. Например, некоторым компоновщикам для Unix требуется с помощью опции -fPIC сгенерировать независимый от положения код (position- independent code) (GCC и Intel для Linux). Эта опция приводит к тому, что несколько процессов смогут использовать единственную копию кода динамической библиотеки. На некоторых системах отсутствие этой опции приведет к ошибке компоновщика. Аналогично в Windows опция компоновщика GCC --enable-auto-image-base снижает вероятность того, что операционная система попытается загрузить две динамические библиотеки в одно и то же место. Использование этой опции помогает ускорить загрузку DLL.
Передать опцию в компоновщик GCC можно через компилятор, используя опцию g++ -Wl,<option>. (За буквой W следует строчная буква l.)
Большая часть других опций используется для указания вариантов рабочей библиотеки и описывается в рецепте 1.23.
Смотри также
Рецепты 1.9, 1.12, 1.17, 1.19 и 1.23.
1.5. Сборка сложного приложения из командной строки
Проблема
Вы хотите использовать для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек, инструменты командной строки.
Решение
Начните со сборки статических и динамических библиотек, от которых зависит ваше приложение. Если библиотеки получены от сторонних разработчиков, следуйте инструкциям, поставляемым с этими библиотеками; в противном случае соберите их так, как описано в рецептах 1.3 и 1.4.
Затем скомпилируйте в объектные файлы .cpp-файлы своего приложения, как описано в разделе «Сборка простой программы «Hello, World» из командной строки». Чтобы сказать компилятору, где искать заголовочные файлы, требуемые для вашего приложения, используйте опцию -I, как показано в табл. 1.12.
Табл. 1.12. Указание директорий для поиска заголовочных файлов
Инструментарий	Опция
Все	-I<директория>
Наконец, для создания исполняемого файла из набора объектных файлов и библиотек используйте компоновщик. Для каждой библиотеки вы должны либо указать ее полный путь и имя, либо сказать компоновщику, где ее искать.
На каждой стадии этого процесса при использовании инструментария, поставляемого со статическим и динамическим вариантами рабочих библиотек, и если программа использует хотя бы одну динамическую библиотеку, вы должны указать компилятору или компоновщику использовать динамическую библиотеку времени выполнения, как описано в рецепте 1.23.
Таблица 1.13 предоставляет команды для компоновки приложения hellobeatles из примера 1.3. Она предполагает, что:
• текущей директорией является hellobeatles;
• статическая библиотека libjohnpaul.lib или libjohnpaul.а была создана в директории johnpaul;
• динамическая библиотека georgeringo.dll, georgeringo.so или georgeringo.dylib и, если есть, ее библиотека импорта были созданы в директории georgeringo.
Так как Comeau, как сказано в рецепте 1.4, не может создавать динамические библиотеки, строка для Comeau в табл. 1.13 предполагает, что libgeorgeringo была создана как статическая, а не как динамическая библиотека. Чтобы собрать libgeorgeringo как статическую библиотеку, в примере 1.2 удалите из объявления функции georgeringo() модификатор GEORGERINGO_DECL.
Табл. 1.13. Команды для компоновки приложения hellobeatles.exe
Инструментарий	Входные файлы	Командная строка
GCC (Unix)	hellobeatles.o libjohnpaul.a libgeorgeringo.so	g++ -о hellobeatles hellobeatles.o -L ./johnpaul -L./georgeringo -ljohnpaui -lgeorgeringo или g++ -o hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.so
Intel (Linux)		icpc -o hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -ljohnpaul -lgeorgeringo или icpc -о hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.so
Comeau (Unix)		como -no_prelink_verbose -o hellobeatles hellobeatles.o -L./johnpaul L./georgeringo -ljohnpaul -lgeorgeringo или como -no_prelink_verbose -o hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.a
GCC (Mac OS X)	hellobeatles.о libjohnpaul.a libgeorgeringo.dylib	g++ -o hellobeatles hellobeatles.o -L/johnpaul -L./georgeringo -ljohnpaul -lgeorgeringo или g++ -o hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dylib
Metrowerks (Mac OS X)		mwld -o hellobeatles hellobeatles.о -search -L/johnpaul -search -L ./georgeringo -ljohnpaui -lgeorgeringo или mwld -о hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dylib
GCC (Cygwin)	hellobeatles.о libjohnpaul.a libgeorgeringo.dll.a	g++ -о hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -Ijohnpaul -Igeorgeringo или g++ -o hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dll.a
GCC (MinGW)	hellobeatles.о libjohnpaul.a libgeorgeringo.a	g++ -o hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -Ijohnpaul -Igeorgeringo или g++ -о hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a. /georgeringo/libgeorgeringo.a
Visual C++	hellobeatles.obj libjohnpaul.lib libgeorgeringo.lib	link -nologo -out:hellobeatles.exe -libpath:./johnpaul -libpath:./georgeringo libjohnpaul.lib libgeorgeringo.lib hellobeatles.obj
Intel (Windows)		xilink -nologo -out:hellobeatles -libpath:./johnpaul -libpath:./georgeringo.lib johnpaul.lib libgeorgeringo.lib hellobeatles.obj
Metrowerks (Windows)		mwld -o hellobeatles -search -L./johnpaul libjohnpaul.lib -search -L./georgeringo libgeorgeringo.lib hellobeatles.obj
Metrowerks (Mac OS X)¹		mwld -o hellobeatles hellobeatles.o -search -L./johnpaul -search -L./georgeringo libjohnpaul libgeorgeringo.dylib
CodeWarrior 10.0 (Mac OS X)²		Сверьтесь с документацией Metrowerks
Borland		bcc32 -q -WR -WC -ehellobeatles -L./johnpaul -L./georgeringo/libjohnpaul.lib libgeorgeringo.lib hellobeatles.obj
Digital Mars		link -noi hellobeatles.obj,hellobeatles.exe,NUL,user32.lib kernel32.lib ..\johnpaul\ .\georgeringo\libjohnpaul.lib libgeorgeringo.lib,, или link -noi hellobeatles.obj,hellobeatles.exe,NUL,user32.lib kernel32.lib ..\johnpaul\libjohnpaul.lib ..\georgeringo\libgeorgeringo.lib,,
Comeau (Windows)	hellobeatles.obj libjohnpaul.lib libgeorgeringo.lib	como -no_prelink_verbose -o hellobeatles ./johnpaul/libjohnpaul.lib ./georgeringo/libgeorgeringo.lib hellobeatles.obj
¹ При сборке с помощью указанной командной строки hellobeatles может работать неправильно, так как это приложение будет использовать две копии рабочих библиотек Metrowerks. (См. рецепт 1.23.)
² CodeWarrior 10.0 для Mac OS X будет содержать динамический вариант своих библиотек. При сборке hellobeatles следует использовать именно их. (См. рецепт 1.23.)
Например, при использовании Microsoft Visual Studio .NET 2003 и если она установлена в стандартную директорию на диске С, чтобы собрать hellobeatles.exe из командной строки, перейдите в директорию hellobeatles и введите следующие команды.
> "С:Program Files\Microsoft Visual Studio .NET 2003\VC\bin\vcvars32.bat"
Setting environment for using Microsoft Visual Studio 2005 tools.
(IF you have another version of Visual Studio or Visual C++ installed
and wish to use its tools from the command line, run vcvars32.bat for
that version.)
> cl -c -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -MD -I.. -Fohollobeatles hellobeatles.cpp
hellobeatles.cpp
> link -nologo -out:hellobeatles.exe -libpath:../johnpaul -libpath:../georgeringo libjohnpaul.lib libgeorgeringo.lib
> hellobeatles.obj
Обсуждение
Поиск включенных заголовочных файлов
Опция -I используется для указания пути, где находятся заголовочные файлы. Когда компилятор — а на самом деле препроцессор — встречает директиву include в виде:
#include "file"
он обычно пытается вначале найти подключаемый файл, интерпретируя указанный путь относительно директории, в которой находится обрабатываемый исходный файл. Если этот поиск не дает результатов, он пытается найти этот файл в одной из директорий, указанных в опции -I, а затем в директориях, указанных в инструментарии, который часто настраивается с помощью переменных среды.
Эта ситуация аналогична включению заголовочного файла с помощью угловых скобок, как здесь:
#include <file>
за исключением того, что обычно компиляторы не интерпретируют указанный таким образом путь относительно местоположения обрабатываемого исходного файла.
Передача библиотек компоновщику
Есть несколько интересных аспектов, связанных с командными строками из табл. 1.13.
В Windows вход компоновщика состоит из объектных файлов, статических библиотек и библиотек импорта. В Unix он состоит из объектных файлов, статических и динамических библиотек.
Как в Windows, так и в Unix библиотеки могут передаваться компоновщику двумя способами:
• с помощью указания пути в командной строке;
• с помощью указания только имени библиотеки и места поиска библиотек.
Таблица 1.13 иллюстрирует оба метода.
Места поиска библиотек обычно могут быть указаны в командной строке. Большинство компоновщиков для этой цели используют опцию -L<directory>, но Visual C++ и Intel для Windows используют опцию -lipath: <directory>, a Metrowerks использует опцию -search -L<directory>. Компоновщик Digital Mars позволяет указывать пути поиска библиотек в командной строке вместе с файлами библиотек, при условии, что пути поиска отличаются от файлов библиотек завершающей обратной косой чертой. Также он требует, чтобы эти обратные слеши использовались как разделители в путях.
Comeau в Windows не имеет опции для указания путей поиска библиотек.
Кроме явно указанных директорий компоновщики обычно используют список собственных директорий, который часто может быть настроен с помощью переменных среды. В Windows список директорий обычно включает lib-поддиректорию пути установки инструментария. В результате, если скопировать .lib-файлы в эту директорию, их можно будет указать в командной строке по имени, не указывая их местоположения. Если объединить этот метод с действиями, описанными в рецепте 1.25, то можно вообще избежать передачи компоновщику какой-либо информации о библиотеке.
Способ, которым имя библиотеки передается компоновщику, для Unix и Windows различается. В Windows указывается полный путь библиотеки, включая расширение файла. В Unix — и в Windows при использовании инструментария GCC — библиотеки указываются с помощью опции -l, за которой следует имя библиотеки с удаленными из него расширением файла и префиксом lib. Это означает, что для того, чтобы компоновщик автоматически находил библиотеку, ее имя должно начинаться с префикса lib. Еще интереснее то, что это дает компоновщику возможность выбрать между несколькими версиями библиотек. Если компоновщик находит как статическую, так и динамическую версии библиотеки, выбирается, если не указано другого, динамическая библиотека. На некоторых системах компоновщик может выбрать между несколькими версиями динамической библиотеки, используя часть имени файла, за которой следует .so.
Metrowerks поддерживает как Windows, так и Unix-стили указания имен библиотек.
Наконец, будьте осторожны, так как компоновщики Unix могут быть очень чувствительны к порядку, в котором в командной строке указаны объектные файлы и статические библиотеки: если статическая библиотека или объектный файл ссылаются на символ, определенный во второй статической библиотеке или объектном файле, первый файл должен быть указан в командной строке до второго. Чтобы разрешить круговые зависимости, иногда требуется указать библиотеку или объектный файл несколько раз. Еще одним решением является передача последовательности из объектных файлов и статических библиотек компоновщику обрамленными в -( и -). Это приведет к тому, что поиск в файле будет производиться до тех пор, пока не будут разрешены все зависимости. Этой опции по возможности следует избегать, так как она значительно снижает производительность.
Запуск вашего приложения
Если ваше приложение использует динамический вариант библиотеки времени исполнения инструментария, то эта библиотека должна быть доступна приложению при его запуске и должна находиться в таком месте, где динамический загрузчик операционной системы сможет автоматически найти ее. Обычно это означает, что динамическая библиотека времени исполнения должна находиться либо в той же директории, что и ваше приложение, либо в одной из директорий, указанных системе. Это больше относится к разработке для Windows, чем для Unix, так как в Unix соответствующие библиотеки обычно уже установлены по правильным путям. Имена динамических библиотек времени исполнения, поставляемых с различным инструментарием, приведены в рецепте 1.23.
Смотри также
Рецепты 1.10, 1.13, 1.18 и 1.23.
1.6. Установка Boost.Build
Проблема
Вы хотите получить и установить Boost.Build.
Решение
Обратитесь к документации Boost.Build по адресу www.boost.org/boost-build2 или выполните эти шаги.
1. Перейдите на домашнюю страницу Boost — www.boost.org и проследуйте по ссылке Download (скачать) на страницу SourceForge Boost.
2. Скачайте и распакуйте либо самый последний релиз пакета boost, либо самый последний релиз пакета boost-build. Первый включает полный набор библиотек Boost, а второй — это отдельный релиз Boost.Build. Распакованные файлы поместите в подходящую временную директорию.
3. Скачайте и распакуйте последнюю версию пакета boost-jam для вашей платформы. Этот пакет включает собранный исполняемый файл bjam. Если пакет boost-jam для вашей платформы недоступен, то для сборки исполняемого файла из исходников следуйте инструкциям, прилагаемым к пакету, скачанному вами на шаге 2.
4. Скопируйте bjam в директорию, указанную в переменной среды PATH.
5. Установите переменную среды BOOST_BUILD_PATH в значение корневой директории BoostBuild. Если вы на шаге 1 скачали пакет boost, то корневая директория — это поддиректория tools/build/v2 установки Boost, а в противном случае это директория boost-build.
6. Настройте BoostBuild на ваш инструментарий и библиотеки, отредактировав файл user-config.jam, расположенный в корневой директории Boost.Build. Файл user-config.jam содержит комментарии, поясняющие, как это сделать.
Обсуждение
Наиболее сложной частью использования Boost.Build является его скачивание и установка. Со временем Boost может предоставить графическую программу установки, но в настоящий момент вы должны следовать приведенным выше шагам.
Целью пятого шага является помощь инструменту сборки — bjam в поиске корневой директории системы сборки. Однако этот шаг необязателен, так как есть другой способ выполнить эту же задачу: просто создайте файл, который называется boost-build.jam, с единственной строкой:
boost-build boost-build-root ;
и поместите его в корневую директорию вашего проекта или любую из его родительских директорий. Если вы хотите распространять BoostBuild вместе с вашим исходным кодом, то второй метод может оказаться предпочтительнее, так как он делает процесс установки более простым для конечных пользователей.
Шестой шаг, вероятно, является наиболее сложным, но на практике он обычно довольно прост. Если у вас установлена только одна версия инструментария, и она установлена в стандартном месте, то файл user-config.jam может содержать всего одну строку вида:
using <toolset> ;
Например, при использовании Visual C++ будет достаточно следующего:
using msvc ;
А при использовании GCC просто напишите:
using gcc ;
Дела становятся несколько более сложными при использовании нескольких версий инструментария или при установке инструментария не по стандартному пути. Если ваш инструментарий установлен в нестандартную директорию, скажите Boost.Build, где искать его, передав ему в качестве третьего аргумента using команду на вызов компилятора инструментария. Например:
using msvc : : "С:/Tools/Compilers/Visual Studio/Vc7/bin/cl" ;
Если у вас установлено несколько версий инструментария, вы можете указать правило using несколько раз с одним и тем же именем инструментария, передавая ему в качестве второго аргумента номер версии, а в качестве третьего — команду компилятора. Например, чтобы настроить две версии инструментария Intel, используйте следующее:
using intel : 7.1 : "C:/Program Files/Intel/Compiler70/IA32/Bin/icl" ;
using intel : 8.0 : "C./Program Files/Intel/CPP/Compiler80/IA32/Bin/icl" ;
Имена, используемые Boost.Build для нескольких разных инструментариев, описываемых в этой главе, приведены в табл 1.14.
Табл. 1.14. Имена инструментариев Boost.Build
Инструментарий	Имя
GCC	gcc
Visual C++	msvc
Intel	intel
Metrowerks	cw
Comeau	como
Borland	borland
Digital Mars	dmc
1.7. Сборка простого приложения «Hello, World» с помощью Boost.Build
Проблема
Вы хотите собрать простую программу «Hello, World», подобную приведенной в примере 1.4, с помощью BoostBuild.
Решение
В директории, где вы хотите создать исполняемый файл и все создаваемые при этом промежуточные файлы, создайте текстовый файл с именем Jamroot. В файле Jamroot укажите два правила, приведенных далее. Во-первых, укажите правило exe, объявляющее целевой исполняемый файл и исходные файлы .cpp. Далее укажите правило install, определяющее имя целевого исполняемого файла и директорию, в которую его следует устанавливать. Наконец, запустите bjam, чтобы собрать программу.
Например, чтобы собрать исполняемый файл hello или hello.exe из файла hello.cpp из примера 1.4, создайте в директории, содержащей файл hello.cpp, файл с именем Jamroot с содержимым, показанным в примере 1.8.
Пример 1.8. Jamfile для проекта hello
# jamfile для проекта hello
exe hello : hello.cpp ;
install dist : hello : <location>. ;
Далее перейдите в директорию, содержащую hello.cpp и Jamroot, и введите следующую команду.
> bjam hello
Эта команда собирает исполняемый файл hello или hello.exe в поддиректории текущей директории. Наконец, введите команду:
> bjam dist
Эта команда копирует исполняемый файл в директорию, указанную в свойстве location, которое в нашем случае равно текущей директории.
В момент сдачи этой книги в печать разработчики Boost.Build готовят официальный релиз BoostBuild версии 2. К моменту, когда вы будете это читать, версия 2 уже, возможно, будет выпущена. Если нет, вы можете задействовать поведение, описанное в этой главе, передав в bjam опцию командной строки --v2. Например, вместо ввода bjam hello введите bjam --v2 hello.
Обсуждение
Файл Jamroot является примером файла Jamfile. В то время как для управления небольшим набором исходных файлов C++ можно использовать один Jam-файл, большой набор файлов обычно требует нескольких Jam-файлов с иерархической организацией. Каждый Jam-файл находится в отдельной директории и соответствует отдельному проекту. Большая часть Jam-файлов просто называется Jamfile, но самый верхний Jam-файл — Jam-файл, который расположен в директории, родительской по отношению ко всем другим директориям, содержащим остальные Jam-файлы, — называется Jamroot. Проект, определяемый этим верхним Jam- файлом, называется корнем проекта. Каждый проект, за исключением корня проекта, имеет родительский проект определяемый проектом, расположенным в ближайшей к нему родительской директории, содержащей Jam-файл.
Эта иерархическая организация обладает большими преимуществами: например, она облегчает применение к проекту и всем его дочерним проектам требований, таких как поддержка потоков.
Каждый проект — это набор целей. Цели объявляются с помощью вызова правил, таких как правило exe и правило install. Большая часть целей соответствует двоичным файлам или, более точно, набору связанных двоичных файлов, таких как отладочная и финальная (релиз) сборки приложения.
Правило exe используется для объявления исполняемой цели. Вызов этого правила имеет вид, показанный в примере 1.9.
Пример 1.9. Вызов правила exe
exe имя-целевого-файла
 : исходные-файлы
 : требования
 : сборка-по-умолчанию
 : требования-к-использованию
 ;
Здесь имя-целевого-файла определяет имя исполняемого файла, исходные-файлы определяет список исходных файлов и библиотек, требования определяет свойства, которые должны применяться к цели независимо от каких-либо дополнительных свойств, указанных в командной строке или унаследованных от другого проекта, сборка-по-умолчанию определяет свойства, которые будут применены к цели, если не явно запрошено другое значение свойства, и требования-к-использованию определяет свойства, которые будут переданы всем остальным целям, зависящим от данной цели.
Свойства указываются в виде <функция>значение. Например, чтобы объявить исполняемый файл, который будет всегда собираться с поддержкой потоков, вы должны написать:
exe hello
 : hello.cpp
 : <threading>multi
 ;
От вас не требуется писать двоеточия, разделяющие последовательные аргументы правила Boost.Build, если вы не указываете значения этих аргументов.
Некоторые часто используемые функции и их возможные значения перечислены в табл. 1.15.
Табл. 1.15. Часто используемые функции Boost.Build
Функция	Значение	Эффект
include	Path	Определяет путь для поиска заголовочных файлов
define	name=[value]	Определяет макрос
threading	multi или single	Включает или отключает поддержку потоков
runtime-link	static или shared	Определяет тип компоновки с библиотекой времени выполнения¹
variant	debug или release	Запрашивает отладочную или окончательную сборку
¹ См. рецепт 1.23.
Когда собирается целевой исполняемый файл, или цель, соответствующая статической или динамической библиотеке, файл, соответствующий этой цели, создается в директории, дочерней по отношению к директории, содержащей Jam-файл. Относительным путь этой директории зависит от инструментария и конфигурации сборки, но он всегда начинается с bin. Например, исполняемый файл из примера 1.8 может быть создан в директории bin/msvc/debug.
Для простоты я попросил вас создать Jam-файл из примера 1.8 в той же директории, в которой находится исходный файл hello.cpp. Однако в реальных проектах вам часто придется хранить исходные и двоичные файлы в различных директориях. В примере 1.8 Jam-файл можно поместить в любое место при условии, что вы укажете путь hello.cpp так, что он будет указывать на реальный файл hello.cpp.
Правило install указывает Boost.Build скопировать один или несколько файлов, указанных как имена файлов или как имена главных целей, в указанное место. Вызов этого правила имеет вид, показанный в примере 1.10.
Пример 1.10. Вызов правила install
install имя-цели
 : файлы
 : требования
 : сборка-по-умолчанию
 : требования-к-использованию
 ;
Здесь имя-цели — это имя объявляемой цели, а файлы — это список из одного или более файлов или целей, которые требуется скопировать. Остальные аргументы — требования, сборка-по-умолчанию и требования-к-использованию — имеют такие же значения, как и в примере 1.9.
Место, куда файлы должны быть скопированы, может указываться либо как имя цели, либо как значение свойства location требований цели. Например, в примере 1.8 можно написать цель install следующим образом.
install . : hello ;
Затем установка исполняемого файла выполняется так:
> bjam .
Однако метод, использованный в примере 1.8, предпочтителен, так как проще запомнить именованную цель, чем путь файла.
Наконец, давайте быстро взглянем на синтаксис командной строки bjam. Чтобы собрать цель xxx, используя инструментарий по умолчанию, введите команду:
> bjam xxx
Чтобы собрать цель xxx, используя инструментарий yyy, введите команду:
> bjam xxx toolset=yyy
Чтобы собрать цель xxx, используя версию vvv инструментария yyy, введите команду:
> bjam хххtoolset=yyy-vvv
Чтобы в командной строке указать использовать при сборке стандартную библиотеку zzz, используйте синтаксис:
> bjam xxx stdlib=zzz
Чтобы собрать несколько целей одновременно, введите в командной строке несколько имен целей, а чтобы собрать все цели данного проекта, не указывайте целей. Следовательно, чтобы собрать и установить исполняемый файл из примера 1.9, просто введите:
> bjam
Чтобы удалить все файлы, созданные в процессе сборки, включая исполняемый файл, введите:
> bjam --clean
Свойство в виде <функция>значение может быть указано в командной строке как функция=значение.
Смотри также
Рецепты 1.2 и 1.15.
1.8. Сборка статической библиотеки с помощью Boost.Build
Проблема
Вы хотите использовать Boost.Build для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.
Решение
В директории, где вы хотите создать статическую библиотеку, создайте файл Jamroot. В файле Jamroot вызовите правило lib, объявляющее целевую библиотеку, указав в качестве исходных файлов свои файлы .cpp и используя в качестве требования свойство <link>static. Чтобы указать директорию поиска заголовочных файлов библиотеки, т. е. директорию, относительно которой должны разрешаться директивы include для заголовочных файлов этой библиотеки, добавьте требование к использованию в виде <include>путь. Чтобы указать компилятору, где искать включенные заголовки, может потребоваться использовать несколько директив вида <include>путь. Наконец, в директории, содержащей Jamroot, запустите bjam, как описано в рецепте 1.7.
Например, чтобы собрать статическую библиотеку из исходных файлов, перечисленных в примере 1.1, ваш Jamroot может выглядеть как в примере 1.11.
Пример 1.11. Jam файл для сборки статической библиотеки libjohnpaul.lib или libjohnpaul.a
# Jamfile для проекта libjohnpaul
lib libjohnpaul
: # исходники
john.cpp paul.cpp johnpaul.cpp
: # требования
<link>static
: # сборка-по-умолчанию
: # требования-к-использованию
<include>..
;
Чтобы собрать библиотеку, введите:
> bjam libjohnpaul
Обсуждение
Правило lib используется для объявления цели, представляющей статическую или динамическую библиотеку. Как показано в примере 1.9, оно имеет такой же вид, что и правило exe. Использование требования <include>.. освобождает проект, который зависит от вашей библиотеки, от необходимости явно указывать в своих требованиях директорию заголовочных файлов вашей библиотеки. Требование <link>static указывает, что ваша цель должна всегда собираться как статическая библиотека. Если вы хотите сохранить возможность сборки целевой библиотеки как статической и как динамической, опустите требование <link>static. Должна ли библиотека собираться как статическая или как динамическая, может быть указано в командной строке или в требованиях цели, которая зависит от целевой библиотеки. Например, если в примере 1.11 требование <link>static опустить, то чтобы собрать цель libjohnpaul как статическую библиотеку, потребуется ввести команду:
> bjam libjohnpaul link=static
Однако написание исходного кода для библиотеки, которая может быть собрана и как статическая, и как динамическая, является нетривиальной задачей, что показано в рецепте 1.9.
Смотри также
Рецепты 1.3, 1.11 и 1.16.
1.9. Сборка динамической библиотеки с помощью Boost.Build
Проблема
Вы хотите использовать Boost.Build для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.
Решение
В директории, где вы хотите создать динамическую библиотеку и, если надо, библиотеку импорта, создайте файл Jamroot. В файле Jamroot вызовите правило lib, объявляющее целевую библиотеку, указав в качестве исходных файлов свои файлы .cpp и используя в качестве требования свойство <link>shared. Чтобы указать директорию поиска заголовочных файлов библиотеки, т.е. директорию, относительно которой должны разрешаться директивы include для заголовочных файлов этой библиотеки, добавьте требование к использованию в виде <include>путь. Если исходные файлы включают заголовки от других библиотек, то чтобы сказать компилятору, где искать заголовочные файлы, вам может потребоваться добавить несколько требований в виде <include>путь. Чтобы гарантировать, что символы вашей динамической библиотеки будут экспортированы в Windows с помощью директивы __declspec(dllexport), вам также может потребоваться добавить одно или несколько требований в виде <define>символ. Наконец, в директории, содержащей Jamroot, запустите bjam, как описано в рецепте 1.7.
Например, чтобы собрать из исходных файлов, перечисленных в примере 1.2, динамическую библиотеку, создайте в директории georgeringo файл с именем Jamroot, показанный в примере 1.12.
Пример 1.12. Jam-файл для сборки динамической библиотеки georgeringo.so, georgeringo.dll или georgeringo.dylib
# Jamfile для проекта georgeringo
lib libgeorgeringo
 : # исходники
  george.cpp ringo.cpp georgeringo.cpp
 : # требования
  <link>shared
  <define>GEORGERINGO_DLL
 : # сборка-по-умолчанию
 : # требования-к-использованию
  <include>..
 ;
Чтобы собрать библиотеку, введите:
> bjam libgeorgeringo
Обсуждение
Как обсуждалось в рецепте 1.8, правило lib используется для объявления цели, представляющей статическую или динамическую библиотеку. Использование требования <include>.. освобождает проект, который зависит от вашей библиотеки, от необходимости явно указывать в своих требованиях директорию заголовочных файлов вашей библиотеки. Требование <link>shared указывает, что цель должна всегда собираться как динамическая библиотека. Если вы хотите иметь возможность собирать библиотеку и как статическую, и как динамическую, опустите требование <link>shared и укажите это свойство в командной строке или в требованиях цели, которая зависит от вашей целевой библиотеки. Однако написание библиотеки, которая может быть собрана и как статическая, и как динамическая, требует особого внимания, так как для правильного экспорта символов в Windows требуется использовать директивы препроцессора. Хорошим упражнением является переписывание примера 1.2 так, чтобы его можно было собрать и как статическую, и как динамическую библиотеку.
Смотри также
Рецепты 1.4, 1.12, 1.17 и 1.19.
1.10. Сборка сложного приложения с помощью BoostBuild
Проблема
Вы хотите использовать Boost.Build для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.
Решение
Выполните следующие шаги.
1. Для каждой библиотеки, от которой зависит исполняемый файл, — при условии, что она не распространяется в виде готового бинарного файла, — создайте Jam-файл, как описано в рецептах 1.8 и 1.9.
2. В директории, где вы хотите создать исполняемый файл, создайте файл Jamroot.
3. В файле Jamroot вызовите правило exe, объявляющее целевой исполняемый файл. Укажите свои файлы .cpp и цели библиотек, от которых исполняемый файл зависит как от источников. Также, если требуется, добавьте свойства вида <include>путь, чтобы сказать компилятору, где искать заголовочные файлы библиотек.
4. В файле Jamroot вызовите правило install, определяющее в качестве требований свойства <install-dependencies>on, <install-type>EXE и <install-type>SHARED_LIB.
5. В директории, содержащей Jamroot, запустите bjam, как описано в рецепте 1.7.
6. Например, чтобы собрать из исходных файлов, перечисленных в примере 1.3, исполняемый файл, создайте в директории hellobeatles файл с именем Jamroot, показанный в примере 1.13.
Пример 1.13. Jam-файл для сборки исполняемого файла hellobeatles.exe или hellobeatles
# Jamfile для проекта hellobeatles
exe hellobeatles
 : # исходники
  ../johnpaul//libjohnpaul
  ../georgeringo//libgeorgeringo
  hellobeatles.cpp
 ;
install dist
 : # исходники
  hellobeatles
 : # требования
  <install-dependencies>on
  <install-type>EXE
  <install-type>SHARED_LIB
  <location>.
 ;
Теперь введите:
> bjam hellobeatles
находясь в директории hellobeatles. В результате этого вначале будут собраны два проекта, от которых зависит цель hellobeatles, а затем будет собрана цель hellobeatles. Наконец, введите:
> bjam dist
В результате исполняемый файл hellobeatles и динамическая библиотека georgeringo будут скопированы в директорию, содержащую файл hellobeatles.cpp.
Как было сказано в рецепте 1.5, прежде чем запускать hellobeatles, вы должны поместить копию рабочей библиотеки вашего инструментария в такое место, где операционная система сможет ее найти.
Обсуждение
Цели библиотек
Цели библиотек, от которых зависит данная цель, указываются как источники с помощью записи path//target-name. В рецептах 1.8 и 1.9 я показал, как объявлять цель для сборки библиотеки из исходного кода с помощью Boost.Build Однако если библиотека доступна в виде готового двоичного файла, вы можете объявить цель для нее следующим образом.
lib имя-цели
 :
 : <file>имя-файла
 ;
Как объяснялось в рецепте 1.7, большая часть основных целей соответствует не одному файлу, а набору связанных файлов, таких как отладочная и окончательная сборка исполняемого файла. Чтобы объявить цель для готовой библиотеки, у которой есть несколько вариантов, используйте следующую запись.
lib имя цели
 :
 : <file>имя-файла требования
 ;
lib имя-цели
 : <file>другое-имя-файла другие-требования
 ;
Например, отладочный и окончательный варианты готовой библиотеки могут быть объявлены следующим образом.
lib cryptolib
 :
 : <file> ../libraries/cryptolib/cryptolib_debug.lib
  <variant>debug
 ;
 lib cryptolib
 : <file> ../libraries/cryptolib/cryptolib.lib
  <variant>release
 ;
Если готовая библиотека расположена в одной из директорий, в которых компоновщик выполняет поиск автоматически, как описано в рецепте 1.5, цель можно объявить следующим образом.
lib имя-цели
 : <name>имя-библиотеки
 ;
Здесь имя-библиотеки — это имя, которое должно быть передано компоновщику и которое может отличаться от реального имени файла, как обсуждалось в рецепте 1.5. Чтобы дать указание компоновщику искать в определенной директории, напишите
lib имя-цели
 : <name>имя-библиотеки
 <search>путь-к-библиотеке
 ;
Установка
Сложное приложение может требовать установки вместе с несколькими дополнительными исполняемыми файлами и динамическими библиотеками, от которых оно зависит. Вместо того чтобы указывать эти файлы по отдельности, используйте функцию install-dependencies, которая позволяет вам указать только главный исполняемый файл и тип зависимостей, которые должны быть установлены. В примере 1.13 требование <install-dependencies>on включает функцию install-dependencies, а требования <install-type>EXE и <install-type>SHARED_LIB говорят BoostBuild установить все зависимости, которые являются исполняемыми файлами или динамическими библиотеками. Другие возможные значения функции install-type включают LIB и IMPORT_LIB.
Организация проекта
Все три Jam-файла, используемые при сборке исполняемого файла hellobeatles, называются Jamroot. Это хорошо для такого простого проекта, но обычно следует организовывать набор Jam-файлов в иерархию с единственным высшим Jam-файлом, определяющим корень проекта. Организация проектов подобным образом позволяет использовать некоторые из более сложных функций Boost.Build's, таких как наследование свойств дочерними проектами. Одним из способов сделать такую организацию в нашем случае является изменение имен Jam-файлов в директориях johnpaul, georgeringo и hellobeatles с Jamroot на Jamfile и добавление файла Jamroot со следующим содержимым в родительскую директорию.
# jamfile для примера приложения
build-project hellobeatles ;
Правило build-project просто говорит bjam собрать данный проект, который может быть указан либо по пути, либо с помощью символьного идентификатора. Если вы перейдете в директорию, содержащую Jamroot, и запустите bjam, то будут собраны три дочерних проекта.
Смотри также
Рецепты 1.5, 1.13 и 1.18.
1.11. Сборка статической библиотеки с помощью IDE
Проблема
Вы хотите использовать IDE для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.
Решение
Основная процедура выглядит следующим образом.
1. Создайте новый проект и укажите, что требуется собрать статическую библиотеку, а не исполняемый файл или динамическую библиотеку.
2. Выберите конфигурацию сборки (т. е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
3. Укажите имя библиотеки и директорию, в которой она должна быть создана.
4. Добавьте в проект исходные файлы.
5. Если необходимо, укажите одну или несколько директорий, где компилятор должен искать подключаемые заголовочные файлы. (См. рецепт 1.13.)
6. Соберите проект.
Шаги этой процедуры могут варьироваться в зависимости от IDE — например, для некоторых IDE некоторые шаги будут объединены в один или изменится их порядок. Второй шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы. насколько это возможно, должны использовать параметры по умолчанию.
Например, вот как надо собирать статическую библиотеку из исходных файлов из примера 1.1 с помощью Visual C++ IDE.
В меню File выберите New→Project, в левой панели выберите Visual С++[2], выберите Win32 Console Application и введите в качестве имени проекта libjohnpaul. В мастере Win32 Application Wizard перейдите в раздел Application Settings (Параметры приложения), выберите Static library, отключите опцию Precompiled header (Прекомпилированные заголовочные файлы) и нажмите на Finish (Готово). Теперь у вас должен иметься пустой проект с двумя конфигурациями сборки — Debug и Release, и первая будет активной.
Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)→Librarian (Библиотекарь)→General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директорию binaries, созданную в начале этой главы, а имя должно быть libjohnpaul.lib.
Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add Existing Item (добавить существующий элемент) из меню Project. Теперь страницы свойств проекта должны содержать узел с именем «C/C++». Перейдите к Configuration Properties→C/C++→Code Generation (Генерация кода) и укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека). Теперь можно собрать проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директории binaries был создан файл с именем libjohnpaul.lib.
Вместо использования опции Add Existing Item, добавляющей в проект исходные файлы из примера 1.1, можно использовать Add New Item (Добавить новый элемент), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.1. Аналогичные замечания действительны и для других IDE.
Обсуждение
IDE различаются гораздо больше, чем инструментарий. Каждая IDE предоставляет свой собственный способ создания проекта, указания свойств конфигурации и добавления в него файлов. Тем не менее после того, как вы узнаете, как использовать несколько разных IDE, изучение использования еще одной IDE будет довольно простым.
При изучении того, как использовать новую IDE, вам следует обратить особое внимание на следующие моменты.
• Как создать новый проект.
• Как указать тип проекта (исполняемый файл, статическая библиотека или динамическая библиотека).
• Как добавить в проект существующий файл.
• Как создать и добавить в проект новый файл.
• Как указать имя выходного файла проекта.
• Как указать пути для включаемых заголовков.
• Как указать пути для поиска библиотек.
• Как указать библиотеки, от которых зависит проект.
• Как собрать проект.
• Как организовать набор проектов в группу и указать их зависимости.
Этот рецепт демонстрирует многие из этих функций. Большая часть других функций описывается в рецептах 1.12 и 1.13.
Теперь давайте посмотрим на то, как собрать статическую библиотеку с помощью CodeWarrior, C++Builder и Dev-C++.
CodeWarrior
В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введите libjohnpaul.mcp, выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-O C++ Console Final, и активной должна быть первая из них.
Так как при создании проекта, зависящего от этого проекта, вам придется ссылаться на эти цели по их имени, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы: отобразить окно Target Settings (Параметры цели). Затем перейдите к Target→Target Settings и в первом поле Target Name (Имя цели) введите libjohnpaul Debug.
Далее в окне Target Settings перейдите к Target→PPC Mac OS X Target. В качестве Project Туре (Тип проекта) укажите Library, а в поле с именем File Name (Имя файла) введите libjohnpaul.а. Чтобы указать в качестве места для создания выходного файла libjohnpaul.a директорию binaries; перейдите к Target→Target Settings и нажмите на Choose….
Наконец выберите вкладку files окна проекта и удалите существующие исходные файлы и файлы библиотек, перетащив их в Trash (корзину). Затем, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add Files (Добавить файлы) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make. Проверьте, что в директории binaries был создан файл с именем libjohnpaul.a.
C++Builder
В меню File выберите New→Other и выберите Library. Теперь у вас должен иметься пустой проект. В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введите libjohnpaul.bpr.
Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options. Затем перейдите в Directories and Conditionals (Директории и условия) и используйте элемент управления рядом с надписью Final output (Окончательный вывод), чтобы указать, где должен создаваться выходной файл libjohnpaul.lib. По умолчанию этот файл будет создан в той же директории, где находится libjohnpaul.bpr, но вы должны сказать C++Builder, что его требуется создать в директории binaries. Если хотите, то также можно использовать элемент управления рядом с Intermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add to Project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make libjohnpaul. Проверьте, что в директории binaries был создан файл с именем libjohnpaul.lib.
Dev-C++
В меню File выберите New→Project. В диалоге New project (Новый проект) выберите Static Library и C++ Project и в качестве имени проекта введите libjohnpaul. После нажатия на OK укажите место для сохранения настроечных файлов проекта.
Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Options. Затем перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указано libjohnpaul.a. В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директории binaries. Если хотите, то в поле Object File output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add to project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Execute пункт Compile. Проверьте, что в директории binaries был создан файл с именем libjohnpaul.a.
Смотри также
Рецепты 1.3, 1.8 и 1.16.
1.12. Сборка динамической библиотеки с помощью IDE
Проблема
Вы хотите использовать IDE для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.
Решение
Основная процедура выглядит следующим образом.
1. Создайте новый проект и укажите, что требуется собрать динамическую библиотеку, а не исполняемый файл или статическую библиотеку.
2. Выберите конфигурацию сборки (т. е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
3. Укажите имя библиотеки и директорию, в которой она должна быть создана.
4. Добавьте в проект исходные файлы.
5. В Windows определите макросы, необходимые для организации экспорта символов динамической библиотеки с помощью __declspec(dllexport).
6. Если необходимо, укажите одну или несколько директорий, где компилятор должен искать подключаемые заголовочные файлы. (См. рецепт 1.13.)
7. Соберите проект.
Как и в рецепте 1.11, шаги в этой процедуре будут различаться в зависимости от IDE. Второй шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы, насколько это возможно, должны использовать параметры по умолчанию.
Например, вот как надо собирать динамическую библиотеку из исходных файлов из примера 1.2 с помощью Visual C++ IDE.
В меню File выберите New→Project, в левой панели выберите Visual С++[3], выберите Win32 Console Application и в качестве имени проекта введите libgeorgeringo. В мастере Win32 Application Wizard перейдите к Application Settings, выберите DLL и Empty Project (Пустой проект) и нажмите на Finish. Теперь у вас должен иметься пустой проект с двумя конфигурациями сборки — Debug и Release, и первая будет активной.
Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)→Linker (Компоновщик)→General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директорию binaries, созданную в начале этой главы, а имя должно быть libgeorgeringo.dll. Аналогично перейдите в раздел Configuration Properties (Свойства конфигурации)→Linker (Компоновщик)→Advanced (Дополнительно) и в поле с именем Import Library (Библиотека импорта) введите имя и путь библиотеки импорта проекта. Директория этого пути должна указывать на директорию binaries, созданную в начале этой главы, а имя должно быть libgeorgeringo.lib.
Затем, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add Existing Item… (Добавить существующий элемент…) из меню Project.
Вместо использования опции Add Existing Item…, добавляющей в проект исходные файлы из примера 1.2, можно использовать Add New Item… (Добавить новый элемент…), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.2. Аналогичные замечания действительны и для других IDE.
Теперь страницы свойств проекта должны содержать узел с именем «С/С++». Перейдите к Configuration Properties→С/С++→Code Generation (Генерация кода) и, как описано в рецепте 1.19, определите макрос GEORGERINGO_DLL. Затем перейдите к Configuration Properties→C/C++→Code Generation и укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека).
Теперь можно собрать проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директории libgeorgeringo.lib были созданы два файла с именами libgeorgeringo.dll и libgeorgeringo.lib.
Обсуждение
Как вы уже видели в рецепте 1.11, каждая IDE предоставляет свой собственный способ создания проекта, указания свойств конфигурации и добавления в него файлов. Теперь давайте посмотрим на то, как собрать динамическую библиотеку с помощью CodeWarrior, C++Builder и Dev-C++.
CodeWarrior
В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введите libgeorgeringo.mcp, выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-О C++ Console Final, и активной должна быть первая из них.
Так как при создании проекта, зависящего от этого проекта, вам придется ссылаться на эти цели по их именам, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings (Параметры цели). Затем перейдите к Target→Target Settings и в первом поле Target Name (Имя цели) введите libgeorgeringo Debug.
Далее в окне Target Settings перейдите к Target→PPC Mac OS X Target. В качестве Project Туре (Тип проекта) укажите Dynamic Library, а в поле с именем File Name (Имя файла) введите libgeorgeringo.dylib. Чтобы в качестве места для создания выходного файла libjohnpaul.а указать директорию binaries, перейдите к Target→Target Settings и нажмите на Choose…. Затем перейдите к Linker→PPC Mac OS X Linker. В раскрывающемся списке Export Symbols (Экспорт символов) выберите Use #pragma и проверьте, что поле Main Entry Point (Главная точка входа) пусто.
Наконец выберите вкладку Files окна проекта и удалите существующие исходные файлы и файлы библиотек, перетащив их в Trash (корзину). Чтобы добавить в проект исходные файлы из примера 1.2, используйте Add Files… (Добавить файлы…) из меню Project. Затем используйте Add Files…, чтобы добавить файл dylib1.о из директории /usr/lib и файлы MSL_All_Mach-O_D.dylib и MSL_Shared_AppAndDylib_Runtime_D.lib из директории Metrowerks CodeWarrior/MacOS X Support/Libraries/Runtime/Runtime PPC/Runtime_MacOSX/Libs. Если бы вы вместо отладочной цели настраивали окончательную, то вместо этих библиотек должны были бы добавить библиотеки MSL_All_Mach-O.dylib и MSL_Shared_AppAndDylib_Runtime.lib. Теперь можно собрать проект, выбрав в меню Project пункт Make. Проверьте, что в директории binaries был создан файл с именем libgeorgeringo.dylib.
C++Builder
В меню File выберите New→Other и затем выберите DLL Wizard. В диалоге DLL Wizard выберите C++ и Multi Threaded. Теперь у вас должен быть проект, содержащий один исходный файл Unit1.cpp. Удалите Unit1.cpp из проекта, сделав для этого щелчок правой кнопкой мыши и выбрав Remove From Project (Удалить из проекта). В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введите libgeorgeringo.bpr.
Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options…. Затем перейдите в Directories and Conditionals (Директории и условия) и используйте элемент управления рядом с надписью Final output (Окончательный вывод), чтобы указать, что выходные файлы проекта должны создаваться в директории binaries. По умолчанию они создаются в той же директории, где находится libjohnpaul.bpr. Если хотите, то также можно использовать элемент управления рядом с Intermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
Далее определите макрос GEORGERINGO_DLL, как описано в рецепте 1.19.
Наконец, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add to Project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make libgeorgeringo. Проверьте, что в директории libgeorgeringo.lib были созданы два файла с именами libgeorgeringo.dll и libgeorgeringo.lib.
Dev-C++
В меню File выберите New→Project. В диалоге New project (Новый проект) выберите DLL и C++ Project, а в качестве имени проекта введите libgeorgeringo. После нажатия на OK укажите место для сохранения настроечных файлов проекта.
Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Option. Затем перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указано libjohnpaul.dll. В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директории binaries. Если хотите, то в поле Object file output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
Теперь определите макрос GEORGERINGO_DLL, как описано в рецепте 1.19.
Наконец удалите из проекта все существующие исходные файлы, сделав щелчок правой кнопкой мыши и выбрав Remove file. Для сохранения настроечного файла проекта libgeorgeringo.dev используйте Save Project as из меню File. Затем, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add to project (Добавить в проект) из меню Project. Соберите проект, в меню Execute выбрав Compile, и проверьте, что в директории binaries был создан файл с именем libjohnpaul.a.
Смотри также
Рецепты 1.4, 1.9, 1.17, 1.19 и 1.23.
1.13. Сборка сложного приложения с помощью IDE
Проблема
Вы хотите использовать IDE для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.
Решение
Основная процедура выглядит следующим образом.
1. При сборке из исходного кода библиотек, от которых зависит исполняемый файл, при том, что они не имеют своих собственных проектов IDE или make-файлов, создайте для них проекты, как описано в рецептах 1.11 и 1.12.
2. Создайте новый проект и укажите, что требуется собрать исполняемый файл, а не библиотеку.
3. Выберите конфигурацию сборки (т.е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
4. Укажите имя исполняемого файла и директорию, в которой он должен быть создан.
5. Добавьте в проект исходные файлы.
6. Скажите компилятору, где искать заголовочные файлы библиотек.
7. Скажите компоновщику, какие библиотеки требуется использовать и где их искать.
8. Если IDE поддерживает группы проектов, добавьте все проекты, указанные выше, в единую группу и укажите зависимости между ними.
9. Если IDE поддерживает группы проектов, соберите группу, созданную на шаге 8. В противном случае соберите проекты по отдельности, обращая внимание на последовательность их сборки с целью соблюдения зависимостей.
Как и в рецептах 1.11 и 1.12, шаги в этой процедуре будут различаться в зависимости от IDE. Третий шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы, насколько это возможно, должны использовать параметры по умолчанию.
Например, вот как надо собирать исполняемый файл из исходных файлов из примера 1.3 с помощью Visual C++ IDE.
В меню File выберите New→Project, в левой панели выберите Visual С++[4], выберите Win32 Console Application и в качестве имени проекта введите hellobeatles. В мастере Win32 Application Wizard перейдите к Application Settings, выберите Console Application (Консольное приложение) и Empty Project (Пустой проект) и нажмите на Finish. Теперь у вас должен иметься пустой проект hellobeatles.vcproj с двумя конфигурациями сборки — Debug и Release, и первая будет активной. Также у вас должно быть решение hellobeatles.sln, содержащее один проект hellobeatles.vcproj.
Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)→Linker (Компоновщик)→General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директорию binaries, созданную в начале этой главы, а имя файла должно быть hellobeatles.exe.
Затем, чтобы добавить в проект исходный файл hellobeatles.cpp из примера 1.3, используйте Add Existing Item (Добавить существующий элемент) из меню Project. Теперь страницы свойств проекта должны содержать узел с именем «C/C++». Перейдите к Configuration Properties→C/C++→Code Generation (Генерация кода) и укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека).
Вместо использования опции Add Existing Item, добавляющей в проект исходные файлы из примера 1.1, можно использовать Add New Item (Добавить новый элемент), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.1. Аналогичные замечания действительны и для других IDE.
Затем перейдите к Configuration Properties→C/C++→General и в поле редактирования с именем Additional Include Directories (Дополнительные директории заголовочных файлов) введите директорию, которая содержит директории johnpaul и georgeringo, — директорию, являющуюся «дедушкой» по отношению к файлам john.hpp, ringo.hpp и другим. Это позволит корректно разрешить директивы include в заголовочном файле hellobeatles.hpp.
Далее, используя Add→Existing Project… (Существующий проект…) из меню File добавьте в решение hellobeatles файлы проектов libjohnpaul.vcproj и libgeorgeringo.vcproj. Чтобы отобразить диалог Project Dependencies… (Зависимости проектов…), в меню Project выберите Project Dependencies. В раскрывающемся списке выберите hellobeatles и щелкните на флажках рядом с libjohnpaul и libgeorgeringo.
Если вы знаете, что будете добавлять несколько проектов в одно решение, нет необходимости создавать для каждого из них отдельное решение. Просто создайте пустое решение, выбрав в меню File пункт New→Blank Solution…, а затем добавив в него новые проекты, выбрав в меню File пункт New→Project….
Наконец соберите проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директории binaries были созданы файлы с именами libjohnpaul.lib, libgeorgeringo.dll, libgeorgeringo.lib и hellobeatles.exe. Теперь, чтобы запустить это приложение, в меню Debug выберите Start Without Debugging (Запустить без отладки).
Обсуждение
В предыдущем примере было достаточно просто указать, что hellobeatles.exe зависит от библиотек libjohnpaul.lib и libgeorgeringo.dll, так как обе эти библиотеки собирались в проектах Visual C++ из исходного кода. При сборке приложения, которое зависит от библиотек, распространяемых в виде готовых бинарных и заголовочных файлов, указать Visual C++, как их найти, можно следующим способом. Во-первых, перейдите к Configuration Properties→C/C++→General и в поле редактирования Additional Include Directories введите директории, которые содержат заголовочные файлы библиотек. Затем перейдите в раздел Configuration Properties→Linker→Input и в поле с именем Additional dependencies (Дополнительные зависимости) введите имена этих библиотек. Наконец перейдите к Configuration Properties→Linker→General и в поле редактирования Additional Include Directories введите директории, которые содержат бинарные файлы этих библиотек. Теперь давайте посмотрим на то, как из исходного кода из примера 1.3 собрать исполняемый файл с помощью CodeWarrior, C++Builder и Dev-C++.
CodeWarrior
В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введите hellobeatles.mcp, выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-O C++ Console Final, и активной должна быть первая из них.
Так как при добавлении в проект зависимостей вам придется ссылаться на эти цели по их именам, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings (Параметры цепи). Затем перейдите к Target→Target Settings и в первом поле Target Name (Имя цели) введите hellobeatles Debug.
Далее выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings, Перейдите к Target→PPC Mac OS X Target, в качестве Project Туре (Тип проекта) укажите Executable (Исполняемый файл), а в поле с именем File Name (Имя файла) введите hellobeatles. Чтобы в качестве места для создания выходного файла hellobeatles указать директорию binaries, перейдите к Target→Target Settings и нажмите на Choose….
Выберите вкладку Files окна проекта и удалите существующие исходные файлы и файлы библиотек MSL, перетащив их в Trash (корзину). Чтобы добавить в проект исходный файл hellobeatles.cpp из примера 13, используйте Add Files… (Добавить файлы…) из меню Project. Затем используйте Add Files…, чтобы добавить файлы MSL_All_Mach-O_D.dylib и MSL_Shared AppAndDylib_Runtime_D.lib, находящиеся в директории Metrowerks CodeWarrior/MacOS X Support/Libraries/Runtime/Runtime PPC/Runtime_MacOSX/Libs. Если бы вы вместо отладочной цели настраивали окончательную, то вместо этих библиотек должны были бы добавить библиотеки MSL_All_Mach-О.dylib и MSL_Shared_AppAndDylib_Runtime.lib. В окне Target Settings перейдите к Target→Access Paths (Пути доступа) и щелкните на панели, которая называется User Paths (Пути пользователя). Чтобы добавить директорию, которая содержит директории johnpaul и georgeringo, — директорию, являющуюся «дедушкой» по отношению к исходным файлам ringo.hpp, ringo.hpp и другим, — используйте элемент управления с именем Add…. Это позволит корректно разрешить директивы include в заголовочном файле hellobeatles.hpp.
Используя Add Files… из меню Project, добавьте в проект hellobeatles.mcp файлы проектов libjohnpaul.mcp и libgeorgeringo.mcp. Перейдите на вкладку Targets и раскройте узлы, которые называются hellobeatles Debug, libjohnpaul.mcp и libgeorgeringo.mcp. Щелкните на пиктограммах целей, расположенных рядом с дочерними узлами libjohnpaul.mcp и libgeorgeringo.mcp, которые называются libjohnpaul Debug и libgeorgeringo Debug. На обеих пиктограммах должны появиться жирные стрелки. Если требуется, увеличьте окно проекта так, чтобы увидеть небольшую пиктограмму связи у правого края окна. Дважды щелкните в этом столбце — напротив пиктограмм целей со стрелками. В этом столбце должны появиться две черные точки.
Соберите проект, выбрав в меню Project пункт Make. Компоновщик может отобразить несколько предупреждений о символах, определенных несколько раз, но ими можно пренебречь. Вы можете подавить их, перейдя к Linker→Mac OS X Linker и установив опцию Suppress Warning Messages (Подавлять предупреждающие сообщения).
Проверьте, что в директории binaries были созданы файлы с именами libjohnpaul.a, libgeorgeringo.dylib и hellobeatles. Теперь запустите hellobeatles, поместив в директорию binaries копию библиотек MSL_All_Mach-O_D.dylib, перейдя в директорию binaries и введя в командной строке ./hellobeatles.
C++Builder
В меню File выберите New и затем выберите Console Wizard. В диалоге Console Wizard выберите C++, Multi Threaded (Многопоточное) и Console Application (Консольное приложение). Теперь у вас должен быть проект, содержащий один исходный файл Unit1.cpp. Удалите Unit1.cpp из проекта, сделав для этого щелчок правой кнопкой мыши и выбрав Remove From Project (Удалить из проекта). В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введите hello_beatles. Я добавил в имя проекта знак подчеркивания, потому что C++Builder не позволяет указывать для проекта то же имя, что и для исходного файла.
Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options…. Далее перейдите в Directories and Conditionals (Директории и условия) и используйте элемент управления рядом с надписью Final output (Окончательный вывод), чтобы указать, где должен создаваться выходной файл hello_beatles.exe. По умолчанию этот файл будет создан в той же директории, где находится hello_beatles.bpr. Скажите C++Builder, что его требуется создать в директории binaries. Если хотите, то также можете использовать элемент управления рядом с Intermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
После этого, чтобы добавить в проект исходный файл hellobeatles.cpp из примера 1.3, используйте Add to Project (Добавить в проект) из меню Project.
Затем из Project Options перейдите к Directories and Conditionals и, используя элемент управления рядом с Include path (Путь заголовочных файлов), выберите директорию, которая содержит директории johnpaul и georgeringo, — директорию, являющуюся «дедушкой» по отношению к исходным файлам john.hpp, ringo.hpp и другим. Это позволит корректно разрешить директивы include в заголовочном файле hellobeatles.hpp.
Далее сделайте щелчок правой кнопкой мыши на ProjectGroup1, выберите Save Project Group As, выберите директорию, содержащую файл hello_beatles.bpr, и введите имя группы проектов hello_beatles.bpg.
После этого в группу проектов добавьте проекты libjohnpaul.bpr и libgeorgeringo.bpr, сделав щелчок правой кнопкой мыши на надписи hello_beatles и выбрав Add Existing Project. Соберите эти два проекта, как описано в рецептах 1.11 и 1.12, если этого еще не сделано, а затем с помощью Add to Project из меню Project добавьте выходные файлы libjohnpaul.lib и libgeorgeringo.lib в проект hello_beatles. Используя клавишу со стрелкой при нажатой клавише Ctrl, переместите в Project Manager проекты libjohnpaul и libgeorgeringo выше проекта hello_beatles так, чтобы гарантировать, что они будут собираться первыми.
Наконец соберите решение, выбрав в меню Build пункт Make All Projects. Проверьте, что в директории binaries был создан файл с именем hellobeatles.exe. Чтобы запустить приложение, выберите Run в меню Run.
Dev-C++
В меню File выберите New→Project. В диалоге New project (Новый проект) выберите Console Application и C++ Project, а в качестве имени проекта введите hellobeatles. После нажатия на OK укажите место для сохранения настроечных файлов проекта.
Затем от Project Options перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указано hellobeatles.exe. В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директории binaries. Если хотите, то в поле Object file output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
Далее удалите из проекта все существующие исходные файлы, сделав щелчок правой кнопкой мыши и выбрав Remove file (Удалить файл). Для сохранения настроечного файла проекта hellobeatles.dev используйте Save Project as из меню File. Наконец, чтобы добавить в проект исходный файл hellobeatles.cpp из примера 1.3, используйте Add to project (Добавить в проект) из меню Project
Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Options. Затем перейдите к Directories→Include Directories, выберите директорию, которая содержит директории johnpaul и georgeringo — директорию, являющуюся «дедушкой» по отношению к исходным файлам ringo.hpp, ringo.hpp и другим, — и нажмите на Add. Это позволит корректно разрешить директивы include в заголовочном файле hellobeatles.hpp.
Наконец от Project Options перейдите к Directories→Libraries Directories и добавьте директорию, которая содержит выходные файлы libjohnpaul.a и libgeorgeringo.c проектов libjohnpaul и libgeorgeringo. Затем перейдите к Parameters→Linker и введите опции -ljohnpaul и -lgeorgeringo.
Теперь с помощью Compile из меню Execute соберите все три проекта по отдельности, проверив, что hellobeatles собирается последним. Запустите hellobeatles.exe, выбрав в меню Execute пункт Run.
Смотри также
Рецепты 1.5, 1.10 и 1.18.
1.14. Получение GNU make
Проблема
Вы хотите получить и установить утилиту GNU make, используемую для сборки библиотек и исполняемых файлов из исходного кода.
Решение
Решение зависит от вашей операционной системы.
Windows
Хотя в некоторых источниках можно получить готовые бинарные файлы GNU make, чтобы использовать возможности GNU make по максимуму, она должна быть установлена как часть Unix-подобной среды. Я рекомендую использовать либо Cygwin, либо MSYS, являющуюся частью проекта MinGW.
Cygwin и MinGW описаны в рецепте 1.1.
Если вы установили Cygwin, как описано в рецепте 1.1, то GNU make у вас уже есть. Чтобы запустить ее из оболочки Cygwin, просто введите команду make.
Чтобы установить MSYS, начните с установки MinGW, как описано в рецепте 1.1. Будущие версии инсталлятора MinGW могут предоставить опцию для автоматической установки MSYS. Но пока выполните следующие дополнительные действия.
Во-первых, на домашней странице MinGW http://www.mingw.org перейдите на страницу закачки MinGW и скачайте самую последнюю стабильную версию программы установки MSYS. Имя этой программы установки должно иметь вид MSYS-<версия>.exe.
Далее запустите программу установки. После этого будет выдан запрос на ввод пути, где находится установка MinGW, и пути, куда следует устанавливать MSYS. Когда программа установки завершит работу, директория установки MSYS должна содержать файл msys.bat. Запуск этого скрипта приведет к отображению оболочки MSYS — порта оболочки bash, из которой можно запускать GNU make и другие программы MinGW, такие как ar, ranlib и dlltool.
Для использования MSYS не требуется, чтобы поддиректории bin установок MinGW или MSYS были записаны в переменной среды PATH.
Unix
Вначале, введя в командной строке make -v, проверьте, установлена ли в вашей системе утилита GNU make. Если GNU make установлена, она должна вывести сообщение, подобное следующему:
GNU Make 3.90
Copyright (С) 2002 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
Если в системе имеется не-GNU-версия make, то, возможно, GNU-версия установлена под именем gmake. Это можно проверить, введя в командной строке gmake -v.
При использовании Mac OS X простейшим способом получения GNU make является скачивание с web-сайта Apple среды разработки Xcode и следование простым инструкциям ее установки. В настоящий момент Xcode доступен по адресу developer.apple.com/tools.
В других случаях скачайте самую свежую версию GNU make с сайта ftp://ftp.gnu.org/pub/gnu/make, распакуйте ее и следуйте инструкциям по установке.
Обсуждение
Утилита make имеет множество разновидностей. Большая часть инструментариев содержит собственные варианты make. Например, Visual C++ поставляется с утилитой, которая называется nmake.exe. Обычно эти специфичные версии make содержат встроенные функции, которые облегчают их использование с конкретным инструментарием. В результате обсуждение make, которое охватывает множество инструментариев, должно будет описать несколько версий make или иметь дело с ситуациями, когда между какой-то отдельной версией make и конкретным инструментарием не будет соответствия.
Вместо того чтобы описывать несколько утилит make, я решил сконцентрировать внимание на GNU make, которая является наиболее мощным и переносимым вариантом make. GNU make в первую очередь предназначена для работы с GCC. В результате использование GNU make с другим инструментарием, в частности для Windows, иногда может оказаться нетривиальным. Тем не менее, так как GNU make обладает достаточной гибкостью, гораздо проще использовать GNU make с нe-GNU-инструментам и, чем большую часть других make, типа nmake.exe, с инструментарием, отличным от того, для которого они были разработаны.
Основные преимущества GNU make происходят от ее способности исполнять сложные сценарии оболочки. Если вы работаете одновременно и в Unix, и в Windows, вы знаете, что оболочка Windows cmd.exe оставляет желать много большего; в ней отсутствуют многие полезные команды, она имеет ограниченную способность по выполнению сценариев и накладывает жесткие ограничения на длину командной строки. Следовательно, если заставить GNU make использовать cmd.exe, то ее возможности будут сильно ограничены. К счастью, Cygwin и MSYS предоставляют прекрасные среды для использования GNU make в Windows.
MSYS предоставляет минимальную среду, необходимую для запуска в Windows make-файлов и сценариев configure в стиле Unix. Среди прочих полезных инструментов она предоставляет awk, cat, cp, grep, ls, mkdir, mv, rm, rmdir и sed. MSYS была предназначена для работы с GCC и прекрасно с этим справляется. Однако с другими инструментариями для Windows, в частности теми, которые предоставляют .bat-файлы для установки переменных среды и используют для опций командной строки слеши (/) вместо тире (-), она работает несколько менее гладко.
Так, где MSYS минимальна, Cygwin максимальна. Cygwin make может делать все, что может MSYS make, и даже много больше. Однако переносимые make-файлы ограничены узким диапазоном утилит GNU, и они все поддерживаются в MSYS.
Смотри также
Рецепт 1.1.
1.15. Сборка простого приложения «Hello, World» с помощью GNU make
Проблема
Вы хотите с помощью GNU make собрать простую программу «Hello, World», подобную приведенной в примере 1.4.
Решение
Прежде чем вы напишете свой первый make-файл, вы должны познакомиться с терминологией, make-файл состоит из набора правил, имеющих вид
цели: пререквизиты
 команда-сценарий
Здесь цели и пререквизиты — это строки, разделенные пробелами, а команда-сценарий состоит из нуля или более строк текста, каждая из которых начинается с символа табуляции (Tab). Цели и пререквизиты обычно являются именами файлов, но иногда они представляют собой просто формальные имена действий, выполняемых make. Командный сценарий состоит из последовательности команд, передаваемых в оболочку. Грубо говоря, правило говорит make сгенерировать набор целей из набора пререквизитов, выполнив для этого командный сценарий.
Пробелы в make-файлах значимы. Строки, содержащие командные сценарии, должны начинаться с Tab, а не с пробелов — это источник некоторых наиболее распространенных ошибок новичков. В следующих примерах строки, которые начинаются с Tab, указаны с помощью отступа на четыре символа.
Теперь вы готовы начать. В директории, содержащей исходные файлы, создайте текстовый файл с именем makefile. В этом файле объявите четыре цели. Первую цель назовите all и в качестве ее пререквизита укажите имя собираемого исполняемого файла. Она не должна содержать командного сценария. Второй цели присвойте имя исполняемого файла. В качестве ее пререквизитов укажите имена исходных файлов, а в качестве командного сценария укажите команды, которые требуется выполнить для сборки исполняемого файла из исходных файлов. Третья цель должна называться install. У нее не должно быть пререквизитов и должен быть командный сценарий, копирующий исполняемый файл из директории, содержащей make-файл, в директорию, где он должен быть установлен. Последняя цель должна называться clean. Как и install, она не должна иметь пререквизитов. Ее командный сценарий должен удалять из текущей директории исполняемый файл и промежуточные объектные файлы. Цели clean и install должны быть помечены как phony targets (фиктивные цели), для чего используется атрибут PHONY.
Например, чтобы с помощью GCC собрать исполняемый файл из исходного кода из примера 1.4, make-файл может иметь вид, показанный в примере 1.14.
Пример 1.14. make-файл для сборки исполняемого файла с помощью GCC
# Это цель по умолчанию, которая будет собрана при
# вызове make
.PHONY: all
all: hello
# Это правило говорит make, как собрать hello из hello.cpp
hello: hello.cpp
    g++ -o hello hello.cpp
# Это правило говорит make скопировать hello в поддиректорию binaries,
# создав ее, если требуется
.PHONY: install
install:
    mkdir -p binaries
    cp -p hello binaries
# Это правило говорит make удалить hello и hello.о
.PHONY: clean
clean:
    rm -f hello
Чтобы собрать исполняемый файл из исходного кода из примера 1.4 с помощью Visual С++, используйте make-файл, показанный в примере 1.15.
Пример 1.15. make-файл для сборки исполняемого файла с помощью Visual С++.
#цель по умолчанию
.PHONY: all
all: hello.exe
#правило для сборки hello.exe
hello.exe: hello.cpp
    cl -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t \
    -Fehello hello.cpp
.PHONY: install
install:
    mkdir -о binaries
    cp -p hello.exe binaries
.PHONY: clean
clean:
    rm -f hello.exe
Команды и списки целей или пререквизитов могут занимать несколько строк текста make-файла, для чего используется символ продолжения строки \, как и в исходных файлах С++.
Чтобы собрать исполняемый файл, установите переменные среды, необходимые для инструментов командной строки, перейдите в директорию, содержащую makefile, и введите make. Чтобы скопировать исполняемый файл в поддиректорию binaries, введите make install. Чтобы удалить из директории make-файла исполняемый файл и промежуточный объектный файл, введите make clean.
Если вы установили среду Cygwin, описанную в рецепте 1.1, можете выполнить make-файл из примера 1.15 непосредственно из оболочки Windows cmd.exe.
Также этот make-файл можно выполнить из оболочки Cygwin, как описано далее. В cmd.exe запустите vcvars32.bat, устанавливающий переменные среды Visual С++. Затем запустите cygwin.bat, запускающий оболочку Cygwin. Если директория установки Cygwin добавлена в PATH, то оболочку Cygwin можно запустить из cmd.exe, просто введя cygwin. Наконец, перейдите в директорию, содержащую make-файл, и введите make.
Аналогично можно выполнить make-файл из оболочки MSYS: в cmd.exe запустите vcvars32.bat, затем запустите msys.bat, запускающий оболочку MSYS.
Если ваш инструментарий предоставляет сценарий для установки переменных среды, запуск make-файла из Cygwin или MSYS несколько более трудоемок, чем его запуск из cmd.exe. Однако для некоторых make-файлов это обязательное условие, так как они не будут работать из-под cmd.exe.
Обсуждение
В нескольких последующих рецептах вы увидите, что GNU make является достаточно мощным инструментом для сборки сложных проектов. Но что же она делает? Вот как она работает. При вызове make без аргументов она просматривает текущую директорию в поисках файла с именем GNUmakefile, makefile или Makefile и пытается собрать первую содержащуюся в нем цель, которая называется целью по умолчанию (default target). Если цель по умолчанию не устарела, что означает, что она существует, все ее пререквизиты существуют и ни один из них не был изменен с момента ее сборки, то работа make закончена. В противном случае она пытается сгенерировать цель по умолчанию из ее пререквизитов, выполнив соответствующий командный сценарий. Аналогично определению устаревания этот процесс рекурсивен: для каждого устаревшего пререквизита make ищет правило, содержащее этот пререквизит в качестве цели, и начинает весь процесс заново. Так продолжается до тех пор, пока цель по умолчанию не будет обновлена или пока не возникнет ошибка.
Из приведенного описания следует, что цель, не имеющая пререквизитов, не устаревает только в том случае, если она соответствует файлу в файловой системе. Следовательно, цель, соответствующая несуществующему файлу, всегда будет устаревшей и может использоваться для безусловного выполнения командного сценария. Такие цели называются phony targets (фиктивными).
Пометив цель атрибутом .PHONY, как в примерах 1.14 и 1.15, можно сказать make, что цель не соответствует файлу, и, таким образом, она всегда должна собираться заново.
И наоборот, пререквизит, соответствующий существующему файлу, никогда не устаревает при условии, что этот файл не указан в качестве цели одного из правил.
Теперь давайте посмотрим на то, что происходит при выполнении make-файла из примера 1.14. Фиктивная цель all всегда устаревшая: единственная ее цель — сказать make собрать hello.exe. В таком простом make-файле нет необходимости в цели all, но в более сложных примерах цель all может иметь несколько пререквизитов, правило с целью hello говорит make собрать, если требуется, hello с помощью g++. Если предположить, что текущая директория не содержит ничего, кроме файлов makefile и hello.cpp, цель hello будет устаревшей. Однако пререквизит не устарел, так как файл hello.cpp существует и так как hello.cpp не является целью одного из правил. Следовательно, make для компиляции и компоновки hello.cpp вызывает g++, генерируя тем самым файл hello. Пререквизит цели all обновляется, так что make собирает цель all — исполняя пустой командный сценарий — и выходит.
При вызове make с аргументом командной строки, соответствующим цели, make пытается собрать эту цель. Следовательно, выполнение make install приводит к выполнению следующих команд:
mkdir -p binaries
cp -p hello binaries
Первая команда создает, если она не существует, директорию binaries, а вторая команда копирует в эту директорию файл hello. Точно так же make clean вызывает команду
rm -f hello
которая удаляет hello.
При использовании Windows команды mkdir, cp и rm, используемые целями install и clean, указывают на инструменты GNU, поставляющиеся в составе Cygwin или MSYS
После того как вы поймете, как make анализирует зависимости, пример 1.14 покажется очень простым. Однако на самом деле он значительно сложнее, чем требуется. Рассмотрение различных методов его упрощения является хорошим способом узнать некоторые из основ make-файлов.
Переменные make
GNU make поддерживает переменные, чьими значениями являются строки. Наиболее часто переменные используются в make-файлах как символьные константы. Вместо того чтобы жестко указывать в нескольких местах make-файла имя файла или команды оболочки, вы можете присвоить имя файла или команды переменной и далее использовать эту переменную. Это дает возможность облегчить сопровождение make-файлов. Например, make-файл из примера 1.14 можно переписать с помощью переменных make так, как показано в примере 1.16.
Пример 1.16. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью переменных
# Указываем целевой файл и директорию установки
OUTPUTFILE=hello
INSTALLDIR=binaries
# Цель по умолчанию
.PHONY all
all: $(OUTPUTFILE)
# Собрать hello из hello.cpp
$(OUTPUTFILE): hello cpp
    g++ -o hello hello.cpp
#Скопировать hello в поддиректорию binaries
.PHONY: install
install:
    mkdir -p $(INSTALLDIR)
    cd -p $(OUTPUTFILE) $(INSTALLDIR)
# Удалить hello
.PHONY: clean
clean:
    rm -f $(OUTPUTFILE)
Здесь я ввел две переменные make — OUTPUTFILE и INSTALLDIR. Как вы можете видеть, значения переменным make присваиваются с помощью оператора присвоения =, и они вычисляются с помощью заключения их в круглые скобки с префиксом в виде знака доллара.
Также установить значение переменной make можно в командной строке с помощью записи make X=Y. Кроме того, при запуске make все переменные среды используются для инициализации переменных make с такими же именами и значениями. Значения, указанные в командной строке, имеют приоритет перед значениями, унаследованными от переменных среды. Значения, указанные в самом make-файле, имеют приоритет перед значениями, указанными в командной строке.
Также GNU make поддерживает автоматические переменные (automatic variables), имеющие специальные значения при выполнении командного сценария. Наиболее важные из них — это переменная $@, представляющая имя файла цели, переменная $<, представляющая имя файла первого пререквизита, и переменная $^,представляющая последовательность пререквизитов, разделенных пробелами. Используя эти переменные, мы можем еще сильнее упростить make-файл из примера 1.16, как показано в примере 1.17.
Пример 1.17. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью автоматических переменных
# Указываем целевой файл и директорию установки
OUTPUTFILE=hellо
INSTALLDIR=binaries
# Цель по умолчанию
.PHONY all
all: $(OUTPUTFILE)
# Собрать hello из hello.cpp
$(OUTPUTFILE) hello.cpp
    g++ -o $@ $<
# Цели Install и clean как в примере 1 16
В командном сценарии g++ -o $@ $< переменная $@ раскрывается как hello, а переменная $< раскрывается как hello.cpp. Следовательно, make-файл из примера 1.17 эквивалентен файлу из примера 1.16, но содержит меньше дублирующегося кода.
Неявные правила
make-файл в примере 1.17 может быть еще проще. На самом деле командный сценарий, связанный с целью hello, избыточен, что демонстрируется выполнением make-файла из примера 1.18.
Пример 1.18. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью неявных правил
# Указываем целевой файл и директорию установки
OUTPUTFILE=hello
INSTALLDIR=binaries
# Цель по умолчанию
.PHONY: all
all: $(OUTPUTFILE)
# Говорим make пересобрать hello тогда, когда изменяется hello.cpp
$(OUTPUTFILE): hello.cpp
# Цели Install и clean как в примере 1.16
Откуда make знает, как собирать исполняемый файл hello из исходного файла hello.cpp, без явного указания? Ответ состоит в том, что make содержит внутреннюю базу данных неявных правил, представляющих операции, часто выполняемые при сборке приложений, написанных на С и С++. Например, неявное правило для генерации исполняемого файла из файла .cpp выглядит так, как в примере 1.19.
Пример 1.19. Шаблон правила из внутренней базы данных make
%: %.cpp
# исполняемые команды (встроенные):
    $(LINK.cpp) $(LOADLIBS) $(LDLIBS) -о $@
Правила, первые строки которых имеют вид %xxx:%yyy, известны как шаблонные правила (pattern rules), а символ % действует как подстановочный знак (wildcard). Когда устаревшему пререквизиту не соответствует ни одно из обычных правил, make ищет доступные шаблонные правила. Для каждого шаблонного правила make пытается найти строку, которая при подстановке подстановочного знака в целевую часть правила даст искомый устаревший пререквизит. Если make находит такую строку, make заменяет подстановочные знаки для цели и пререквизитов шаблонного правила и создает новое правило. Затем make пытается собрать устаревший пререквизит с помощью этого нового правила.
Чтобы напечатать базу данных неявных правил GNU make, используйте make -p.
Например, при первом выполнении make-файла из примера 1.18 пререквизит hello цели по умолчанию all является устаревшим. Хотя hello фигурирует как цель правила $(OUTPUTFILE): hello.cpp, это правило не содержит командного сценария, и, таким образом, оно бесполезно для сборки файла hello. Следовательно, make выполняет поиск в своей внутренней базе данных и находит правило, показанное в примере 1.19. Подставляя в правило из примера 1.19 вместо подстановочного знака строку hello, make генерирует следующее правило с hello в качестве цели.
hello: hello.cpp
    $(LINK.cpp) $(LOADLIBS) $(LDLIBS) -o $@
Пока все хорошо, но есть еще кое-что. Повторный взгляд на внутреннюю базу данных make показывает, что переменная LINK.cpp по умолчанию раскрывается как $(LINK.cc). В свою очередь LINK.cc по умолчанию раскрывается как
$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
Наконец, переменная CXX по умолчанию раскрывается как g++, а четыре другие переменные — $(CXXFLAGS), $(CPPFLAGS), $(LDFLAGS) и $(TARGET_ARCH) — раскрываются как пустые строки. После выполнения всех этих подстановок получается следующее правило, которое теперь выглядит более знакомо.
hello: hello.cpp
    g++ $^ -o $@
Запутались? Это не страшно. Если вы изучите приведенное объяснение и потратите некоторое время на изучение внутренней базы данных make, неявные правила приобретут смысл.
Возможности для настройки
Теперь, когда вы увидели, как шаблонное правило из примера 1.19 приводит к тому, что make собирает исполняемый файл hello из исходного файла hello.cpp, вы можете спросить, почему было необходимо использовать столько промежуточных шагов. Почему вместо сложного правила из примера 1.19 во внутреннюю базу данных make просто не добавить правило
%: %.cpp
    g++ $^ -о $@
Ответ состоит в том, что промежуточные переменные, такие как $(CXX), $(CXXFLAGS), $(CPPFLAGS) и $(LDFLAGS), служат как точки настройки (customization points). Например, указав значение LDFLAGS в командной строке, в make-файле или установив значение переменной среды, можно указать дополнительные флаги, передаваемые компоновщику. Переменные CPPFLAGS и CXXFLAGS играют схожую роль для опций препроцессора и компилятора C++ соответственно. А установив значение переменной CXX, можно указать компилятор, отличный от GCC. Например, чтобы собрать hello с помощью Intel для Linux и используя make-файл из примера 1.18, вы должны в командной строке ввести make CXX=icpc, предполагая, что переменные среды, необходимые для компилятора Intel, уже установлены.
VPATH и директива vpath
В примере 1.18 make может применить правильное шаблонное правило, потому что файл .cpp находится в той же директории, в которой создается выходной файл. Если исходные файлы находятся в другой директории, то для указания make, где искать цели или пререквизиты, используется переменная VPATH.
VPATH = <путь-к-файлам-cpp>
Чтобы сказать make, что выполнять поиск определенных типов файлов требуется в определенном месте, используйте директиву vpath.
# искать файлы .exp в ../lib
vpath %. exp../lib
Смотри также
Рецепты 1.2 и 1.7.
1.16. Сборка статической библиотеки с помощью GNU Make
Проблема
Вы хотите использовать GNU make для сборки статической библиотеки из набора исходных файлов C++, таких как перечисленные в примере 1.1.
Решение
Вначале в директории, где должна быть создана статическая библиотека, создайте make-файл и объявите фиктивную цель all, единственным пререквизитом которой будет статическая библиотека. Затем объявите цель статической библиотеки. Ее пререквизитами должны быть объектные файлы, входящие в состав библиотеки, а ее командный сценарий должен представлять собой командную строку для сборки библиотеки из набора объектных файлов, аналогично показанному в рецепте 1.3. При использовании GCC или компилятора с похожим синтаксисом командной строки настройте, если требуется, неявные правила шаблонов, изменив одну или более переменных CXX, CXXFLAGS и т.п., используемых в базе данных неявных правил make, как показано в рецепте 1.15. В противном случае, используя синтаксис шаблонных правил, описанный в рецепте 1.16, напишите шаблонное правило, говорящее make, как с помощью командной строки из табл. 1.8 компилировать .cpp-файлы в объектные. Далее явно или неявно объявите цели, указывающие, как каждый из исходных файлов библиотеки зависит от включаемых в него заголовков. Эти зависимости можно описать вручную или сгенерировать их автоматически. Наконец, добавьте цели install и clean, как показано в рецепте 1.15.
Например, чтобы с помощью GCC в Unix собрать из исходных файлов, перечисленных в примере 1.2, статическую библиотеку, создайте в директории johnpaul make-файл, показанный в примере 1.20.
Пример 1 20. make-файл для создания libjohnpaul.a с помощью GCC в Unix
# Укажите расширения файлов, удаляемых при очистке
CLEANEXTS - о а
# Укажите целевой файл и директорию установки
OUTPUTFILE = libjohnpaul.a
INSTALLDIR = ../binaries
# Цель по умолчанию
.PHONY: all
all: $(OUTPUTFILE)
# Соберите libjohnpaul.a из john.o. paul.o и johnpaul.с
$(OUTPUTFILE): john.o paul.o johnpaul.о
    ar ru $@ $^
    ranlib $@
# Для сборки john.o, paul.o и johnpaul.о из файлов .cpp
# правила не требуются; этот процесс обрабатывается базой данных
# неявных правил make
.PHONY: install
install:
    mkdir -p $(INSTALLDIR)
    cp -p $(OUTPUTFILE) $(INSTALLDIR)
.PHONY: clean
clean:
    for file in $(CLEANEXTS); do rm -f *.$$file; done
# Укажите зависимости файлов cpp от файлов .hpp
john.o: john.hpp
paul.o: paul.hpp
johnpaul.o: john.hpp paul.hpp johnpaul.hpp
Аналогично, чтобы собрать статическую библиотеку с помощью Visual С++, ваш make-файл должен выглядеть, как показано в примере 1.21.
Пример 1.21. make-файл для создания libjohnpaul.lib с помощью Visual C++
# Укажите расширения файлов, удаляемых при очистке
CLEANEXTS = obj lib
# Specify the target file and the install directory
OUTPUTFILE = libjohnpaul.lib
INSTALLDIR = ./binaries
# Шаблонное правило для сборки объектного файла из файла .cpp
%.obj: %.cpp
    "$(MSVCDIR)/bin/cl" -с -nologo -EHsc -GP -Zc:forScope -Zc:wchar_t \
    $(CXXFLAGS) S(CPPFLAGS) -Fo"$@" $<
# Фиктивная цель
.PHONY: all
all: $(OUTPUTFILE)
# Соберите libjohnpaul.lib из john.obj, paul.obj и johnpaul.obj
$(OUTPUTFILE): john.obj paul.obj johnpaul.obj
    "$(MSVCDIR)/bin/link" -lib -nologo -out:"$@" $^
.PHONY: install
install:
    mkdir -p $(INSTALLDIR)
    cp -p $(OUTPUTFILE) $(INSTALLDIR)
.PHONY: clean
clean:
    for file in $(CLEANEXTS); do rm -f *.$$file; done
# Укажите зависимости файлов .cpp от файлов .hpp
john.obj: john.hpp
paul.obj: paul.hpp
johnpaul.obj: john.hpp paul.hpp johnpaul.hpp
В примере 1.21 я с помощью переменной среды MSVCDIR, устанавливаемой в vcvars32.bat, показал команду Visual C++ link.exe как "$(MSVCDIR)/bin/link". Это позволяет избежать путаницы между компоновщиком Visual C++ и командой Unix link, поддерживаемой Cygwin и MSYS. Для полноты картины я также использовал MSVCDIR для команды компиляции Visual С++.
Обсуждение
Давайте подробно рассмотрим пример 1.20. Вначале я определяю переменные, представляющие выходной файл, директорию установки и расширения файлов, которые должны удаляться при сборке цели clean. Затем я объявляю цель по умолчанию all, как в примере 1.14.
Правило для сборки статической библиотеки выглядит так.
$(OUTPUTFILE): john.o paul.o johnpaul.о
    ar ru $@ $^
    ranlib $@
Это непосредственная адаптация записи для GCC из табл. 1.10. Здесь $(OUTPUTFILE) и $@ раскрываются как libjohnpaul.a, а $^ раскрывается в виде списка пререквизитов john.o paul.o johnpaul.о.
Следующие два правила объявляют цели install и clean, как в рецепте 1.15. Единственное отличие состоит в том, что в примере 1.20 для удаления всех файлов, чьи расширения имеются в списке о а — т. е. все объектные файлы и файлы статической библиотеки, - я использую цикл оболочки.
for file in $(CLEANEXTS); do rm -f *.$$file; done
Двойной знак доллара я использовал для того, чтобы запретить make раскрывать переменную $$file при передаче ее оболочке.
Три последних правила указывают отношения зависимостей между файлами .cpp библиотеки и включаемыми в них заголовочными файлами. Здесь указано по одному правилу для каждого .cpp-файла. Целью такого правила является объектный файл, собираемый из .cpp-файла, а пререквизитами являются заголовочные файлы, явно или неявно включаемые .cpp-файлом.
john.o: john.hpp
paul.o: paul.hpp
johnpaul.o. john.hpp paul.hpp johnpaul.hpp
Это можно понять следующим образом. Если .cpp-файл явно или косвенно включает заголовочный файл, то он должен быть пересобран при каждом изменении этого заголовочного файла. Однако, так как .cpp-файл существует и не является целью какого-либо правила, он никогда не устаревает, как описано в рецепте 1.15. Следовательно, при изменении заголовочного файла перекомпиляции не происходит. Чтобы исправить эту ситуацию, требуется объявить правило, сделав эти зависимости явными; когда один из используемых заголовочных файлов изменяется, объектный файл, соответствующий .cpp-файлу, устаревает, что приводит к перекомпиляции .cpp-файла.
Это решение удобно только для очень небольших проектов, так как очень сложно постоянно отслеживать зависимости целей, представляющих собой исходные файлы, входящие в большую базу кода. К счастью, имеется несколько способов автоматической генерации этих зависимостей. Например, три последних правила примера 1.20 можно заменить на следующие.
# Генерируем зависимости .cpp-файлов от .hpp-файлов
include john.o paul.o johnpaul.о
%.d: %.cpp
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's.\($*\)\.o[ :]*.\1.o $@ : ,g' < $@.$$$$ > $@, \
    rm -f $@.$$$$
Этот фрагмент кода основан на опции компилятора -M, которая заставляет GCC вывести в make-файл информацию о зависимостях. За подробным описанием того, как это работает, и почему иногда не подходит, обратитесь к книге Managing Projects with GNU make, Third Edition, написанной Робертом Мекленбургом (Robert Mecklenburg) (O'Reilly).
Код для генерации зависимостей помещайте в конец make-файла.
Так как большинство компиляторов имеет опцию, аналогичную опции -М GCC, этот метод может быть адаптирован для работы с большинством инструментов. На самом деле обычно эта опция называется -М или -m. Однако Visual C++ не имеет опции для генерации зависимостей в make-файле. При использовании Visual C++ есть две возможности. Можно использовать опцию -Gm совместно с опциями -Zi или -ZI, обсуждаемыми в рецепте 1.21. Опция -Gm говорит компилятору создать базу данных, сохраняемую в файле с расширением idb, содержащую информацию о зависимостях между исходными файлами. Файл .idb создается при первоначальной компиляции файла или набора файлов .cpp. При последующих компиляциях перекомпилируются только те исходные файлы, которые были изменены или зависят от изменившихся заголовочных файлов.
Кроме того, можно использовать опцию -showIncludes совместно с опцией -E. Опция -showIncludes приводит к тому, что компилятор при каждом обнаружении директивы include выводит в стандартный поток ошибок сообщение. Опция -E говорит компилятору запустить препроцессор и выйти, не создавая никаких двоичных файлов. С помощью небольшого сценария оболочки можно использовать вывод, сгенерированный -showIncludes; для создания зависимостей в make-файле.
include john.d paul.d johnpaul.d
%d: %.cpp
    "$(MSVCDIR)/bin/cl" -E -showIncludes $< 2> $@.$$$$ > /dev/null; \
    sed -n 's/^Note: including file: *\(.*\)/$*.obj•$*.d:\1/gp' \
    < $@.$$$$ | sed "s:\\:/:g:s: :\\ :gp" > $@; \
    rm -f $@.$$$$
В этом примере символ • обозначает Tab.
Давайте сделаем еще одно последнее усовершенствование примера 1.20. В настоящий момент последовательность john paul johnpaul содержится в двух местах — в пререквизитах правила для сборки статической библиотеки и в директиве include, используемой для генерации зависимостей. Если список исходных файлов изменится, вам придется вносить изменения в двух местах make-файла. Гораздо лучше определить переменную SOURCES и заменить оба использования последовательности john paul johnpaul на выражения, использующие SOURCES.
SOURCES = john.cpp paul.cpp johnpaul.cpp
...
# Собираем libjohnpaul.a из john.о, paul.o и johnpaul.о
$(OUTPUTFILE): $(subst .cpp, .o,$(SOURCES))
    ar ru $@ $^
    ranlib $@
...
# Генерируем зависимости .cpp-файлов от .hpp-файлов
include $(subst .cpp,.d,$(SOURCES))
%d: %.cpp
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*.\1.o $@ : .g' < $@ $$$$ > $@; \
    rm -f $@.$$$$
Здесь я использую функцию make $(subst x, y, str), которая заменяет в строке str все вхождения x на y.
GNU make поддерживает большое количество функций обработки строк и имен файлов, а также много других. Также она поддерживает определение пользовательских функций. Как обычно, за подробным описанием обратитесь к Managing Projects with GNU make, Third Edition Роберта Мекленбурга (O'Reilly).
Смотри также
Рецепты 1.2 и 1.7.
1.17. Сборка динамической библиотеки с помощью GNU Make
Проблема
Вы хотите использовать GNU make для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.
Решение
Вначале в директории, где должна быть создана динамическая библиотека, создайте make-файл и объявите фиктивную цель all, единственным пререквизитом которой будет эта динамическая библиотека. Затем объявите цель динамической библиотеки. Ее пререквизитами должны быть объектные файлы, из которых она собирается, а ее командный сценарий должен представлять собой командную строку для сборки библиотеки из набора объектных файлов, аналогично показанному в рецепте 1.4. При использовании GCC или компилятора с похожим синтаксисом командной строки настройте, если требуется, неявные правила шаблонов, изменив одну или более переменных CXX, CXXFLAGS и т.п., используемых в базе данных неявных правил make, как показано в рецепте 1.15. В противном случае, используя синтаксис шаблонных правил, описанный в рецепте 1.16, напишите шаблонное правило, говорящее make, как с помощью командной строки из табл. 1.8 скомпилировать .cpp-файлы в объектные. Наконец добавьте цели install и clean, как показано в рецепте 1.15, и механизм для автоматической генерации зависимостей исходных файлов, как показано в рецепте 1.16.
Например, чтобы из исходных файлов, перечисленных в примере 1.2, собрать динамическую библиотеку с помощью GCC в Unix, в директории georgeringo создайте make-файл, показанный в примере 1.22.
Пример 1.22. make-файл для libgeorgeringo.so с использованием GCC
# Укажите расширения файлов, удаляемых при очистке
CLEANEXTS = o so
# Укажите исходные файлы, целевой файл и директорию установки
SOURCES = george.cpp ringo.cpp georgeringo.cpp
OUTPUTFILE = libgeorgeringo.so
INSTALLDIR = ../binaries
.PHONY: all
all: $(OUTPUTFILE)
# Соберите libgeorgeringo.so из george.o, ringo.о
# и georgeringo.o; subst - это функция поиска и замены.
# показанная в рецепте 1.16
$(OUTPUTFILE): $(subst .cpp,.o,$(SOURCES))
    $(CXX) -shared -fPIC $(LDFLAGS) -о
.PHONY: install
install:
    mkdir -p $(INSTALLDIR)
    cp -p $(OUTPUTFILE) $(INSTALLDIR)
.PHONY: clean
clean:
    for file in $(CLEANEXTS); do rm -f *.$$file; done
# Сгенерируйте зависимости файлов .cpp от файлов .hpp
    include $(subst .cpp,.d,$(SOURCES))
%.d: %.cpp
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's. \($*\)\.o[ :]*.\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
Обсуждение
make-файл из примера 1.22 — это прямое применение идей из рецептов 1.4, 1.15 и 1.16. Главным отличием между примерами 1.22 и 1.20 является правило для сборки libgeorgeringo.so из объектных файлов george.o, ringo.o и georgeringo.о.
$(OUTPUTFILE): $(subst .cpp,.o,$(SOURCES))
$(CXX) -shared -fPIC $(LDFLAGS) -о $@ $^
Здесь $(OUTPUTFILE) раскрывается как libgeorgeringo.so, а выражение $(subst.cpp, .o, $(SOURCES)) раскрывается как george.о, ringo.о и georgeringo.o, как показано в рецепте 1.16. Командный сценарий $(CXX) -shared -fPIC $(LDFLAGS) -о — это адаптация командной строки GCC, показанной в табл. 1.11.
Смотри также
Рецепты 1.4, 1.9, 1.12, 1.19 и 1.23.
1.18. Сборка сложного приложения с помощью GNU make
Проблема
Вы хотите использовать GNU make для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.
Решение
Выполните следующие действия.
1. Создайте make-файлы для библиотек, используемых приложением, как описано в рецептах 1.16 и 1.17. Эти make-файлы должны находиться в отдельных директориях.
2. Создайте make-файл в еще одной директории. Этот make-файл будет использоваться для сборки приложения, но только после того, как будут выполнены make-файлы из шага 1. Укажите в этом make-файле фиктивную цель all, чьим пререквизитом будет являться исполняемый файл. Объявите цель исполняемого файла с пререквизитами, состоящими из библиотек, используемых приложением, а также объектных файлов, которые собираются из .cpp-файлов приложения. Напишите командный сценарий для сборки исполняемого файла из набора библиотек и объектных файлов, как описано в рецепте 1.5. Если необходимо, напишите шаблонное правило для генерации объектных файлов из .cpp-файлов, как показано в рецепте 1.16. Добавьте цели install и clean, как показано в рецепте 1.15, и механизм для автоматической генерации зависимостей исходных файлов, как показано в рецепте 1.16.
3. В директории, родительской по отношению к директориям, содержащим все остальные make-файлы, создайте новый make-файл — давайте называть его главным (top-level) make-файлом, а все остальные — подчиненными. Объявите цель по умолчанию all с пререквизитами в виде директории, содержащей make файл, созданный на шаге 2. Объявите правило, чьи цели состоят из директорий, содержащих подчиненные make-файлы, а командный сценарий вызывает make в каждой целевой директории для цели, указанной в виде значения переменной TARGET. Наконец, объявите цели, указывающие зависимости между целями по умолчанию подчиненных make-файлов.
Например, чтобы из исходных файлов из примера 1.3 собрать исполняемый файл с помощью GCC в Unix, создайте такой make-файл, как показанный в примере 1.23.
Пример 1.23. make файл для hellobeatles.exe с использованием GCC
# Укажите исходные файлы, целевой файл, директории сборки
# и директорию установки
SOURCES = hellobeatles.cpp
OUTPUTFILE = hellobeatles
LIBJOHNPAUL = libjohnpaul.a
LIBGEORGERINGO = libgeorgeringo.so
JOHNPAULDIR = ../johnpaul
GEORGERINGODIR = ../georgeringo
INSTALLDIR = ../binaries
#
# Добавьте в путь поиска заголовочных файлов родительскую директорию
#
CPPFLAGS += -I..
#
# Цель по умолчанию
#
.PHONY: all
all: $(HELLOBEATLES)
#
# Цель для сборки исполняемого файла.
#
$(OUTPUTFILE): $(subst .cpp,.о,$(SOURCES)) \
 $(JOHNPAULDIR)/$(LIBJOHNPAUL) \
 $(GEORGERINGODIR)/$(LIBGEORGERINGO)
    $(CXX) $(LDFLAGS) -o $@ $^
.PHONY: install
install:
    mkdir -p $(INSTALLDIR)
    cp -p $(OUTPUTFILE) $(INSTALLDIR)
.PHONY: clean
clean:
    rm -f *.o
    rm -f $(OUTPUTFILE)
#Сгенерируйте зависимости .cpp-файлов от .hpp-файлов
include $(subst .cpp,.d,$(SOURCES))
%.d: %.cpp
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@..$$$$ > $@; \
    rm -f $@.$$$$
Далее в директории, содержащей johnpaul, georgeringo, hellobeatles и binaries, создайте главный make-файл, как показано в примере 1.24.
Пример 1.24. Главный make-файл для исходного кода из примеров 1.1, 1.2 и 1.3
# Все цели в этом make-файле — фиктивные
PHONY: all johnpaul georgeringo hellobeatles
# Цель по умолчанию
all: hellobeatles
# Цели johnpaul, georgeringo и hellobeatles представляют
# директории, командный сценарий вызывает make в каждой из них
johnpaul georgeringo hellobeatles
$(MAKE) --directory=$@ $(TARGET)
# Это правило указывает что цель по умолчанию make-файла
# в директории hellobeatles зависит от целей по умолчанию
# make-файлов из директорий johnpaul и georgeringo
.PHONY: hellobeatles
hellobeatles: johnpaul georgeringo
Чтобы собрать hellobeatles, перейдите в директорию, содержащую главный make-файл, и введите make. Чтобы скопировать файлы libjohnpaul.a, libgeorgeringo.so и hellobeatles в директорию binaries, введите make TARGET=install. Чтобы очистить проект, введите make TARGET=clean.
Обсуждение
Подход к управлению сложными проектами, продемонстрированный в этом рецепте, известен как рекурсивный make (recursive make). Он позволяет организовать проект в виде набора модулей, каждый со своим собственным make-файлом, и указать зависимости между этими модулями. Он не ограничен одним главным make-файлом с набором дочерних make-файлов: эта методика может применяться для обработки многоуровневых древовидных структур. В то время, пока рекурсивный make был стандартной методикой управления большими проектами с помощью make, появились другие методы, которые теперь рассматриваются как более качественные. За подробностями снова обратитесь к Managing Projects with GNU make, Third Edition Роберта Мекленбурга (O'Reilly).
Пример 1.23 — это прямое применение методик, продемонстрированных в рецептах 1.15, 1,16 и 1.17. В нем есть один очень интересный момент. Как показано в рецепте 1.15, при компиляции hellobeatles.cpp из командной строки необходимо использовать опцию -I.., говорящую компилятору, где искать заголовочные файлы johnpaul.hpp и georgeringo.hpp. Одним из возможных решений является написание явного правила сборки hellobeatles.o с помощью командного сценария, содержащего опцию -I.. подобно этому.
hellobeatles.o: hellobeatles.cpp
g++ -с -I.. -о hellobeatles.o hellobeatles.cpp
Вместо этого я использовал точку настройки CPPFLAGS, описанную в рецепте 1.15, и указал, что всегда, когда происходит компиляция объектного файла из файла .cpp, в командную строку должна быть добавлена опция -I..:
CPPFLAGS += -I..
Вместо оператора присвоения = я использовал +=, так что новое значение будет добавляться к тому значению CPPFLAGS, которое могло быть указано в командной строке или в переменной среды.
Теперь давайте посмотрим на то, как работает пример 1.24. Наиболее важным правилом является то, которое заставляет make вызываться для каждой из директорий johnpaul, georgeringo и hellobeatles.
johnpaul georgeringo hellobeatles:
$(MAKE) --directory=$@ $(TARGET)
Чтобы понять это правило, вы должны знать три вещи. Во-первых, переменная MAKE раскрывается как имя запущенного в данный момент экземпляра make. Обычно это будет make, но на некоторых системах это может быть gmake. Во-вторых, опция командной строки --directory=<path> заставляет make вызваться с <path> в качестве текущей директории. В-третьих, правило с несколькими целями эквивалентно набору правил, каждое из которых имеет по одной цели и которые содержат одинаковые командные сценарии. Так что приведенное выше правило эквивалентно следующим.
johnpaul:
    $(MAKE) --directory=$@ $(TARGET)
georgeringo:
    $(MAKE) --directory=$@ $(TARGET)
hellobeatles:
    $(MAKE) --directory=$@ $(TARGET)
В свою очередь это эквивалентно:
johnpaul:
    $(MAKE) --directory=johnpaul $(TARGET)
georgeringo:
    $(MAKE) --directory=georgeringo $(TARGET)
hellobeatles:
    $(MAKE) -directory=hellobeatles $(TARGET)
Следовательно, эффект от этого правила состоит в вызове make-файлов в каждой из директорий johnpaul, georgeringo и hellobeatles, а в командной строке передаётся значение переменной TARGET. В результате для сборки цели xxx в каждом из подчиненных make-файлов требуется выполнить главный make-файл с опцией TARGET=xxx.
Последнее правило make-файла гарантирует, что подчиненные make-файлы вызываются в правильном порядке; оно просто объявляет цель hellobeatles, зависящую от целей johnpaul и georgeringo.
hellobeatles: johnpaul georgeringo
В более сложном приложении может иметься большое количество зависимостей между исполняемым файлом и входящими в него библиотеками. Для каждой такой компоненты требуется объявить правило, указывающее другие компоненты, от которых она явно зависит.
Смотри также
Рецепты 1.5, 1.10 и 1.13.
1.19. Определение макроса
Проблема
Вы хотите определить символ препроцессора name, присвоив ему либо неопределенное значение, либо значение value.
Решение
Опции компилятора для определения макросов в командной строке показаны в табл. 1.16. Инструкции для определения макросов в IDE приведены в табл. 1.17. Чтобы определить макрос с помощью Boost.Build, просто добавьте в требования цели свойство вида <define>name[=value], как показано в табл. 1.15 и примере 1.12.
Табл. 1.16. Определение макроса из командной строки
Инструментарий	Опции
Все	-Dname[-value]
Табл. 1.17. Определение макроса из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Preprocessor и в Preprocessor Definitions (определения препроцессора) введите name[=value], для разделения нескольких записей используя точку с запятой
CodeWarrior	В окне Target Settings перейдите к Language Settings→C/C++ Preprocessor и введите: #define name[=value] в поле с именем Prefix Text
C++Builder	В Project Options перейдите к Directories/Conditionals и в Preprocessor Definitions введите name[=value], для разделения нескольких записей используя точку с запятой
Dev-C++	В Project Options выберите Parameters и введите: -Dname[=value] в области C++ Compiler
Обсуждение
Символы препроцессора часто используются в коде C++ для того, чтобы один набор исходных файлов мог быть использован в нескольких конфигурациях сборки или операционных системах. Например, предположим, что вы хотите написать функцию, проверяющую, является ли имя объекта именем файла или директории. Сейчас стандартная библиотека C++ не предоставляет функциональности, необходимой для выполнения этой задачи. Следовательно, эта функция должна использовать функции, специфичные для платформы. Если вы хотите, чтобы этот код работал и в Windows, и в Unix, вы должны убедиться, что код, использующий специфичные для Windows функции, невидим для компилятора при компиляции под Unix, и наоборот. Обычным способом достижения этого эффекта является использование условной компиляции, иллюстрируемой в примере 1.25.
Пример 1.25. Условная компиляция с помощью предопределенных макросов
#ifdef _WIN32
# include <windows.h>
#else // He Windows - предположим, что мы в Unix
# include <sys/stat.h>
#endif
bool is_directory(const char* path) {
#ifdef _WIN32
 // реализация для Windows
#else
 // реализация для Unix
#endif
}
В Windows все наборы инструментов, за исключением порта GCC Cygwin, определяют макрос _WIN32. Макрос, определяемый автоматически, называется предопределенным макросом. Пример 1.25 использует предопределенный макрос WIN32 для определения, под какой операционной системой он компилируется, и для включения соответствующего специфичного для платформы кода.
Однако часто настроечная информация, необходимая для выполнения подобного рода условной компиляции, в виде предопределенных макросов недоступна. В таких случаях необходимо создать собственные макросы и с помощью методов, показанных в табл. 1.15, 1.16 и 1.17, присвоить им соответствующие значения. Хорошим примером является пример 1.2. В Windows при сборке DLL georgeringo.dll функция georgeringo() должна быть объявлена с атрибутом __declspec(dllexport), а в остальных случаях — с атрибутом __declspec(dllimport). Как описано в рецепте 1.4, этого эффекта можно достичь, определив в командной строке сборки DLL символ препроцессора GEORGERINGO_DLL и не определяя его при компиляции кода, использующего эту DLL.
Если вы не указали значение макроса, то большинство компиляторов присваивают ему значение 1, но некоторые присваивают ему пустое значение. При использовании макросов для включения условной компиляции, как в примере 1.25, эта разница не имеет значения. Однако, если требуется, чтобы макрос раскрывался как определенное значение, вы должны указать это значение явно, использовав запись вида -D<name>=<value>.
Смотри также
Рецепты 1.4, 1.9, 1.12 и 1.17.
1.20. Указание опций командной строки из IDE
Проблема
Вы хотите передать компилятору или компоновщику опцию командной строки, но она не соответствует ни одному из параметров, доступных в IDE.
Решение
Многие IDE предоставляют способ передачи опций командной строки непосредственно компилятору или компоновщику. Эти способы приведены в табл. 1.18 и 1.19.
Табл. 1.18. Указание опций компилятора из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→С/С++→Command Line (командная строка) и введите опцию в поле Additional options (дополнительные опции)
CodeWarrior	Неприменимо
C++Builder	Неприменимо
Dev-C++	В Project Options выберите Parameters и введите опцию в поле C++ Compiler
Табл. 1.19. Указание опций компоновщика из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→Linker→Command Line и введите опцию в поле Additions options
Metrowerks	Неприменимо
C++Builder	Неприменимо
Dev-C++	В Project Options выберите Parameters и введите опцию в поле Linker
Обсуждение
Visual C++ предоставляет опции расширенной настройки через свой графический интерфейс, но также позволяет указать опции командной строки явно. CodeWarrior и C++Builder не позволяют явно устанавливать опции командной строки, но обычно это не является проблемой, так как аналогично Visual C++ они предоставляют опции расширенной настройки через свои графические интерфейсы. С другой стороны, некоторые IDE предоставляют для настройки инструментов командной строки только самый минимум, за исключением возможности явного ввода в текстовое поле опций командной строки. Dev-C++ занимает положение где-то посередине: хотя Dev-C++ предлагает больше графических опций настройки, чем некоторые IDE, предназначенные для работы с инструментарием GCC, при его использовании обычно бывает необходимо явно ввести опции командной строки.
1.21. Создание отладочной сборки
Проблема
Вы хотите собрать версию проекта, которую можно будет легко отлаживать.
Решение
В основном для получения отладочной сборки требуется:
• отключить оптимизации;
• отключить расширение встраиваемых (inline) функций;
• включить генерацию отладочной информации.
Таблица 1.20 представляет опции компилятора и компоновщика, предназначенные для отключения оптимизаций и встраивания функций, а табл. 1.21 представляет опции компилятора и компоновщика для включения отладочной информации.
Табл. 1.20. Отключение оптимизаций и встраивания из командной строки
Инструментарии	Оптимизация	Встраивание
GCC	-O0	-fno-inline¹
Visual C++ Intel (Windows)	-Od	-Ob0
Intel (Linux)	-O0	-Ob0
-opt off	-inline off
Comeau (Unix)	-O0	--no_inlining
Comeau (Windows)	To же, что и у основного компилятора, но вместо тире (-) используется слеш (/)
Borland	-Od	-vi-
Digital Mars	-o+none -S	-C
¹ Эту опцию указывать не требуется, если не была указана опция -O3.
Табл. 1.21. Опции командной строки для включения отладочной информации
Инструментарии	Опции компилятора	Опции компоновщика
Comeau (Unix) GCC	-g	-g
Intel (Linux) Metrowerks
Visual C++ Intel (Windows)	См. табл. 1.22	См. табл. 1 22
Comeau (Windows)	To же, что и у основного компилятора, но вместо тире (-) используется слеш (/)	То же, что и у основного компилятора, но вместо тире (-) используется слеш (/)
Borland	-v	-v
Digital Mars	-g	-co
Табл. 1.22. Включение отладочной информации при использовании Visual C++ или Intel для Windows
Опции компилятора	Опции компоновщика	IDE options¹	Описание
-Z7	-debug	C7 Compatible (совместимость с C7)	Отладочная информация сохраняется в файлах .obj и .exe
-Zi [-Fd<pdb-file-for-obj>].	-debug[-pdb:<pdb-file-for-exe>]	Program Database (база данных программы)	Отладочная информация сохраняется в файлах .pdb; опция в квадратных скобках используется для указания файлов .pdb
-Zi [-Fd<pdbfile-for-obj>]	-debug [-pdb:<pdb-file-for-exe>]	Program Database for Edit & Continue (база данных программы для редактирования и продолжения)	Отладочная информация сохраняется в файлах .pdb; опция в квадратных скобках используется для указания файлов .pdb. Программа может быть перекомпилирована во время сессии отладки
¹ Чтобы получить доступ к этим опциям, перейдите к Configuration Properties→С/С++→ General→Debug Information Format (формат отладочной информации).
BoostBuild предоставляет похожий механизм создания отладочной сборки: просто добавьте к требованиям цели <variant>debug или используйте опцию командной строки variant=debug, которую можно сократить до просто debug.
Некоторые IDE также предоставляют простой способ создания отладочной сборки. Например, при создании нового проекта в Visual C++ IDE автоматически генерирует конфигурации для отладочной и окончательной сборок. Чтобы запросить отладочную сборку, просто выберите в меню Build опцию Configuration Manager и в качестве активной выберите конфигурацию Debug. Также можно выбрать Debug в раскрывающемся списке конфигураций на стандартной панели инструментов. При следующей сборке проекта будет создана отладочная сборка.
Аналогично при создании проекта в CodeWarrior с помощью одного из шаблонов проектов Metrowerks, называемых «принадлежности» (stationery), IDE автоматически генерирует отладочную и окончательную цели. Имя отладочной цели может быть разным, но оно всегда должно включать слово «debug». Чтобы запросить отладочную сборку, в меню Project выберите пункт Set Default Target (установить цель по умолчанию), а затем выберите элемент меню, соответствующий отладочной цели. Также можно выбрать отладочную цель в раскрывающемся списке целей в окне проекта.
C++Builder не поддерживает множественных конфигураций для одного проекта, но он предоставляет простой способ создания отладочной сборки. Чтобы запросить отладочную сборку, перейдите в Project Options→Compiler и нажмите на Full debug (полная отладка). Это отключит все оптимизации и встраивание и включит отладочную информацию.
При использовании IDE, которая не предоставляет готовых отладочной и окончательной конфигураций, такой как Dev-C++, или если вам требуется получить дополнительный контроль над параметрами проекта, обратитесь к таблицам с 1.23 до 1.25.
Табл. 1.23. Отключение оптимизаций из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Optimization и установите опцию Optimization в значение Disabled (отключено). Для остальных опций на этой странице оставьте значения по умолчанию
CodeWarrior	В окне Target Settings перейдите к Code Generation→Global Optimizations (генерация кода→глобальная оптимизация) и выберите Off (выкл)
C++Builder	В Project Options перейдите к Compiler, в разделе Code optimization (оптимизация кода) выберите None
Dev-C++	В Project Options перейдите к Compiler→Optimization и установите опцию Perform a number of minor optimizations (выполнить несколько незначительных оптимизаций) в значение No (нет), затем перейдите к Compiler→Optimization→Further optimizations (дополнительные оптимизации) и установите опции Optimize (оптимизировать), Optimize more (дополнительно оптимизировать) и Best Optimization (наилучшая оптимизация) в значение No
Табл. 1.24. Отключение встраивания из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Optimization и установите опцию Inline Function Expansion (расширение встраиваемых функций) в значение Default (по умолчанию)
CodeWarrior	В окне Target Settings перейдите к Language Settings→C/C++ Language и установите Inline Depth (глубина встраивания) в значение Don't Inline (не встраивать)
C++Builder	В Project Options перейдите к Compiler и в разделе Debugging установите флажок Disable inline expansions (отключить встраивание функций)
Dev-C++	См. запись для GCC в табл. 1.20 и обратитесь к рецепту 1.20
Табл. 1.25. Включение отладочной информации в IDE
IDE	Конфигурация
Visual C++	См. табл. 1.22
CodeWarrior	В окне Target Settings перейдите к Language Settings→Linker→PPC Mac OS X Linker и установите флажки Generate SYM File (генерировать SYM-файл) и Full Path in SYM Files (полные пути в SYM-файлах)
C++Builder	В Project Options перейдите к Compiler и установите флажки Debug information и Line Number Information (информация о номерах строк)
Dev-C++	См. запись для GCC в табл. 1.21 и обратитесь к рецепту 1.20
Обсуждение
Все наборы инструментов предоставляют опции для генерации в объектных и исполняемых файлах информации, которая позволяет отладчикам сообщать полезные данные при пошаговом выполнении программы. Эта информация обычно включает имена исходных файлов и номера строк, соответствующих определенному объекту или инструкциям машинного кода, а также информацию об объектах С++, занимающих определенные области памяти, включая их имена и типы.
Большинство наборов инструментов сохраняют отладочную информацию непосредственно в объектных и исполняемых файлах, но некоторые также предоставляют опцию для генерации отладочной информации в отдельных файлах базы данных. Например, в Visual C++ опция компилятора -Z7 указывает, что отладочная информация должна быть помещена в объектные и исполняемые файлы, а опции -Zi и -ZI указывают, что она должна быть сохранена в файлах базы данных программы, имеющих расширение .pdb. Опция -ZI включает функцию, которая называется Edit and Continue (отредактировать и продолжить), которая позволяет пользователям IDE изменять и перекомпилировать код, не прерывая сессии отладки. Аналогично CodeWarrior для Mac OS X по умолчанию генерирует отладочную информацию в файлах .SYM.
Большая часть наборов инструментов может генерировать отладочную информацию даже с включенными оптимизациями и встраиванием, хотя в некоторых случаях отладочная информация может оказаться несовместимой с некоторыми видами оптимизации. Однако при включении оптимизаций компилятор может увеличить эффективность кода, изменив порядок следования операторов или полностью реорганизовав фрагменты кода, в то время как внешне его поведение останется неизменным. Это делает отладку более сложной, так как при этом теряется строгое соответствие между частями исходного кода и местами расположения объектов и машинным кодом. Это же верно и для встраивания: когда компилятор раскрывает встраиваемую функцию, объектный код, соответствующий этой функции, генерируется в теле вызывающей функции. При выполнении этого кода для встроенной функции не создается стекового фрейма. Помимо всего прочего это означает, что отладчик не сможет отобразить значения аргументов функции и ее локальных переменных. Обычно отладчики даже не пытаются сообщать о местах в исходном коде, соответствующих телам встроенных функций.
По этим причинам обычно при создании отладочной сборки принято отключать оптимизации и встраивание.
Смотри также
Рецепт 1.22.
1.22. Создание окончательной сборки
Проблема
Вы хотите создать небольшой быстрый исполняемый файл или динамическую библиотеку, предназначенные для распространения среди покупателей.
Решение
В основном для получения окончательной сборки требуется:
• включить оптимизации;
• включить расширение встраиваемых (inline) функций;
• отключить генерацию отладочной информации.
В табл 1.26 представлены опции компилятора и компоновщика, включающие оптимизацию и встраивание. Опций командной строки для отключения отладочной информации не существует: при сборке из командной строки отладочная информация по умолчанию отключена. Однако при использовании инструментария GCC размер исполняемых файлов и динамических библиотек можно уменьшить, указав компоновщику опцию -s.
Табл. 1.26. Опции компилятора, включающие оптимизации и встраивание
Инструментарий	Оптимизация	Встраивание
GCC	-O3	-finline-functions¹
Visual C++ Intel	-O2	-Оb1
Metrowerks	-opt full	-inline auto -inline level=8
Comeau (Unix)	-O3
Comeau (Windows)	To же, что и у основного компилятора, но вместо тире (-) используется слеш (/)	-inlining
Borland	-O2	-vi
Digital Mars	-o+time	Включено по умолчанию
¹ Эта опция автоматически включается при указании -O3.
Boost.Build предоставляет похожий механизм создания окончательной сборки: просто добавьте к требованиям цели <variant>release или используйте опцию командной строки variant=release, которую можно сократить до просто release.
Некоторые IDE также предоставляют простой способ создания окончательной сборки. Например, как я говорил в рецепте 1.21, при создании нового проекта в Visual C++ IDE автоматически генерирует отладочную и окончательную конфигурации. Чтобы запросить окончательную сборку, просто выберите в меню Build опцию Configuration Manager и в качестве активной выберите конфигурацию Release. Также можно выбрать Release в раскрывающемся списке конфигураций на стандартной панели инструментов. При следующей сборке проекта будет создана окончательная сборка.
Аналогично при создании проекта в CodeWarrior с помощью одного из шаблонов проектов Metrowerks, называемых «принадлежности» (stationery), IDE автоматически генерирует отладочную и окончательную цели. Имя окончательной цели может быть разным, но оно всегда должно включать слово «release» или «final». Чтобы запросить окончательную сборку, в меню Project выберите пункт Set Default Target (установить цель по умолчанию), а затем выберите элемент меню, соответствующий окончательной цели. Также можно выбрать окончательную цель в раскрывающемся списке целей в окне проекта.
C++Builder не поддерживает множественных конфигураций для одного проекта, но он предоставляет простой способ создания окончательной сборки. Чтобы запросить окончательную сборку, перейдите в Project Options→Compiler и нажмите на Release. Это включит все оптимизации и встраивание и отключит отладочную информацию.
При использовании IDE, которая не предоставляет готовых отладочной и окончательной конфигураций, такой как Dev-C++, или если требуется получить дополнительный контроль над параметрами проекта, обратитесь к таблицам с 1.27 до 1.29.
Табл. 1.27. Включение оптимизаций из IDE
IDE	Конфигурация
Visual C++	На странице свойств проекта перейдите к Configuration Properties→C/C++→Optimization и установите параметр Optimization в значение Maximize Speed (Максимизировать быстродействие), Favor Size or Speed (Отдавать предпочтение размеру или скорости) в значение Favor Fast Code (Отдавать предпочтение быстроте кода), а параметры Global Optimizations (Глобальная оптимизация). Enable Intrinsic Functions (Включить встроенные функции) и Omit Frame Pointers (Не включать указатели фрейма) в значение Yes (Да). Для остальных опций на этой странице оставьте значения по умолчанию
CodeWarrior	В окне Target Settings перейдите к Code Generation→Global Optimizations (Генерация кода→Глобальная оптимизация) и выберите Level 4 (Уровень 4)
C++Builder	В Project Options перейдите к Compiler, в разделе Code optimization (оптимизация кода) выберите Speed (Скорость)
Dev-C++	См запись для GCC в табл. 1 26 и обратитесь к рецепту 1.20
Табл. 1.28. Включение встраивания из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Optimization и установите опцию Inline Function Expansion (расширение встраиваемых функций) в значение Any Suitable (Все подходящие)
CodeWarrior	В окне Target Settings перейдите к Language Settings→C/C++ Language. Установите параметр Inline Depth (Глубина встраивания) в значение 8, а остальные опции встраивания оставьте неотмеченными
C++Builder	В Project Options перейдите к Compiler и в разделе Debugging снимите флажок Disable inline expansions (Отключить встраивание функций)
Dev-C++	См. запись для GCC в табл. 1.26 и обратитесь к рецепту 1.20
Табл. 1.29. Отключение отладочной информации в IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→С/С++→General и для опции Debug Information Formal (Формат отладочной информации) выберите значение Disabled
Metrowerks	В окне Target Settings перейдите к Language Settings→Linker→х86 Linker и снимите флажки Store full paths (Сохранять полные пути). Link debug info (Компоновать с отладочной информацией), и Debug inline functions (Отлаживать встраиваемые функции)
C++Builder	В Project Options перейдите к Compiler и снимите флажки Debug Information и Line Number Information (информация о номерах строк)
Dev-C++	Убедитесь, что. как описано в рецепте 1.20 не указана опция командной строки -g
Обсуждение
Большинство наборов инструментов предлагает несколько опций оптимизации, а некоторые даже десятки. Какие оптимизации следует выбрать, зависит от требований к проекту. Например, во встраиваемых системах может потребоваться выбрать оптимизации, которые ценой некоторого уменьшения скорости приводят к созданию меньших по размеру исполняемых файлов. В других случаях приоритет может отдаваться скорости. Некоторые оптимизации сделают программу быстрее на одной платформе, но медленнее на другой. Вы можете даже столкнуться с тем, что некоторые опции сделают отдельные части программы быстрее, а другие части — медленнее.
Таблицы 1.26 и 1.27 показывают опции обобщенных оптимизаций, но для достижения наилучших результатов следует тщательно рассмотреть все требования, изучить документацию по инструментарию и провести всестороннее тестирование.
Эта ситуация аналогична встраиванию, хотя обычно инструментарии предоставляют значительно меньше опций для встраивания, чем для других оптимизаций
Смотри также
Рецепт 1.21.
1.23. Указание варианта библиотеки времени выполнения
Проблема
Ваш инструментарий поставляется с несколькими вариантами базовых библиотек времени выполнения, и вы хотите указать компилятору и компоновщику тот вариант, который должен использоваться.
Решение
Библиотеки времени выполнения, поставляемые с данным инструментарием, могут различаться по тому, являются ли они одно- или многопоточными, статическими или динамическими и содержат ли они отладочную информацию или нет.
При использовании Boost.Build эти три выбора можно сделать, использовав функции threading, runtime-link и variant, описанные в табл. 1.15. Например, чтобы указать статическую библиотеку времени выполнения, добавьте к требованиям цели <runtime-link>static или используйте опцию командной строки runtime-link=static. Чтобы указать многопоточную библиотеку времени выполнения, добавьте к требованиям цели <threading>multi или используйте опцию командной строки threading=multi.
При сборке из командной строки используйте опции компилятора и компоновщика, представленные в таблицах с 1.30 до 1.36. Опции командной строки и имена библиотек для отладочной и окончательной конфигураций обычно очень похожи. В следующих таблицах буквы в квадратных скобках добавляются только для отладочных конфигураций. Имена динамических вариантов библиотек времени выполнения показаны в круглых скобках. При выборе динамической компоновки эти библиотеки должны быть доступны при выполнении программы.
Табл. 1.30. Опции компилятора для выбора библиотеки времени выполнения при использовании Visual C++ или Intel (Windows)
Статическая компоновка	Динамическая компоновка
Однопоточная	-ML[d]¹	Неприменимо
Многопоточная	-MT[d]	-MD[d](msvcrt[d].dll, msvcr80[d].dll)²
¹ Начиная с Visual Studio 2005, в момент написания книги, находящейся в стадии бета-тестирования, опции -ML и -MLd считаются устаревшими, а однопоточные статические библиотеки времени выполнения больше не поставляются.
² Предыдущие версии Visual C++ использовали DLL msvcr71.dll, msvcr71d.dll, msvcr70.dll, msvcr70d.dll и т.д.
Табл. 1.31. Опции компилятора для выбора библиотеки времени выполнения при использовании Metrowerks (Windows)
Статическая компоновка	Динамическая компоновка
Однопоточная	-runtime ss[d]	Неприменимо
Многопоточная	-runtime sm[d]	-runtime dm[d](MSL_All-DLL90_x86[_D].dll)
Табл. 1.32. Опции командной строки для выбора библиотеки времени выполнения при использовании CodeWarrior 10 для Max OS X
Статическая компоновка	Динамическая компоновка
Опции не требуется	Обратитесь к документации Metrowerks по опциям командной строки (MSL_All_Mach-O[_D].dylib)
Табл. 1.33. Опции компилятора для выбора библиотеки времени выполнения при использовании Borland
Статическая компоновка	Динамическая компоновка
Однопоточная	-WM	-WM- -WR -WC¹ (cc3260.dll)
Многопоточная	-WM	-WM -WR -WC (cc3260mt.dll)
¹ Опция -WC требуется только при сборке консольного приложения.
Табл. 1.34. Опции компилятора для выбора библиотеки времени выполнения при использовании Digital Mars (все библиотеки времени выполнения многопоточны)
Статическая компоновка	Динамическая компоновка
Опций не требуется	-ND -D_STLP_USE_DYNAMIC_LIB(sccrt70.dll, stlp45dm.dll)
Табл. 1.35. Опции компилятора для выбора библиотеки времени выполнения при использовании GCC
Статическая компоновка	Динамическая компоновка
-static¹	Опций не требуется
¹ Эта опция отключает всю динамическую компоновку, а не только динамические библиотеки времени выполнения.
Например, чтобы указать динамическую окончательную сборку библиотеки времени выполнения Visual С++, используйте опцию компилятора -MD. Чтобы указать статическую однопоточную отладочную сборку библиотеки времени выполнения Metrowerks для Windows, используйте опцию компилятора -runtime ssd. Чтобы указать однопоточную динамическую сборку библиотеки времени выполнения Borland, передайте компилятору и компоновщику опции -WM- -WR -WC.
Инструкции для указания варианта библиотеки времени выполнения в IDE приведены в табл. 1.36.
Табл. 1.36. Указание варианта библиотеки времени выполнения из IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Code Generation (Генерация кода) и используйте раскрывающийся список Runtime Library (библиотека времени выполнения)
CodeWarrior	Для проектов динамических библиотек добавьте в проект объектный файл /usr/lib/dylib1.o и библиотеки MSL_Shared_AppAndDylib_Runtime[_D].lib и MSL_All_Mach-O[_D].dylib и удалите все библиотеки вида MSL_<XXX>_Mach-O[_D].lib. Для проектов исполняемых файлов добавьте в проект объектный файл /usr/lib/crtl.с и библиотеки MSL_Shared_AppAndDylib_Runtime[_D].lib и MSL_All_Mach-O[_D].dylib и удалите все библиотеки вида MSL_<XXX>_Mach-O[_D].lib
C++Builder	Будет ли проект одно- или многопоточным, должно быть указано при его создании. Чтобы выбрать статическую или динамическую библиотеку времени выполнения, в окне Project Options перейдите к Linker и установите или снимите флажок Use dynamic RTL (Использовать динамические библиотеки времени выполнения)
Dev-C++	Чтобы выбрать статическую библиотеку времени выполнения, укажите опцию командной строки -static, как описано в рецепте 1.20
Обсуждение
Библиотека времени выполнения содержит реализации вспомогательных функций, необходимых при выполнении программы. Обычно библиотека времени выполнения содержит реализации функций стандартной библиотеки С, функций, используемых для доступа к сервисам операционной системы, таким как потоки и файловые системы, и специфичных для платформы, и функций, предоставляющих инфраструктуру для функций языка С++, таких как информация о типах во время выполнения (RTTI) и обработка исключений.
В большинстве случаев, чем больше у вас выбор, тем лучше. Однако слишком большое количество библиотек времени выполнения приводит к различным проблемам. Главной проблемой является гарантия того, что все компоненты приложения — статические библиотеки, динамические библиотеки и исполняемые файлы — используют один и тот же вариант библиотеки времени выполнения, Если это не так, то приложение может не скомпоноваться или в нем могут появиться сложные с точки зрения диагностики сбои.
При использовании библиотек, разработанных другими, у вас не будет возможности выбрать библиотеки времени выполнения. В таких случаях вы будете вынуждены использовать в одном приложении несколько вариантов библиотек времени выполнения.
Итак, как же решить, какую библиотеку времени выполнения использовать? Два выбора — одно- или многопоточную и отладочную или окончательную — вполне очевидны.
Если проект использует несколько потоков или зависит от многопоточных библиотек, вы должны выбрать многопоточный вариант библиотеки времени выполнения (если такой имеется в поставке инструментария). Если библиотека времени выполнения была собрана без поддержки многопоточности, то вызов ее функций из нескольких потоков может привести к непредсказуемому поведению программы. Аналогично при создании отладочной сборки следует использовать отладочный вариант библиотеки времени выполнения (если он имеется).
Последний выбор — следует использовать статическую или динамическую библиотеку времени выполнения — более сложен. Использование статической библиотеки имеет несколько преимуществ. Во-первых, благодаря тому, что в приложение включаются только функции, реально используемые приложением, она может уменьшить суммарный размер дистрибутива программы, исключив необходимость распространять динамическую библиотеку времени выполнения. (Однако если известно, что динамическая библиотека в целевой системе уже имеется, компоновка со статической библиотекой сделает дистрибутив больше по размеру.) Во-вторых, при компоновке со статической библиотекой устраняется проблема версий библиотек, которая возникает, когда в системе присутствует несколько версий одной и той же динамической библиотеки.
Однако компоновка с динамической библиотекой времени выполнения также имеет свои преимущества. В первую очередь благодаря тому, что очень эффективным средством организации приложения является создание набора динамических библиотек. Во-первых, это позволяет обновлять части приложения, не требуя переустановки всего приложения. Далее, в некоторых случаях, благодаря использованию возможности отложенной загрузки DLL в Windows, значительно увеличивается производительность приложения. Но так как все компоненты приложения должны использовать один и тот же вариант библиотеки времени выполнения, то если приложение использует хотя бы одну динамическую библиотеку, все компоненты этого приложения должны использовать динамическую библиотеку времени выполнения. В результате использование динамической библиотеки времени выполнения облегчает разбиение приложения на модули.
Я рекомендую в большинстве случаев выбирать динамическую компоновку. Однако, как я упоминал выше, иногда предпочтительнее статическая компоновка. Иногда, когда неизвестно, как будет использоваться написанная библиотека, невозможно узнать заранее, какой тип компоновки предпочтительнее. В этом случае общим решением является создание нескольких вариантов библиотеки, скомпонованных с использованием различных вариантов библиотеки времени выполнения.
Смотри также
Рецепты 1.4, 1.5, 1.21 и 1.25.
1.24. Включение строгого соответствия стандарту C++
Проблема
Вы хотите, чтобы компилятор принимал только программы, которые соответствуют стандарту языка С++.
Решение
Опции командной строки для указания строгого соответствия стандарту C++ приведены в табл. 1.37. Инструкции для включения строгого соответствия в IDE приведены в табл. 1.38
Некоторые из показанных в табл. 1.6 опций компиляторов могут рассматриваться как опции соответствия. Примерами являются опции для включения основных языковых функций, таких как поддержка «широких» символов, исключений и информации о типе во время выполнения. В табл. 1.37 они не приведены.
Табл. 1.37. Включение строгого соответствия из командной строки
Инструментарий	Опции командной строки компилятора
GCC	-ansi -pedantic-errors
Visual C++	-Za
Intel (Windows)	-Za -Qms0
Intel (Linux)	-strict-ansi¹
Metrowerks	-ansi strict -iso_templates on -msext off
Comeau (Windows)	-A
Comeau (Unix)	-strict or -A
Borland	-A²
Digital Mars	-A
¹ Версии компилятора Intel для Linux до 9.0 использовали опцию -strict_ansi. При использовании -strict-ansi или -strict_ansi может потребоваться с помощью опции -cxxlib-icc включить стандартную библиотеку Intel
² С опцией -А некоторые стандартные заголовочные файлы библиотеки STLPort могут не компилироваться.
Табл. 1.38. Включение строгого соответствия в IDE
IDE	Конфигурация
Visual C++	На страницах свойств проекта перейдите к Configuration Properties→C/C++→Language и установите в значение Yes (Да) опции Disable Language Extensions (Отключить расширения языка), Treat wchar_t as Built-in Type (Рассматривать wchar_t как встроенный тип) и Force Conformance in For Loop Scopes (Включить соответствие стандарту в циклах For)
Metrowerks	В окне Target Settings перейдите к Language Settings→C/C++ Language и установите ISO Template Parser (Синтаксический анализ шаблонов ISO), ANSI Strict (Строгий ANSI) и ANSI Keywords Only (Только ключевые слева ANSI). Убедитесь, что выбраны опции Enable C++ Exceptions (Включить исключений С++). Enable RTTI support (Включить поддержку RTTI). Enable bool Support (Включить поддержку bool) и Enable wchar_t Support (Включить поддержку wchar_t)
C++Builder	В Project Options перейдите к Advanced Compiler и в разделе Language Compliance (Соответствие языка) установите ANSI
Dev-C++	См запись для GCC в табл. 1 37 и обратитесь к рецепту 1.20
Обсуждение
Язык C++ был стандартизирован Международной организацией по стандартизации (International Standards Organization — ISO) в 1998 году. В том же году стандарт ISO был одобрен и принят Национальным институтом стандартизации США (American National Standards Institute — ANSI). В 2003 году была одобрена вторая редакция стандарта, которая содержит исправления и пояснения, но также вводит несколько новых языковых возможностей. В настоящее время ведется работа над обновленной версией стандарта С++, которая будет включать несколько важных языковых функций и расширенную стандартную библиотеку.
В момент принятия стандарта в 1998 году ни один из компиляторов не достигал полного соответствия его требованиям, хотя многие были представлены как «ANSI-совместимые». Однако в течение нескольких прошедших лет поставщики много работали над тем, чтобы сделать свои инструменты более точно и строго соответствующими стандарту. По состоянию на сентябрь 2005 года последние версии компиляторов GNU, Microsoft, Intel, Metrowerks и Comeau обладают высокой степенью соответствия. Comeau и Intel с их поддержкой экспорта шаблонов могут рассматриваться как соответствующие стандарту почти на 100%[5].
Ни один из компиляторов не может обеспечить полного соответствия стандарту с точки зрения отказа компилировать любую неверную программу. И не только из-за того, что ни один из них не соответствует стандарту на 100%: более важной причиной является то, что стандарт C++ не требует от компилятора отвергать неверные программы. Имеется четкий перечень обстоятельств, в которых компилятор должен выдавать диагностическое сообщение, указывающее на неправильно написанную программу, однако для многих некорректных программ диагностики не требуется. Это программы, которые приводят к тому, что стандарт называет неопределенным поведением программы при ее выполнении. И даже тогда, когда диагностика обязательна, компилятор волен выдать сообщение и продолжить компиляцию, в результате которой возможно успешное создание исполняемого файла или библиотеки.
Главной причиной, по которой от компиляторов не требуется отвергать все некорректно написанные программы, является то, что во многих случаях эту некорректность сложно, а иногда и невозможно обнаружить. Еще одной причиной, которая обсуждается далее, является то, что некорректные с точки зрения стандарта программы иногда очень полезны.
Я советую вам использовать опции строгого соответствия компилятора как можно чаще. Однако имеются ситуации, когда это невозможно. Чтобы лучше это понять, давайте посмотрим на несколько вариантов не соответствующего стандарту кода.
Для начала вот код, который полностью попустим в ранних диалектах С++, существовавших до стандартизации языка. Например, в ранних версиях C++ область видимости переменной, объявленной при инициализации цикла for, простиралась до конца блока, в котором находился этот цикл.
// ВНИМАНИЕ: некорректный код!
int main() {
 for (int i = 0; i < 10; ++i)
  ;
 int j = i; // j == 10
}
Стандартом это не допускается и не имеет никаких преимуществ по сравнению со стандартными правилами областей видимости. Требование компилировать код, подобный этому, возникает только при сопровождении устаревших приложений.
Другой категорией некорректного кода является код, который использует экспериментальные расширения языка, которые по какой-либо причине не вошли в конечный стандарт C++. Например, многие компиляторы предоставляют встроенный тип long long, длина которого гарантированно имеет не менее 64 бит. Как еще один пример, некоторые компиляторы предоставляют встроенный оператор typeof, имеющий такой же синтаксис, как и оператор sizeof, и возвращающий тип выражения. Обе эти функции, скорее всего, появятся в следующей версии стандарта C++, хотя ожидается, что написание typeof изменится на, возможно, decltype.
Будьте осторожны при использовании подобного рода расширений: вы можете столкнуться с тем, что вам потребуется портировать код на платформу, не реализующую какого-либо расширения или реализующую его по-другому.
Третья категория некорректного кода — это код, который использует платформенно-зависимые расширения языка, необходимые для использования функций операционной системы. В эту категорию попадают атрибуты __declspec(dllexport) и __declspec(dllimport), используемые для сборки динамических библиотек в Windows, и атрибуты __stdcall, __fastcall и __cdecl, представляющие соглашения о вызовах в Windows. Хотя это и расширения языка, большая часть компиляторов для Windows принимает код, содержащий эти расширения, даже если используется опция строгого соответствия стандарту.
Последней категорией некорректного кода является код, нарушающий стандарт С++, но полностью соответствующий некоторым другим стандартам. Главным примером такого стандарта является C++/CLI, который сейчас проходит последние стадии стандартизации в ECMA. C++/CLI — это расширение С++, которое состоит из интерфейса C++ к Command Language Infrastructure — ядру Microsoft .NET Framework. При компиляции приложения, использующего определенные расширения C++/CLI, соответствующий стандарту компилятор C++ должен выдавать диагностику, но при поддержке стандарта C++/CLI он может свободно генерировать работоспособное приложение.
Если вам требуется скомпилировать код, не соответствующий стандарту, вначале проверьте, будет ли он компилироваться при использовании опций, приведенных в табл. 1.37 и 138. Если нет, то некоторые компиляторы предлагают набор «дробных» опций совместимости, позволяющих использовать некоторые несовместимые конструкции, но запрещающих другие. Например, Comeau предоставляет опцию --long_long, указывающую на необходимость распознавания типа long long. Наконец, некоторые компиляторы предоставляют опции, заставляющие их сообщать о большинстве нарушений стандарта как о предупреждениях, а не ошибках. Например, GCC для этой цели предоставляет опцию -pedantic, a Comeau для Windows предоставляет опцию --a, а для других платформ — опции --strict_warnings или -a.
Смотри также
Рецепт 1.2.
1.25. Указание определенной библиотеки для автоматической компоновки с исходным файлом
Проблема
Вы написали библиотеку, которую хотите распространять в виде набора заголовочных файлов и готовых статических или динамических библиотек, но не хотите, чтобы пользователи вашей библиотеки должны были сами указывать имена библиотек при компоновке приложений.
Решение
При программировании для Windows с использованием инструментария Visual C++, Intel, Metrowerks, Borland или Digital Mars для указания имен и (при необходимости) путей готовых библиотек, с которыми должен компоноваться код, включающий заголовочные файлы вашей библиотеки, используйте в этих заголовочных файлах pragma comment.
Например, предположим, что вы хотите распространить библиотеку из примера 1.1, состоящую из статической библиотеки libjohnpaul.lib и заголовочного файла johnpaul.hpp. Измените этот заголовочный файл так, как показано в примере 1.26.
Пример 1.26. Использование pragma comment
#ifndef JОНNPAUL_HPP_INCLUDED
#define JOHNPAUL_HPP_INCLUDED
#pragma comment(lib, "libjohnpaul")
void johnpaul();
#endif // JOHNPAUL_HPP_INCLUDED
После этого изменения компоновщики Visual С++, Intel, Metrowerks, Borland и Digital Mars при компоновке кода, включающего заголовочный файл johnpaul.hpp, будут автоматически находить библиотеку libjohnpaul.lib.
Обсуждение
В некоторых ситуациях компоновка может оказаться более сложным этапом процесса сборки, чем компиляция. Одна из наиболее часто возникающих проблем компоновки создается тогда, когда компоновщик находит неверную версию какой-либо библиотеки. Это в основном проблема Windows, где библиотеки времени выполнения и зависящие ar них библиотеки часто имеют множество вариантов. По этой причине библиотеки для Windows часто поставляются с именами, измененными так, чтобы они отражали различные конфигурации сборки. Хотя это и помогает снизить число конфликтов версий, это также затрудняет процесс компоновки, так как теперь вы должны указывать компоновщику правильное измененное имя.
По этой причине pragma comment очень полезна. Среди прочего она позволяет указать правильное имя библиотеки в заголовочном файле и избавить пользователя от необходимости разбираться в ваших соглашениях об изменении имен файлов. Если в дополнение к этому вы разработаете процесс установки, копирующий двоичные файлы в папку, автоматически используемую компоновщиком, — такую как поддиректория lib корневых директорий Visual С++, CodeWarrior или C++Builder, — то программисты смогут использовать вашу библиотеку, просто включив ее заголовочные файлы.
До сих пор все было хорошо. Но есть одна проблема: pragma comment распознается не всеми компиляторами. Если вы хотите писать портируемый код, вы должны вызывать pragma только после того, как проверите, что она поддерживается используемым инструментарием. Например, вы можете изменить johnpaul.cpp вот так.
#ifndef JOHNPAUL_HPP_INCLUDED
#define JOHNPAUL_HPP_INCLUDED
#if defined(_MSC_VER) || \
 defined(__ICL) || \
 defined(__MWERKS__) && defined(_WIN32) || \
 defined(__BORLANDC__) \
 defined(__DMC__) \
/**/
#pragma comment (lib, "libjohnpaul")
#endif
void johnpaul();
#endif // JOHNPAUL_HPP_INCLUDED
Этот пример уже стал достаточно сложным, и, к сожалению, он все еще не полностью корректен: некоторые компиляторы, не поддерживающие pragma comment, для совместимости в Visual C++ определяют макрос _MSC_VER. К счастью, Boost предоставляет простое решение.
#ifndef johnpaul_hpp_included
#define JOHNPAUL_HPP_INCLUDED
#define BOOST_LIB_NAME libjohnpaul
#define BOOSTAUTO_LINK_NOMANGLE
#include <boost/config/auto_link.hpp>
void johnpaul();
#endif // JOHNPAUL_HPP_INCLUDED
Здесь строка
#define BOOST_LIB_NAME libjohnpaul
определяет имя библиотеки, строка
#define BOOST_AUTO_LINK_NOMANGLE
указывает, что вы не хотите использовать соглашение об именах Boost, а строка
#include <boost/config/auto_link.hpp>
вызывает pragma comment для поддерживающих ее компиляторов.
Смотри также
Рецепт 1.23.
1.26. Использование экспортируемых шаблонов
Проблема
Вы хотите собрать программу, использующую экспортируемые шаблоны, что означает, что она объявляет шаблоны в заголовочных файлах с использованием ключевого слова export, а реализация шаблонов находится в файлах .cpp.
Решение
Во-первых, скомпилируйте в объектные файлы файлы .cpp, содержащие реализации шаблонов, передав компилятору опцию командной строки, необходимую для включения экспортируемых шаблонов. Затем скомпилируйте и скомпонуйте файлы .cpp, использующие экспортируемые шаблоны, передав компилятору и компоновщику опции командной строки, необходимые для включения экспортируемых шаблонов, а также опции, указывающие директории, содержащие реализации шаблонов.
Опции для включения экспортируемых шаблонов приведены в табл 1.39. Опции для указания расположения реализаций шаблонов приведены в табл. 1.40. Если ваш инструментарий в этой таблице не указан, то он, скорее всего, не поддерживает экспортируемых шаблонов.
Табл. 1.39. Опции для включения экспортируемых шаблонов
Инструментарий	Сценарий
Comeau (Unix)	-export, -A или -strict
Comeau (Windows)	-export или -A
Intel (Linux)	-export или -strict-ansi¹
¹ Версии компилятора Intel для Linux до 9.0 использовали опцию -strict_ansi
Табл. 1.40. Опции, указывающие расположение реализаций шаблонов
Инструментарий	Сценарий
Comeau	-template_directory=<path>
Intel (Linux)	-export_dir<path>
Например, предположим, что вы хотите скомпилировать программу, показанную в примере 1.27. Она содержит три файла.
• Файл plus.hpp содержит объявление экспортируемого шаблона функции plus().
• Файл plus.cpp содержит определение plus().
• Файл test.cpp включает объявление — но не определение — plus() и определяет функцию main(), использующую plus().
Пример 1.27. Простая программа, использующая экспортируемые шаблоны
plus.hpp:
#ifndef PLUS_HPP_INCLUDED
#define PLUS_HPP_INCLUDED
export template<typename T>
T plus(const T& lhs, const T& rhs);
#endif // #ifndef PLUS_HPP_INCLUDED
plus.cpp:
#include "plus.hpp"
template<typename T>
T plus(const T& lhs, const T& rhs) {
 return rhs + lhs;
}
test.cpp:
#include <iostream>
#include "plus.hpp"
int main() {
 std::cout << "2 + 2 = " << plus(2, 2) << "\n";
}
Чтобы скомпилировать plus.cpp в объектный файл plus.obj с помощью Comeau в Unix, перейдите в директорию, содержащую plus.cpp, plus.hpp и test.cpp, и введите следующую команду.
$ como -c --export plus.cpp
Эта команда также генерирует файл plus.et, описывающий реализацию шаблона, содержащегося в plus.cpp.
Для развлечения откройте plus.et в текстовом редакторе.
Затем скомпилируйте test.cpp в объектный файл test.obj с помощью команды:
$ como -c --export test.cpp
Наконец, скомпонуйте исполняемый файл test.exe.
$ como --export -о test test.obj
Две последние команды также можно объединить в одну.
$ como --export -o test test.cpp
Теперь можно запустить test.exe.
$ ./test
2 + 2 = 4
Теперь предположите, что файлы plus.hpp и plus.cpp находятся в директории с именем plus, a test.cpp находится в дочерней директории test. Чтобы скомпилировать и скомпоновать test.cpp, перейдите в директорию test и введите:
$ como --export --template_directory=../plus -I../plus -o test
test.cpp
Обсуждение
C++ поддерживает две модели обеспечения определений шаблонов функций и статических данных-членов шаблонов классов: включающую (inclusion model) и раздельную (separation model) модели. Включающая модель знакома всем программистам, регулярно использующим шаблоны С++, но часто оказывается непонятной программистам, привыкшим писать код без шаблонов. Во включающей модели определение шаблона функции — или статических данных-членов шаблона класса — должно включаться в каждый исходный файл, ее использующий. В противоположность этому при использовании нешаблонных функций и данных достаточно включить в исходный файл только объявление; определение может быть помещено в отдельный файл .cpp.
Раздельная модель ближе к традиционной манере организации исходного кода C++. Для шаблонов, объявленных с ключевым словом export, не требуется включать определения во все исходные файлы, их использующие. Вместо этого определения помещаются в отдельные файлы .cpp. Однако параллель с традиционной организацией кода не полная, так как даже несмотря на то, что код, использующий экспортируемый шаблон, не требует включения его определения, он зависит от определения.
Раздельная модель предлагает несколько потенциальных преимуществ.
Уменьшение времени компиляции
Время компиляции при использовании раздельной модели может сократиться благодаря тому, что сканирование определений шаблонов производится реже, и потому, что раздельная модель уменьшает зависимости между модулями.
Снижение «загрязнения» символов
Имена функций, классов и данных, используемых в файле реализации шаблона, могут быть полностью скрыты от кода, использующего этот шаблон, что снижает возможность случайного совпадения имен. Кроме того, автор реализации шаблона может уделять меньше внимания случайным совпадениям с именами из исходных файлов, использующих шаблон
Возможность поставлять скомпилированные реализации шаблонов.
Теоретически при использовании раздельной модели поставщик может распространять реализации шаблонов в скомпилированном двоичном виде, находящемся где-то посередине между исходным кодом C++ и обычными объектными файлами.
Все три потенциальных преимущества раздельной модели спорны. Во-первых, хотя некоторые пользователи сообщали о сокращении времени компиляции, раздельная модель также может в некоторых случаях привести к его увеличению. В настоящее время данных для окончательных выводов недостаточно. Во-вторых, хотя раздельная модель снижает некоторые виды загрязнения символов, правила языка, необходимые для поддержки раздельной модели, и особенно идея двухэтапного поиска, усложняют способ написания кода шаблона — даже по сравнению с включающей моделью - и имеют несколько нежелательных последствий. В-третьих, все существующие реализации раздельной модели основаны на оболочке EDG, a EDG пока еще не предоставляет никаких возможностей для компиляции исходных файлов, содержащих реализации экспортируемых шаблонов, в двоичные файлы, которые могут поставляться вместо исходников.
В 2003 году имела место попытка удалить экспортируемые шаблоны из будущих версий стандарта С++, но она провалилась. Следовательно, экспортируемые шаблоны являются постоянной частью языка С++, и вы должны научиться использовать их.
Смотри также
Рецепт 1.25.
Глава 2
Организация кода
2.0. Введение
Возможно, что одной из причин популярности C++ является его способность одинаково хорошо подходить для маленьких, средних и больших проектов. Для небольшого прототипа или исследовательского проекта можно написать всего несколько классов, а при росте проекта и увеличении числа сотрудников C++ позволяет масштабировать приложение, разбив его на модули, различающиеся по степени своей независимости. Недостатком здесь является то, что вы должны потратить время на то, чтобы вручную выполнить реорганизацию (добавить пространства имен, реорганизовать физическое расположение заголовочных файлов и т.д.). Обычно это стоит того, так как при этом приложение становится модульным и позволяет отдельным людям сосредоточиться только на их локальной функциональной области.
Количество необходимого ручного труда обратно пропорционально количеству времени, потраченному на первоначальную разработку модульности. Начните с нескольких хороших методик достижения модульности, и ваш код будет масштабируемым.
Если вы еще не используете пространства имен, вы, возможно, по крайней мере, слышали о них и уже используете одно из них: пространство имен std, которое является пространством имен, содержащим стандартную библиотеку. Исходя из моего опыта, пространства имен используются не настолько часто, насколько следовало бы но это не потому, что они очень сложны или их использование требует больших усилии. Рецепт 2.3 объясняет, как с помощью пространств имен сделать код модульным.
Многие рецепты этой главы описывают методики, применяемые в заголовочных файлах. Так как здесь обсуждается несколько возможностей, каждая из которых относится к отдельной части заголовочного файла, я поместил во введение пример 2.1, который показывает, как выглядит типичный заголовочный файл, который использует все методики, описанные в этой главе.
Пример 2.1. Заголовочный файл
#ifndef MYCLASS_H__ // защита #include, рецепт 2.0
#define MYCLASS_H__
#include <string>
namespace mylib { // пространства имен, рецепт 2.3
 class AnotherClass; // предварительное объявление класса, рецепт 2.2
 class Logger;
 extern Logger* gpLogger; // объявление внешнего хранилища, рецепт 2.1
 class MyClass {
 public:
  std::string getVal() const;
  // ...
 private:
  static int refCount_;
  std::string val_;
 };
}
// Встраиваемые определения, рецепт 2.4
inline std::string MyClass::getVal() const {
 return(val_);
}
#include "myclass.inl"
} // namespace
#endif // MYCLASS_H__
После написания заголовочного файла также вам будет нужен файл реализации, под которым я понимаю файл .cpp, содержащий не только объявления, но и определения. Файл реализации оказывается менее сложным, чем заголовочный файл, но ради полноты пример 2.2 содержит пример реализации файла, идущего в комплекте с заголовочным файлом из примера 2.1.
Пример 2.2. Файл реализации
#include "myclass.h"
namespace mylib {
 MyClass::refCount_ = 0; // статическое определение, рецепт 8.4
 MyClass::foo() { // реализация метода
  // ...
 };
}
Конечно, файлы реализации будут полны обдуманных, хорошо написанных комментариев, но ради простоты я оставляю этот вопрос за скобками.
2.1. Обеспечение единственности подключения заголовочного файла
Проблема
У вас есть заголовочный файл, который подключается несколькими другими файлами. Вы хотите убедиться, что препроцессор сканирует объявления в заголовочном файле не более одного раза.
Решение
В заголовочном файле с помощью #define определите макрос и содержимое заголовочного файла подключайте только тогда, когда макрос еще не был определен. Используйте такую комбинацию директив препроцессора #ifndef, #define и #endif, как я делаю в примере 2.1:
#ifndef MYCLASS_H__ // защита #include
#define MYCLASS_H__
// Здесь поместите все. что требуется...
#endif // MYCLASS_H__
Когда препроцессор сканирует такой заголовочный файл, одной из первых встреченных им вещей будет директива #ifndef и следующий за ней символ, #ifndef говорит препроцессору перейти на следующую строку только в том случае, если символ MYCLASS_H__ еще не определен. Если он уже определен, препроцессор должен пропустить код до закрывающей директивы #endif. Строка, следующая за #ifndef, определяет MYCLASS_H__, так что если этот файл при одной и той же компиляции сканируется препроцессором дважды, то второй раз MYCLASS_H__ будет уже определен. Поместив весь код между #ifndef и #endif, вы гарантируете, что в процессе компиляции он будет прочитан только один раз.
Обсуждение
Если вы не используете эту методику, которая называется защитой заголовка, то вы, вероятно, уже видели ошибки компиляции «symbol already defined» (символ уже определен), которые являются следствием отсутствия защитных мер против множественных определений. C++ не позволяет определять один и тот же символ несколько раз, и если вы это сделаете (целенаправленно или случайно), то получите ошибку компилятора. Включение защиты предотвращает такие ошибки, и она стала стандартной методикой.
Определяемый с помощью #define макрос не обязан следовать какому-либо формату, но использованный мной синтаксис имеет широкое распространение. Его идея состоит в том, чтобы использовать символ, который не будет конфликтовать с другим макросом, в результате чего файл будет непреднамеренно пропускаться препроцессором. На практике вы можете столкнуться и с другими методиками, такими как включение в макрос версии заголовочного файла или модуля, т.е. MYCLASS_H_V301__, или, возможно, имени автора. Не имеет значения, как вы его назвали, до тех пор, пока вы придерживаетесь единой схемы. Эти макросы должны использоваться только в заголовочном файле, который они защищают, и больше нигде.
В некоторых фрагментах кода можно увидеть внешнюю защиту заголовков, которая аналогична описанной ранее внутренней защите заголовков, за исключением того, что она используется в файле, включающем заголовочный файл, а не в самом заголовочном файле.
#ifndef MYCLASS_H__
#include "myclass.h"
#endif
Это сокращает процесс включения, поскольку, если макрос MYCLASS_H__ уже определен, файл myclass.h даже не подключается. Несколько лет назад утверждалось, что внешняя защита заголовков в больших проектах снижает время компиляции, но компиляторы совершенствуются и внешняя защита больше не требуется. Не используйте ее.
Даже если вы работаете над небольшим проектом, всегда следует помещать в заголовочный файл защиту заголовка. Если заголовочный файл включается в более чем одном файле, имеется вероятность, что в один прекрасный момент вы увидите ошибку переопределения. Более того, небольшие проекты стремятся за очень короткое время превратиться в большие, и хотя проект мог начинаться с единственного исполняемого файла и набора заголовочных файлов, включаемых только один раз, рано или поздно проект вырастет, и начнут появляться ошибки компиляции. Если вы с самого начала добавите защиту заголовков, вам не придется в будущем возвращаться и добавлять их сразу в большое количество файлов.
2.2. Обеспечение единственности экземпляра переменной при большом количестве исходных файлов
Проблема
Требуется, чтобы одна и та же переменная использовалась различными модулями программы, а копия переменной должна быть только одна. Другими словами, это должна быть глобальная переменная.
Решение
Объявите и определите как обычно переменную в одном файле реализации, а в других файлах реализации, где требуется доступ к этой переменной, используйте ключевое слово extern. Часто это означает включение объявлений extern в заголовочные файлы, используемые файлами реализаций, которым требуется доступ к глобальной переменной. Пример 2.3 содержит несколько файлов, которые показывают, как используется ключевое слово extern для доступа к переменным, определенным в другом файле реализации.
Пример 2.3. Использование ключевого слова extern
// global.h
#ifndef GLOBAL_H__ // см. рецепт 2.0
#define GLOBAL_H__
#include <string>
extern int x;
extern std::string s;
#endif
// global.cpp
#include <string>
int x = 7;
std::string s = "Kangaroo";
// main.cpp
#include <iostream>
#include "global.h"
using namespace std;
int main() {
 cout << "x = " << x << endl;
 cout << "s = " << s << endl;
}
Обсуждение
Ключевое слово extern — это способ сказать компилятору, что реальная область памяти для переменной выделяется в другом месте, extern говорит компоновщику, что переменная описана где-то в другом объектном файле и что компоновщик должен найти ее при создании конечного исполняемого файла или библиотеки. Если компоновщик не находит переменной, объявленной как extern, или если он находит более одного ее определения, он генерирует ошибку компоновки.
Пример 2.3 не слишком впечатляет, но он хорошо иллюстрирует вопрос. Две мои глобальные переменные объявляются в global.cpp:
int x = 7;
std::string s = "Kangaroo";
Мне требуется доступ к ним из других файлов реализации, так что я поместил в заголовочный файл global.h объявление extern для них:
extern int x;
extern std::string s;
Разница между объявлением и определением очень важна. В C++ можно объявить что-либо несколько раз, при условии совпадения объявлений, но определить что-либо можно только один раз. Это называется правилом одного определения (на самом деле в некоторых случаях определить объект можно несколько раз, но только если определения абсолютно идентичны — обычно это бессмысленно). Ключевое слово extern — это механизм, позволяющий сказать компилятору и компоновщику, что определение находится где-то еще и что оно должно быть разрешено при компоновке.
Нельзя сказать, что использование extern должно быть постоянным. Его следует использовать обдуманно и только тогда, когда это необходимо, так как оно позволяет создавать переменные, глобальные для всего приложения. Иногда оно может потребоваться для поистине глобальных объектов или данных — объекта журналирования, оборудования, большого объекта общих данных, но в большинстве случаев имеются более адекватные альтернативы.
2.3. Снижение числа #include с помощью предварительного объявления классов
Проблема
Имеется заголовочный файл, который ссылается на классы из других заголовочных файлов, и требуется снизить зависимости компиляции (и, возможно, время).
Решение
Чтобы избежать ненужных зависимостей при компиляции, везде, где только возможно, используйте предварительное объявление классов. Пример 2.4. является коротким примером предварительного объявления класса.
Пример 2.4. Предварительное объявление класса
// myheader.h
#ifndef MYHEADER_H__
#define MYHEADER_H__
class A; // заголовок для А включать не требуется
class В {
public:
 void f(const A& a);
 // ...
private:
 A* a_;
};
#endif
Где-то в другом месте имеется заголовочный файл и, вероятно, файл реализации, который объявляет и определяет класс А, но в файле myheader.h подробности класса А меня не волнуют: все, что мне требуется знать, — это то, что А — это класс.
Обсуждение
Предварительное объявление класса — это способ игнорировать подробности, о которых не требуется беспокоиться. В примере 2.4 myheader.h не должен знать о классе А ничего, кроме того, что он существует и что это класс.
Рассмотрим, что случится, если с помощью #include включить заголовочный файл для А, или, что более реально, заголовочный файл для полудюжины или более классов, присутствующих в реальном заголовочном файле. Тогда файл реализации (myheader.cpp) будет включать заголовочный файл myheader.h, так как он содержит все объявления. До сих пор все было хорошо. Но если вы измените один из заголовочных файлов, включаемых в myheader.h (или один из заголовочных файлов, включаемых одним из этих файлов), то потребуется перекомпилировать все файлы реализации, включающие myheader.h.
Создайте предварительное объявление класса, и эти зависимости компиляции исчезнут. Использование предварительного объявления просто создает имя, на которое можно ссылаться далее в заголовочном файле. Компоновщик должен будет сам найти в файлах реализаций подходящее определение.
К несчастью, использовать предварительное объявление можно не всегда. Класс В в примере 2.4 использует только указатели или ссылки на A, так что ему достаточно только предварительного объявления. Однако если бы в определении класса В я использовал функцию-член (метод) или переменную А или если бы создавал объект типа А, а не только указатель или ссылку на него, то предварительного объявления окажется недостаточно. Причиной этого является то, что файлы, включающие myheader.h, должны знать размер В, и если A является членом В, то компилятор, чтобы определить размер В, должен знать размер А. Указатель или ссылка на что-либо всегда имеют один и тот же размер, так что в случае использования указателей или ссылок подробности об А компилятор не интересуют, и, следовательно, заголовочный файл не требуется
Неудивительно, что если включить в myheader.h какое-либо определение, использующее членов A, то потребуется включить через #include заголовок для А. Это требуется для того, чтобы компилятор мог проверить сигнатуру используемой функции-члена А или тип переменной-члена А. Вот иллюстрация кода, требующего #include.
#include "a.h"
class B {
public:
 void f(const A& a) {
  foo_ = a.getVal(); // требуется знать, допустимо ли a.getVal
 }
}
// ...
В общем случае используйте предварительное объявление тогда, когда это позволяет снизить количество #include, что отражается на времени компиляции.
2.4. Предотвращение конфликта имен с помощью пространств имен
Проблема
В несвязанных между собой модулях обнаружены конфликтующие имена или требуется заранее избежать возможности таких конфликтов, создав логические группы кода.
Решение
Для структурирования кода используйте пространства имен. С помощью пространств имен можно объединять большие группы кода, находящиеся в разных файлах, в единое пространство имен. Для разбиения больших модулей на подмодули можно использовать вложенные пространства имен, и потребители вашего модуля смогут выборочно открывать элементы вашего пространства имен, которые им требуются. Пример 2.5 показывает несколько способов использования пространства имен.
Пример 2.5. Использование пространств имен
// Devices.h
#ifndef DEVICES_H__
#define DEVICES_H__
#include <string>
#include <list>
namespace hardware {
 class Device {
 public:
  Device(): uptime_(0), status_("unknown") {}
  unsigned long getUptime() const;
  std::string getStatus() const;
  void reset();
 private:
  unsigned long uptime_;
  std::string status_;
 };
 class DeviceMgr {
 public:
  void getDeviceIds(std::list<std::string>& ids) const;
  Device getDevice(const std::string& id) const;
  // Other stuff...
 };
}
#endif // DEVICES_H__
// Devices.cpp
#include "Devices.h"
#include <string>
#include <list>
namespace hardware {
 using std::string;
 using std::list;
 unsigned long Device::getUptime() const {
  return(uptime__);
 }
 string Device::getStatus() const {
  return(status_);
 }
 void DeviceMgr::getDeviceIds(list<string>& ids) const {}
 Device DeviceMgr::getDevice(const string& id) const {
  Device d;
  return(d);
 }
}
// DeviceWidget.h
#ifndef DEVICEWIDGET_H__ #define DEVICEWIDGET_H__
#include "Devices.h"
namespace ui {
 class Widget {/*... */ };
 class DeviceWidget : public Widget {
 public:
  DeviceWidget(const hardware::Device& dev) : device_(dev) {}
  // Some other stuff
 protected:
  hardware::Device device_;
 };
}
#endif // DEVICEWIDGET_H__
// main.cpp
#include <iostream>
#include "DeviceWidget.h"
#include "Devices.h"
int main( ) {
 hardware::Device d;
 ui::DeviceWidget myWidget(d);
 // ...
}
Обсуждение
Пример 2.5 более сложен, но давайте разберем его по частям, так как он иллюстрирует несколько ключевых моментов, связанных с пространствами имен. Представьте, что вы пишете управляющее приложение, которое должно взаимодействовать с различным оборудованием. С целью устранения конфликтов имен вы можете разбить это приложение на два или более пространств имен или просто разделить его логически на две части.
Вначале рассмотрим файл Devices.h. Он содержит пару классов, которые управляют элементами оборудования, — Device и DeviceMgr. Однако они не должны находиться в глобальном пространстве имен (что означало бы, что их имена видны в любом месте программы), так что я поместил их в пространство имен hardware.
#ifndef DEVICES_H__ // см. рецепт 2.0
#define DEVICES_H__
#include <string>
#include <list>
namespace hardware {
 class Device {
  // ...
 };
 class DeviceMgr {
  // ...
 };
}
#endif // DEVICES_H__
Этот механизм прост: «оберните» все, что требуется поместить в пространство имен, в блок namespace.
Приведенный выше фрагмент — это объявление Device и DeviceMgr, но нам также требуется подумать об их реализациях, которые находятся в файле Devices.cpp. И снова оберните все в блок namespace — он будет добавлен к уже имеющемуся содержимому этого пространства имен.
#include "Devices.h"
#include <string>
#include <list>
namespace hardware {
 using std::string;
 using std::list;
 // Реализация Device и DeviceMgr
}
В данный момент пространство имен hardware содержит все, что требуется. Все, что осталось, — это где-то его использовать. Для этого имеется несколько способов. Способ, который был использован в примере 2.5, состоит в указании полного имени класса Device, включая пространство имен, как здесь.
#ifndef DEVICEWIDGET_H_
#define DEVICEWIDGET_H_
#include "Devices.h"
namespace ui {
 class Widget { /* ... */ };
 class DeviceWidget : public Widget {
 public:
  DeviceWidget(const hardware::Device& dev) : device_(dev) {}
  // Other stuff...
 protected:
  hardware::Device device_;
 };
}
#endif // DEVICEWIDGET_H__
Также я использую этот способ в main в main.cpp.
int main() {
 hardware::Device d;
 ui::DeviceWidget myWidget(d);
}
Чтобы добавить к одному из пространств имен типы, объявите заголовочный файл и файл реализации так, как показано в примере 2.5. При каждом использовании блока пространства имен, обрамляющего код, этот код добавляется в это пространство имен, так что в пространстве имен может находиться код, который ничего не знает о другом коде этого же пространства имен.
При использовании подхода с указанием полных имен классов, включающих пространство имен, вы быстро устанете вводить код. Имеется пара способов устранить эту проблему. Для полного имени типа с помощью ключевого слова using можно создать псевдоним.
using hardware::Device;
int main() {
 Device d; // Пространство имен не требуется
 ui::DeviceWidget myWidget(d);
}
В последующем коде вместо ввода полного имени можно просто сослаться на этот псевдоним. Или можно с помощью using импортировать все содержимое пространства имен, а не только один содержащийся в нем тип.
using namespace hardware;
int main() {
 Device d:
 ui::DeviceWidget myWidget(d);
}
Этот вариант вы, вероятно, уже использовали, или, по крайней мере, видели в примерах, при использовании стандартной библиотеки (эту методику используют многие примеры в этой книге). Вся стандартная библиотека находится в пространстве имен std, так что очень часто вы увидите такое:
using namespace std;
Импорт всего пространства имен часто является плохой идеей и обычно рассматривается как плохой стиль. В примерах в этой книге мы импортируем полное содержимое пространства имен std только с целью повышения ясности кода и обычно рекомендуем не делать этого в реальных программах.
При импорте всего пространства имен или даже нескольких пространств имен их полезность значительно снижается. Одной из причин существования пространств имен является снижение конфликтов имен. При импорте нескольких различных пространств имен вероятность конфликтов имен увеличивается. В данный момент код может прекрасно компилироваться, но в будущем в одно из пространств имен может быть что-то добавлено, и при последующей сборке кода возникнет конфликт.
Чтобы разделить содержимое пространства имен на более мелкие группы, можно использовать вложенные пространства имен. Например, пространство имен hardware, определенное в примере 2.5, может на самом деле содержать большое количество сетевых классов и еще больше классов устройств, так что его можно было бы разделить, вложив еще несколько описательных имен.
namespace hardware {
 namespace net {
  // сетевые классы
 }
 namespace devices {
  // классы устройств
 }
}
Теперь доступ к элементам, содержащимся в пространстве имен, стал несколько более сложным.
// В каком-либо другом файле...
using hardware::devices::Device;
Пространства имен довольно удобны. Есть несколько интересных вещей, связанных с пространствами имен, облегчающих жизнь: псевдонимы пространств имен, автоматический поиск имен в пространствах имен параметров функций и подстановка имен перегрузок функций в объявлениях using. Последние два длинны по названиям, но просты.
Псевдоним пространства имен — это то, что означает его название: имя (возможно, короткое), которое используется для замены имени (возможно, длинного) пространства имен. Если вы не хотите использовать выражение using, но также не хотите вводить при каждом использовании класса огромное полное имя, создайте для него псевдоним.
using dev = hardware::devices;
// ...
dev::Device d;
Затем этот псевдоним используется при ссылке на элементы соответствующего пространства имен.
C++ также предоставляет автоматический поиск в пространствах имен, к которым относятся параметры функций. Так, например, следующий код описывает аргументы в пространстве имен (dev — это пространство имен, в котором объявлен Device):
void f(dev::Device& d) {
 register(d); // на самом деле это dev::register
}
При передаче функции параметра, принадлежащего пространству имен, компилятор включает это пространство имен при поиске имен функций, вызываемых в теле этой функции. Это, может быть, не самая часто используемая особенность, но когда она используется, то экономит значительное время набора кода и позволяет избежать лишних директив using. В основе этого лежит идея о том, что функции, которые оперируют с каким-либо типом, часто определяются в том же пространстве имен, что и этот тип. Кстати, вообще всегда, когда возможно, следует помещать функции, оперирующие определенными типами, в то же пространство имен, в котором находятся эти типы.
Последним интересным моментом, связанным с пространствами имен, является подстановка имен перегрузок в объявлениях using. Рассмотрим такой пример.
namespace mylib {
 void foo(mt);
 void foo(double);
 void foo(std::string);
 // Другие перегрузки foo( )...
}
// В каком-то другом файле...
using mylib::foo; // Какой вариант используется?
Объявление using соответствует всем перегрузкам foo, так что писать отдельную директиву для каждой перегрузки не требуется. Другим преимуществом этой записи является то, что если добавляется еще одна перегрузка foo, то весь код, содержащий объявление вида mylib::foo, видит ее автоматически (конечно, при компиляции кода, содержащего это объявление), так как объявление using включает и ее.
Конечно, использовать пространства имен следует обдуманно, а иначе у вас или тех, кто будет их использовать, появятся неожиданные ошибки компиляции. Вот несколько популярных советов по использованию пространств имен.
Как можно реже используйте using namespace xxx
Как я объяснял ранее, импорт всего пространства имен увеличивает вероятность конфликта имен — либо сразу, либо в будущем (в используемое вами пространство имен может быть добавлено что-то, что приведет к конфликту). Это также снижает степень модульности, предоставляемую пространствами имен.
Не используйте оператор using в заголовочных файлах
Заголовочные файлы включаются большим количеством других файлов, так что использование пространства имен или чего-либо из пространства имен в заголовочном файле открывает его файлам, включающим этот заголовочный файл. Решение этой проблемы заключается в указании в заголовочных файлах полных имен.
Не помещайте объявления using или определения перед директивами #include
Если это сделать, тогда то, что указано в директиве using, будет открыто для кода заголовочного файла, что, вероятно, не входило в намерения автора этого заголовочного файла.
При выполнении этих правил использование пространств имен в новом проекте или добавление их в существующий проект должно быть относительно просто.
2.5. Включение встраиваемого файла
Проблема
Имеется несколько функций-членов или самостоятельных функций, которые требуется сделать встраиваемыми (inline), но вы не хотите определять их все в определении класса (или даже после него) в заголовочном файле. Это позволит хранить объявление и реализацию по отдельности.
Решение
Создайте файл .inl и с помощью #include включите его в конец своего заголовочного файла. Это эквивалентно помещению определения функции в конец заголовочного файла, но позволяет хранить объявление и определение раздельно. Пример 2.6 показывает, как это делается.
Пример 2.6. Использование встраиваемого файла
// Value.h
#ifndef VALUE_H__
#define VALUE_H__
#include <string>
class Value {
public:
 Value (const std::string& val) : val_(val) {}
 std::string getVal() const;
private:
 std::string val_;
};
#include "Value.inl"
#endif VALUE_H__
// Value.inl
inline std::string Value::getVal() const {
 return(val_);
}
Это решение не требует пояснений, #include заменяется на содержимое ее аргумента, так что здесь в заголовочный файл включается содержимое Value.inl. Следовательно, любой файл, включающий этот заголовочный файл, содержит определения встраиваемых функций, но вам не требуется загромождать объявление класса.
Глава 3
Числа
3.0. Введение
Даже если вы не занимаетесь написанием научных или инженерных приложений, вам все равно придется работать с числами. Эта глава содержит решения проблем, часто возникающих при работе с числовыми типами С++.
Некоторые из рецептов содержат методики преобразования из числовых типов в тип string и обратно чисел, представленных в различных форматах (шестнадцатеричном, с плавающей точкой или экспоненциальном). Самостоятельное написание кода для таких преобразований утомительно и требует времени, так что я показываю возможности стандартной библиотеки или одной из библиотек Boost, облегчающие выполнение этих задач. Также имеется несколько рецептов по работе исключительно с числовыми типами: безопасное преобразование между ними, сравнение чисел с плавающей точкой с граничными значениями и поиск минимального и максимального значений.
Рецепты в этой главе предоставляют решения некоторых общих проблем, с которыми обычно сталкиваются при работе с числами в С++, но они не пытаются решать проблем, специфичных для конкретных приложений. При написании научного или инженерного приложения вам также следует взглянуть на главу 11, которая содержит рецепты ко многим общим научным и инженерным алгоритмам.
3.1. Преобразование строки в числовой тип
Проблема
Имеются числа в строковом формате, и вам требуется преобразовать их в числовой тип, такой как int или float.
Решение
Это можно сделать двумя способами — с помощью функций стандартной библиотеки или с помощью класса lexical_cast из Boost (написанного Кевлином Хенни (Kevlin Henney) Функции стандартной библиотеки неуклюжи и небезопасны, но они стандартны, и в некоторых случаях потребуются именно они, так что в первом решении я представлю именно их. lexical_cast более безопасен, проще в использовании и интереснее, так что я представляю его в обсуждении.
Функции strtol, strtod и strtoul, определенные в <cstdlib>, преобразуют символьные строки, ограниченные нулем, в long int, double или unsigned long. Они могут использоваться для преобразования чисел, представленных в виде строк с любым основанием, в числовые типы. Код примера 3.1 демонстрирует функцию hex2int, которая предназначена для преобразования шестнадцатиричной строки в long.
Пример 3.1. Преобразование числовых строк в числа
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;
long hex2int(const string& hexStr) {
 char *offset;
 if (hexStr.length( ) > 2) {
  if (hexStr[0] == '0' && hexStr[1] == 'x') {
   return strtol(hexStr.c_str(), &offset, 0);
  }
 }
 return strtol(hexStr.c_str( ), &offset, 16);
}
int main() {
 string str1 = "0x12AB";
 cout << hex2int(str1) << endl;
 string str2 = "12AB";
 cout << hex2int(str2) << endl;
 string str3 = "0AFG";
 cout << hex2int(str3) << endl;
}
Вот вывод этой программы.
4779
4779
0
Первые две строки содержат шестнадцатеричное число 12AB. Первая из них содержит префикс 0x, а вторая — нет. Третья строка не содержит правильного шестнадцатеричного числа. В этом случае функция просто возвращает 0.
Обсуждение
Некоторые люди склонны писать свои собственные функции для преобразования шестнадцатеричных чисел в целочисленные форматы. Но зачем изобретать колесо? Стандартная библиотека уже предоставляет эту функциональность. Пример 3.1 представляет собой функцию-оболочку, упрощающую вызов strtol. Функция strtol — это старая функция библиотеки С, и она требует от вас передачи указателя на завершающуюся нулем строку, а так же адрес еще одного указателя на строку. Этот второй указатель получает адрес, на котором обработка строки завершилась. Однако в C++ большинство людей предпочитает работать с более мощным классом string, а не со старыми указателями на символьные строки. Поэтому функция hex2int принимает параметр типа string.
Функция strtol несколько странна в том, что она позволяет использовать два разных метода указания основания 16: 16 можно передать как третий параметр функции, а можно в качестве основания передать 0, но предварить строку символами 0x (точно также, как это делается для обозначения шестнадцатеричных чисел в коде, но только помните, что в случае с strtol передается строка).
Пример 3.1 позволяет использовать оба метода. При передаче строки вида 0x12AB функция обнаружит 0x и передаст ее непосредственно в strtol, в качестве третьего параметра передав 0. В противном случае функция передаст строку, в качестве третьего параметра передав 16.
strtol и strtoul работают одинаково, за исключением типа возвращаемого значения. strtod аналогична им, но не позволяет указывать основание.
Эти старые функции С не являются единственным способом преобразования строк в числа. Проект Boost предоставляет класс преобразования lexical_cast, который выполняет то же самое для числовых строк, записанных с основанием 10. Пример 3.2 показывает как он используется.
Пример 3.2. Использование lexical_cast
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>
using namespace std;
int main() {
 string str1 = "750" ;
 string str2 = "2.71";
 string str3 = "0x7FFF";
 try {
  cout << boost::lexical_cast<int>(str1) << endl;
  cout << boost::lexical_cast<double>(str2) << endl;
  cout << boost::lexical_cast<int>(str3) << endl;
 } catch (boost::bad_lexical_cast& e) {
  cerr << "Bad cast: " << e.what() << endl;
 }
}
Вывод примера 3.2 таков.
750
2.71
Bad cast: bad lexical cast: source type value could not be
interpreted as target
(Неверное преобразование: неверное лексическое преобразование: значение исходного типа не может быть преобразовано в целевой.)
Вы ведите, что для последнего значения, представляющего собой шестнадцатеричное число, он выбрасывает исключение. При преобразовании чисел с основанием, отличным от 10, требуется использовать функции strtol.
Также имеются версии функций strtol для работы с «широкими» символами. Эквивалент strtol для работы с широкими символами — это wcstol, которая объявлена в <cwchar>. Эквивалентами функций strtod и strtoul являются wcstod и wcstoul. Каждая из этих функций точно такая же, за исключением того, что те параметры, которые в функциях для узких символов имеют тип char*, в функциях для широких символов имеют тип wchar_t*.
Смотри также
Рецепт 3.2.
3.2. Преобразование чисел в строки
Проблема
Имеются числовые типы (int, float), и вам требуется поместить их содержимое в string, возможно, предварительно отформатировав.
Решение
Для выполнения этого имеется множество способов, каждый из которых имеет свои достоинства и недостатки. Первая представляемая мной методика использует для хранения строковых данных класс stringstream, который является частью стандартной библиотеки и прост в использовании. Этот подход показан в примере 3.3. Смотри обсуждение альтернативных методик.
Пример 3.3. Форматирование числа как строки
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
using namespace std;
int main() {
 stringstream ss;
 ss << "В моей корзине " << 9 << " яблок.";
 cout<<ss.str() <<endl; //stringstream::str() возвращает string
                        // с содержимым
 ss.str(""); // Очистка строки
 ss << showbase << hex << 16; // Показать основание в шестнадцатеричном формате
 cout << "ss = " << ss.str() << endl;
 ss.str("");
 ss << 3.14;
 cout << "ss = " << ss.str() << endl;
}
Вывод примера 3.3 выглядит так.
В моей корзине 9 яблок.
ss = 0x10
ss = 3.14
Обсуждение
stringstream — это удобный способ поместить данные в string, поскольку он позволяет использовать все возможности форматирования, предоставляемые классами стандартного ввода и вывода. В простейшем случае в примере 3.3 я для записи комбинации текста и числовых данных в строковый поток просто использую оператор сдвига влево (<<).
ss << "В моей корзине " << 9 << " яблок.";
Оператор << перегружен для встроенных типов и соответственно форматирует вывод. Когда требуется получить данные, хранящиеся в string, используйте функцию-член str.
cout << ss.str() << endl;
В <iomanip> имеется большое количество манипуляторов потоками, и их использование при выводе числовых данных в строку позволяет выполнить все виды форматирования. В примере 3.3 для форматирования числа как шестнадцатеричного я использовал showbase и hex, но есть еще и другие возможности форматирования. Например, можно установить точность отображения, отличную от числа десятичных знаков по умолчанию.
ss << setprecision(6) << 3.14285;
Однако использование манипуляторов является не самой интуитивно понятной вещью, и именно поэтому создан рецепт, посвященный им. За дополнительной информацией о форматировании числовых данных с помощью манипуляторов потоками обратитесь к рецепту 10.2.
Конечно, как часто бывает в С++, имеется и другой способ. Библиотека Boost Format (написанная Сэмюэлем Кремппом (Samuel Krempp) содержит класс format, который делает форматирование и преобразование очень простыми. Пример 3.4 показывает, как выполнить подобное преобразование.
Пример 3.4. Форматирование целых в шестнадцатеричное представление
#include <iostream>
#include <boost/format.hpp>
using namespace std;
using boost::format;
using boost.:io::str;
using boost::io::format_error;
int main() {
 try {
  format f("Имеется %1% способа. %2% %3% %4%");
  f % 3;
  f % "чтобы" % "это" % "сделать.";
  cout << f << endl;
  f.clear(); // Счистка буферов для форматирования чего-либо еще
  f.parse("Это стоит $%d.");
  f % 50;
  cout << f << endl;
  int x = 11256099;
  string strx = str(format("%x") % x);
  cout << strx << endl;
 } catch (format_error &e) {
  cout << e.what() << endl;
 }
}
Вот что вы увидите при запуске этой программы.
Имеется 3 способа, чтобы это сделать.
Это стоит $50.
abc123
Использование класса format требует двух шагов, включая создание объекта format и передачу ему содержимого. Для простейшего случая в примере 3.4 я создал объект format с помощью простейшей версии его синтаксиса.
format f(" Имеется %1% способа, %2% %3% %4%");
В строке формата заполнители — это числа, обрамленные с обеих сторон символами %. Затем я начинаю передавать в объект содержимое указанного формата.
f % 3;
f % "чтобы" % "это" % "сделать;
Оператор % в библиотеке форматирования был переопределен так, чтобы добавлять указанные в нем переменные в левую часть объекта format. Его можно использовать как один раз на строку, так и несколько раз в одной строке. Он аналогичен оператору << для строк. Что же касается оператора <<, он также был переопределен так, что объекты format можно непосредственно записать в выходной поток. Кроме того, если требуется поместить результаты в строку, используйте функцию-член str.
string s = f.str();
Если же вам нравится printf, то можно использовать форматную строку printf.
f.parse("Это стоит $%d.*");
f % 50;
Если будет записано слишком много или слишком мало переменных для указанного формата, то при попытке записать строку в поток или извлечь отформатированную строку будет выброшено исключение format_error (или подкласс thereof).
Класс format достаточно мощен и содержит слишком много возможностей форматирования, чтобы их можно было описать здесь, и его стоит изучить. Чтобы скачать Boost или почитать документацию, посетите web-сайт Boost по адресу www.boost.org.
Также для преобразования чисел из числовых типов в строки можно использовать sprintf или аналогичные ей функции. Обычно этого следует избегать, так как это небезопасно и для этого имеются лучшие альтернативы.
Смотри также
Глава 10.
3.3. Проверка, содержит ли строка допустимое число
Проблема
Имеется строка string и требуется определить, содержит ли она допустимое число.
Решение
Для проверки допустимости числа можно использовать шаблон функции lexical_cast библиотеки Boost. При таком подходе допустимое число может включать предшествующий знак минус, предшествующий знак плюс, но не пробел. В примере 3.5 приводятся несколько образцов типов форматов, с которыми работает lexical_cast.
Пример 3.5. Проверка числовой строки
#include <iostream>
#include <boost/lexical_cast.hpp>
using namespace std;
using boost::lexical_cast;
using boost::bad_lexical_cast;
template<typename T>
bool isValid(const string& num) {
 bool res = true;
 try {
  T tmp = lexical_cast<T>(num);
 } catch (bad_lexical_cast &e) {
  res = false;
 }
 return(res);
}
void test(const string& s) {
 if (isValid<int>(s))
  cout << s << " - допустимое целое число." << endl;
 else
  cout << s << " - HE допустимое целое число." << endl;
 if (isValid<double>(s))
  cout << s << " - допустимое число двойной точности." << endl;
 else
  cout << s << " - HE допустимое число двойной точности." << endl;
 if (isValid<float>(s))
  cout << s << " - допустимое число одинарной точности." << endl;
 else
  cout << s << " - HE допустимое число одинарной точности " << endl;
}
int main() {
 test("12345");
 test("1.23456");
 test("-1.23456");
 test(" - 1.23456");
 test("+1.23456");
 test(" 1.23456 ");
 test("asdf");
}
Вот вывод этого примера.
12345 - допустимое целое число.
12345 - допустимое число двойной точности.
12345 - допустимое число одинарной точности.
1.23456 - НЕ допустимое целое число.
1.23456 - допустимое число двойной точности.
1.23456 - допустимое число одинарной точности.
-1.23456 - НЕ допустимое целое число.
-1.23456 - допустимое число двойной точности.
-1.23456 - допустимое число одинарной точности.
- 1.23456 - НЕ допустимое целое число.
- 1 23466 - НЕ допустимое число двойной точности.
- 1.23456 - НЕ допустимое число одинарной точности.
+1.23456 - НЕ допустимое целое число.
+1.23456 - допустимое число двойной точности.
+1.23456 - допустимое число одинарной точности.
 1.23456 - НЕ допустимое целое число.
 1.23456 - НЕ допустимое число двойной точности.
 1.23456 - НЕ допустимое число одинарной точности.
asdf - НЕ допустимое целое число.
asdf - НЕ допустимое число двойной точности.
asdf - НЕ допустимое число одинарной точности.
Обсуждение
Шаблон функции lexical_cast преобразует значение из одного типа в другой. Он объявлен следующим образом.
template<typename Target, typename Source>
Target lexical_cast(Source arg)
Source — это тип оригинальной переменной, a Target — это тип переменной, в которую значение преобразуется. Таким образом, например, чтобы преобразовать из string в int, вызов lexical_cast имеет вид:
int i = lexical_cast<int>(str); // str - это строка
lexical_cast проводит анализ и пытается выполнить преобразование. Если преобразование невозможно, он выбрасывает исключение bad_lexical_cast. В примере 3.5 я только хочу проверить допустимость, и мне не требуется сохранять целевую переменную, так что если исключение не выбрасывается, я возвращаю true, а в противном случае — false.
В lexical_cast требуется передать только первый аргумент, поскольку это шаблон, что означает, что компилятор может догадаться, какой тип имеет аргумент функции, и использовать его в качестве второго аргумента. Пояснение этой ситуации более сложно, чем простая демонстрация, так что позвольте мне использовать фрагмент кода примера. Вместо того чтобы вызывать lexical_cast, как в предыдущем фрагменте кода, можно сделать так.
int i = lexical_cast<int, string>(str);
Это означает то же самое, но указывать аргумент string не требуется, так как компилятор видит, что str — это string, и понимает, что от него требуется дальше.
Если вы собираетесь написать аналогичную функцию-обертку для проверки допустимости, возвращающую true и false, ее также можно написать как шаблон функции. В этом случае ее потребуется написать только один раз с использованием параметризованного типа, а различные версии будут генерироваться при каждом ее использовании с различными типами.
lexical_cast также удобен для преобразования из одного числового типа в другой. Более подробно это обсуждается в рецепте 3.6.
Смотри также
Рецепт 3.6.
3.4. Сравнение чисел с плавающей точкой с ограниченной точностью
Проблема
Требуется сравнить значения с плавающей точкой, но при этом выполнить сравнение на равенство, больше чем или меньше чем с ограниченным количеством десятичных знаков. Например, требуется, чтобы 3.33333 и 3.33333333 считались при сравнении с точностью 0.0001 равными.
Решение
Напишите свои функции сравнения, которые принимают в качестве параметра ограничение точности сравнения. Пример 3.6 показывает основную методику, используемую в такой функции сравнения.
Пример 3.6. Сравнение чисел с плавающей точкой
#include <iostream>
#include <cmath> // для fabs()
using namespace std;
bool doubleEquals(double left, double right, double epsilon) {
 return (fabs(left - right) < epsilon);
}
bool doubleLess(double left, double right, double epsilon,
 bool orequal = false) {
 if (fabs(left - right) < epsilon) {
  // В рамках epsilon, так что считаются равными
  return (orequal);
 }
 return (left < right);
}
bool doubleGreater(double left, double right, double epsilon,
 bool orequal = false) {
 if (fabs(left - right) < epsilon) {
  // В рамках epsilon, так что считаются равными
 return (orequal);
 }
 return (left > right);
}
int main() {
 double first = 0.33333333;
 double second = 1.0 / 3.0;
 cout << first << endl;
 cout << second << endl;
 // Тест на прямое равенство. Не проходит тогда, когда должно проходить.
 // (boolalpha печатает булевы значения как "true" или "false")
 cout << boolalpha << (first == second) << endl;
 // Новое равенство. Проходит так, как требуется в научном приложении.
 cout << doubleEquals(first, second, .0001) << endl;
 // Новое меньше чем
 cout << doubleLess(first, second, .0001) << endl;
 // Новое больше чем
 cout << doubleGreater(first, second, .0001) << endl;
 // Новое меньше чем или равно
 cout << doubleLess(first, second, .0001, true) << endl;
 // Новое больше чем или равно
 cout << doubleGreater(first, second, .0001, true) << endl;
}
Далее показан вывод этого примера.
0.333333
0.333333
false
true
false
false
true
true
Обсуждение
Код примера 3.6 начинается с двух значений — 0.33333333 и того, что компьютер получает в результате деления 1.0 / 3.0. Он с помощью форматирования по умолчанию cout печатает эти два значения. Они кажутся одинаковыми и равными 0.333333. Однако при сравнении этих двух значений они оказываются различными. Значение 1.0 / 3.0 имеет больше значащих цифр, чем 0.33333333, и, следовательно, как полагает машина, эти два числа не равны. Однако в некоторых приложениях может потребоваться, чтобы они считались равными.
Чтобы добиться этого, надо написать собственные функции сравнения чисел с двойной точностью: doubleLess, doubleEquals и doubleGreater, каждая из которых принимает в качестве параметров два значения типа double. Кроме того, doubleLess и doubleGreater имеют дополнительный параметр, который при его равенстве true приводит к тому, что эти функции ведут себя как «меньше или равно» и «больше или равно» соответственно.
Чтобы заставить эти функции учитывать точность, рассмотрим функцию doubleEquals. Вместо того чтобы проверять на равенство, эта функция проверяет, находится ли разность двух чисел в указанном пользователем диапазоне epsilon. (В качестве epsilon пример использует значение 0.0001.) Если это так, то функция возвращает значение true, что означает, что значения одинаковы. Таким образом, равными окажутся значения 0.3333, 0.33333, 0.333333, 0.33333333333 и 0.33333323438.
Чтобы выполнить операцию «меньше чем» и «больше чем», вначале проверьте, не равны ли значения, как это делается в функции doubleEquals. Если так, то при наличии теста на равенство верните true, а в противном случае — false. В противном случае выполните прямое сравнение.
3.5. Лексический анализ строки, содержащей число в экспоненциальной форме
Проблема
Имеется строка, содержащая число в экспоненциальной форме, и требуется сохранить значение числа в переменной типа double.
Решение
Наиболее простым способом анализа числа в экспоненциальной форме является использование встроенного в библиотеку C++ класса stringstream, объявленного в <sstream>, как показано в примере 3.7.
Пример 3.7. Лексический анализ числа в экспоненциальной форме
#include <iostream>
#include <sstream>
#include <string>
using namespace std;
double sciToDub(const strings str) {
 stringstream ss(str);
 double d = 0;
 ss >> d;
 if (ss.fail()) {
  string s = "Невозможно отформатировать ";
  s += str;
  s += " как число!";
  throw (s);
 }
 return (d);
}
int main() {
 try {
  cout << sciToDub("1.234e5") << endl;
  cout << sciToDub("6.02e-2") << endl;
  cout << sciToDub("asdf") << endl;
 } catch (string& e) {
  cerr << "Ошибка: " << e << endl;
 }
}
Далее показан вывод этого кода.
123400
0.0602
Ошибка: невозможно отформатировать asd как число!
Обсуждение
Класс stringstream — это string, который ведет себя как поток (что неудивительно). Он объявлен в <sstring>. Если требуется выполнить анализ string, содержащей число в экспоненциальной форме (см. также рецепт 3.2), то с этой работой прекрасно справится stringstream. Стандартные классы потоков уже «знают», как анализировать числа, так что не тратьте без острой необходимости время на повторную реализацию этой логики.
В примере 3.7 я написал простую функцию sciToDub, принимающую параметр типа string и возвращающую содержащийся в ней double, если он допустим. В sciToDub я использую stringstream следующим образом.
stringstream ss(str); // Конструирование из строки типа string
double d = 0;
ss >> d;
if (ss.fail()) {
 string s = "Невозможно отформатировать ";
 s += str;
 s += " как число!";
 throw (s);
}
return (d);
Наиболее важной частью здесь является то, что все, что требуется сделать, — это использовать для чтения из строкового потока в double оператор сдвига вправо (>>), как это делается при чтении из cin.
Ну, это не совсем все, что требуется сделать. Если в stringstream записано значение, которое не может быть записано в переменную в правой части оператора >>, то для потока будет выставлен бит fail. Этот бит можно проверить с помощью функции-члена fail (на самом деле это функция-член basic_ios, который является родительским классом для stringstream). Кроме того, переменная справа от оператора >> в случае ошибки значения не меняет.
Однако с целью обобщения можно избежать написания отдельных версий sciToDub для типов int, float, double и чего-либо еще, что может потребоваться преобразовать, если написать шаблон функции. Рассмотрим такую новую версию.
template<typename T>
T strToNum(const string& str) {
 stringstream ss(str);
 T tmp;
 ss >> tmp;
 if (ss.fail()) {
  string s = "Невозможно отформатировать ";
  s += str;
  s += " как число!";
  throw (s);
 }
 return (tmp);
}
Теперь, чтобы преобразовать string в числовой тип, можно сделать так.
double d = strToNum<double>("7.0");
float f = strToNum<float>("7.0");
int i = strToNum<int>("7.0");
Также параметром шаблона можно сделать тип символов, но это очень просто сделать, так что я оставляю это в качестве вашего упражнения.
Смотри также
Рецепт 3.2.
3.6. Преобразования между числовыми типами
Проблема
Имеется число одного типа и требуется преобразовать его в другой, как int в short или наоборот, но при этом необходимо перехватывать все ошибки переполнения (overflow) или потери значимости (underflow), возникающие при работе программы.
Решение
Используйте шаблон класса numeric_cast Boost. Он выполняет проверки, которые при переполнениях переменной, принимающей значение, или других ошибках выбрасывают исключение типа bad_numeric_cast. Пример 3.8 показывает, как это выполняется.
Пример 3.8. Безопасное преобразование чисел
#include <iostream>
#include <boost/cast.hpp>
using namespace std;
using boost::numeric_cast;
using boost::bad_numeric_cast;
int main() {
 // Целые типы
 try {
  int i = 32767;
  short s = numeric_cast<short>(i);
  cout << "s = " << s << endl;
  i++; // Теперь i выходит за диапазон (если sizeof(short) равен 2)
  s = numeric__cast<short>(i);
 } catch (bad_numeric_cast& e) {
  cerr << e.what() << endl;
 }
 try {
  int i = 300;
  unsigned int ui = numeric_cast<unsigned int>(i);
  cout << ui << endl; // Прекрасно
  i *= -1;
  ui = numeric_cast<unsigned int>(i); // i отрицателен!
 } catch (bad_numeric_cast& e) {
  cerr << e.what() << endl;
 }
 try {
  double d = 3.14.
  int i = numeric_cast<int>(d);
  i = numeric_cast<int>(d); // Это отрезает 0.14!
  cout << i << endl; // i = 3
 } catch (bad_numeric_cast& e) {
  cerr << e.what( ) << endl;
 }
}
Обсуждение
Вы, вероятно, знаете, что базовые типы C++ имеют различные размеры. Стандарт C++ содержит жесткие указания по относительному размеру типов: int всегда не короче, чем short int, но он не указывает абсолютных размеров. Это означает, что если взять long int и попытаться записать его значение в short или попытаться поместить int в unsigned int, то информация о значении переменной-источника, такая как знак или даже часть числового значения, может быть потеряна.
Только знания, что это может привести к проблемам, не достаточно. Вы можете быть ограничены жесткими требованиями по объему и не захотите использовать четыре байта для long, когда можно обойтись двумя байтами для short (если ваша платформа на самом деле использует такие размеры, что очень распространено, но не гарантируется). Из-за ограничений по объему может возникнуть желание попробовать хранить значения в наименьших возможных типах. Если вы любите приключения, но вам нужна страховка, для перехвата потерь данных при работе программы используйте numeric_cast из Boost.
Синтаксис numeric_cast очень прост. Это шаблон функции, объявленный следующим образом.
template<typename Target, typename Source>
inline Target numeric_cast(Source arg)
Если вы уже прочли рецепты 3.1 и 3.3, он аналогичен lexical_cast. У него имеется два параметра шаблона — Target и Source, — которые представляют типы оригинального и результирующего значений. Так как это шаблон функции, компилятор может догадаться о типе аргумента Source, так что требуется указать только Target, как здесь.
int i = 32767;
short s = numeric_cast<short>(i);
short — это аргумент, передаваемый в шаблон как параметр Target. Компилятор догадывается, что Source имеет тип int потому, что i имеет тип int.
В этом случае я впихиваю int в short. В моей системе (Windows XP) int имеет длину четыре байта, a short — два. short имеет знак, это означает, что для представления числа в нем используется 15 бит и, следовательно, максимальным допустимым положительным значением для него является 32 767. Приведенный выше фрагмент кода работает молча, но когда я увеличиваю i на единицу, она выходит за диапазон short.
s = numeric_cast<short>(i); // Ох!
Вы уже догадались, что выбрасывается исключение bad_numeric_cast. Смотри остальную часть примера 3.8: numeric_cast также перехватывает потери знака, возникающие при присвоении отрицательного значения со знаком типу без знака.
Но numeric_cast не решает всех проблем. Если попытаться поместить значение с плавающей точкой в тип без плавающей точки, то будет потеряно все, что находится справа от десятичной точки, так? numeric_cast в этой ситуации не спасает, так что не думайте, что он сможет уберечь вас от всех рискованных предприятий. Например, рассмотрим такой фрагмент кода из примера 3.8:
double a = 3.14;
int i = numeric_cast<int>(d); // Ох!
Здесь не будет выброшено никаких исключений. Но это произойдет, если попробовать такое:
double d = -3.14;
unsigned int ui = numeric_cast<unsigned int>(d);
Потому что, несмотря на то что происходит потеря всего, что находится справа от десятичной точки, происходит потеря знака, а это очень плохо.
Смотри также
Рецепты 3.1 и 3.3.
3.7. Получение минимального и максимального значений числового типа
Проблема
Требуется узнать наибольшее и наименьшее значения, представляемые на данной платформе числовым типом, таким как int или double.
Решение
Чтобы среди прочего получить максимальное и минимальное допустимые значения числового типа, используйте шаблон класса numeric_limits из заголовочного файла <limits> (см. пример 3.9).
Пример 3.9. Получение числовых ограничений
#include <iostream>
#include <limits>
using namespace std;
template<typename T>
void showMinMax() {
 cout << "min: " << numeric_limits<T>::min() << endl;
 cout << "max: " << numeric_limits<T>::max() << endl;
 cout << endl;
}
int main() {
 cout << "short:" << endl;
 showMinMax<short>();
 cout << "int:" << endl;
 showMinMax<int>();
 cout << "long:" << endl;
 showMinMax<long>();
 cout << "float:" << endl;
 showMinMax<float>();
 cout << "double:" << endl;
 showMinMax<double>();
 cout << "long double:" << endl;
 showMinMax<long double>();
 cout << "unsigned short:" << endl;
 showMinMax<unsigned short>();
 cout << "unsigned int:" << endl;
 showMinMax<unsigned int>();
 cout << "unsigned long:" << endl;
 showMinMax<unsigned long>();
}
Вот что я получил в Windows XP, используя Visual C++ 7.1.
short:
min: -32768
max: 32767
int:
min: -2147483648
max: 2147483647
long:
min -2147483648
max 2147483647
float:
min: 1.17549e-038
max: 3.40282e-038
double:
min: 2.22507e-308
max: 1.79769e+308
long double:
min: 2.22507e-308
max: 1.79769e+308
unsigned short:
min: 0
max: 65535
unsigned int:
min: 0
max: 4294967295
unsigned long:
min: 0
max: 4294967295
Обсуждение
Пример 3.9 показывает простой пример получения минимального и максимального значений встроенных числовых типов. Шаблон класса numeric_limits имеет специализации для всех встроенных типов, включая как числовые, так и нечисловые типы. Стандарт требует, чтобы все типы, которые я использовал в примере 3.9, а также перечисленные далее, имели свою специализацию numeric_limits.
bool
char
signed char
unsigned char
wchar_t
min и max — это функции-члены numeric_limits типа static, которые возвращают наименьшее и наибольшее значения для типа переданного им параметра.
Глава 4
Строки и текст
4.0. Введение
Эта глава содержит рецепты работы со строками и текстовыми файлами. Большая часть программ на C++ независимо от сферы их применения в той или иной степени работает со строками и текстовыми файлами. Однако, несмотря на различия в сферах применения, требования к ним часто одни и те же: для строк — обрезка, дополнение, поиск, разбиение и т.п.; для текстовых файлов — перенос строк, переформатирование, чтение файлов с разделителями и др. Следующие рецепты предоставляют решения многих из часто встречающихся задач, не имеющих готовых решений в стандартной библиотеке С++.
Стандартная библиотека переносима, стандартизована и в общем случае не менее эффективна, чем самодельное решение, так что в следующих примерах я предпочитаю ее коду, написанному с нуля. Она содержит богатый раздел для работы со строками и текстом, большая часть которого заключена в шаблоне классов basic_string (для строк), basic_istream и basic_ostream (для входных и выходных текстовых потоков). Почти все методики, описанные в этой главе, используют или расширяют эти шаблоны классов. В тех случаях, когда они не делают того, что требуется, я использую другую часть стандартной библиотеки, содержащей общие готовые решения: алгоритмы и контейнеры.
Строки используют все, так что если что-то, что вам требуется, отсутствует в стандартной библиотеке, то велика вероятность, что это уже написано кем-то другим. Библиотека Boost String Algorithms (алгоритмы для работы со строками), написанная Паволом Дробой (Pavol Droba), заполняет большинство пробелов стандартной библиотеки, реализуя большую часть алгоритмов, которые могут понадобиться в различных ситуациях, и делает это переносимым и эффективным способом. Для получения дополнительной информации и документации по библиотеке String Algorithms обратитесь к проекту Boost по адресу www.boost.org. Библиотека String Algorithms и решения, приводимые в этой главе, в некоторых частях дублируют друг друга. В большинстве случаев я привожу примеры или, по крайней мере, упоминаю алгоритмы Boost связанные с приводимым решением.
Для большинства примеров приводится как версия с использованием шаблонов, так и без них. Это сделано по двум причинам. Во-первых, большая часть областей стандартной библиотеки, использующих символьные данные, — это шаблоны классов, параметризованных по типу символов — узкие (char) или широкие (wchar_t). Следуя этой модели, можно повысить совместимость программного обеспечения со стандартной библиотекой. Во-вторых, работаете ли вы со стандартной библиотекой или нет, шаблоны классов и функций предоставляют прекрасную возможность написания программного обеспечения, не привязанного к конкретной ситуации. Однако, если шаблоны не нужны, используйте нешаблонные версии, хотя, если вы новичок в шаблонах, я рекомендую вам поэкспериментировать с ними.
Стандартная библиотека очень активно использует шаблоны, а для того, чтобы оградить программистов от многословного синтаксиса шаблонов, использует typedef. В результате термины basic_string, string и wstring используются как взаимозаменяемые, поскольку то, что верно для одного из них, обычно верно и для двух других, string и wstring являются typedef для basic_string<char> и basic_string<wchar_t>.
Наконец, вы, вероятно, заметите, что ни один из рецептов этой главы не использует строк в стиле С, т.е. заканчивающихся нулем символьных массивов. Стандартная библиотека предоставляет такую богатую, эффективную и расширяемую поддержку строк С++, что использование строковых функций в стиле С (которые поддерживаются с целью обратной совместимости) — это уход от гибкости, безопасности и общей природы того, что дается бесплатно компилятором: классов строк С++.
4.1. Дополнение строк
Проблема
Требуется «дополнить» — или заполнить - строку некоторым количеством символов до определенной длины. Например, может потребоваться дополнить строку "Chapter 1" точками до 20 символов в длину так, чтобы она выглядела как "Chapter 1...........".
Решение
Для дополнения строк начальными или концевыми символами используйте функции-члены (методы) insert и append класса string. Например, чтобы дополнить конец строки 20 символами X:
std::string s = "foo";
s.append(20 - s.length(), 'X');
Чтобы дополнить начало строки:
s.insert(s.begin(), 20 - s.length(), 'X');
Обсуждение
Разница в использовании двух функций заключается в первом параметре insert. Это итератор, который указывает на символ, справа от которого требуется вставить новые символы. Метод begin возвращает итератор, указывающий на первый элемент строки, так что в этом примере последовательность символов добавляется слева от него. Параметры, общие для всех функций, — это количество раз, которое требуется повторить символ, и сам символ.
insert и append — это методы шаблона класса basic_string, описанного в заголовочном файле <string> (string — это typedef для basic_string<char>, a wstring — это typedef для basic_string<wchar_t>), так что они работают как для строк из узких, так и широких символов. Их использование по мере необходимости, как в предыдущем примере, прекрасно работает, но при использовании методов basic_string в собственных вспомогательных функциях общего назначения эти функции следует создавать, используя общий существующий дизайн стандартной библиотеки и шаблоны функций. Рассмотрим код примера 4.1, который определяет общий шаблон функции pad, который работает для строк типа basic_string.
Пример 4.1. Общий шаблон функции pad
#include <string>
#include <iostream>
using namespace std;
// Общий подход
template<typename >
void pad(basic_string<T>& s,
 typename basic_string<T>::size_type n, T c) {
 if (n > s.length())
  s.append(n - s.length(), c);
}
int main() {
 string s = "Appendix A";
 wstring ws = L"Acknowledgments"; // "L" указывает, что
                                  // этот литерал состоит из
 pad(s, 20. "*");                 // широких символов
 pad(ws, 20, L'*');
 // cout << s << std::endl; // He следует пытаться выполнить это
 wcout << ws << std::endl;  // одновременно
}
pad в примере 4.1 дополняет данную строку s до длины n, используя символ c. Так как шаблон функции использует параметризованный тип элементов строки (T), он будет работать для basic_string из любых символов: char, wchar_t или любых других, определенных пользователем.
4.2. Обрезка строк
Проблема
Требуется обрезать несколько символов в конце или начале строки, обычно пробелов.
Решение
Для определения позиции строки, которую требуется удалить, используйте итераторы, а для ее удаления — метод erase. Пример 4.2 показывает функцию rtrim, которая удаляет символ в конце строки.
Пример 4.2. Обрезка символов строки
#include <string>
#include <iostream>
// Подход для строк из узких символов
void rtrim(std::string& s, char с) {
 if (s.empty()) return;
 std::string::iterator p;
 for (p = s.end(); p != s.begin() && *--p == c;);
 if (*p != c) p++;
 s.erase(p, s.end());
}
int main() {
 std::string s = "zoo";
 rtrim(s, 'o');
 std::cout << s << '\n';
}
Обсуждение
Пример 4.2 выполняет все необходимое для строк длины char, но работает только для них. Аналогично тому, что показано в примере 4.1, можно использовать общий дизайн basic_string и шаблон функции. Пример 4.3 использует для удаления символов в конце строки любого типа шаблон функции.
Пример 4.3. Обобщенная версия rtrim
#include <string>
#include <iostream>
using namespace std;
// Общий подход к обрезке отдельных
// символов строки
template<typename T>
void rtrim(basic_string<T>& s, T с) {
 if (s.empty()) return;
 typename basic_string<T>::iterator p;
 for (p = s.end(); p != s.begin() && *--p == c;);
 if (*p != c) p++;
 s.erase(p, s.end());
}
int main() {
 string s = "Great!!!!";
 wstring ws = L"Super!!!!";
 rtrim(s, '!');
 rtrim(ws, L'!');
 cout << s << '\n';
 wcout << ws << L'\n';
}
Эта функция работает точно так же, как и предыдущая, необобщенная версия из примера 4.2, но так как она параметризована по типу символов, она будет работать для basic_string любого типа.
Примеры 4.2 и 4.3 удаляют из строки последовательность одного символа. Однако обрезка пробелов выглядит по-другому, так как пробельный символ может быть представлен одним из нескольких символов. Для удобства стандартная библиотека предоставляет простейший способ справиться с этим: функцию isspace из заголовочного файла <cctype> (и ее wchar_t-эквивалент iswspace из <cwctype>). Пример 4.4 определяет общую функцию, которая обрезает концевые пробелы.
Пример 4.4. Удаление концевых пробелов
#include <string>
#include <iostream>
#include <cctype>
#include <cwctype>
using namespace std;
template<typename T, typename F>
void rtrimws(basic_string<T>& s, F f) {
 if (s.empty()) return;
 typename basic_string<T>::iterator p;
 for (p = s.end(); p ! = s.begin() && f(*--p););
 if (!f(*p))
  p++;
 s.erase(p, s.end());
}
// Перегрузка для облегчения вызовов в клиентском коде
void rtrimws(string& s) {
 rtrimws(s, isspace);
}
void rtrimws(wstring& ws) {
 rtrimws(ws, iswspace);
}
int main() {
 string s = "zing ";
 wstring ws = L"zong ";
 rtrimws(s) rtrimws(ws);
 cout << s << "|\n";
 wcout << ws << L"|\n";
}
Шаблон функции rtrimws в примере 4 4 — это шаблон обобщённой функции, аналогичной предыдущим примерам, которая принимает basic_string и удаляет пробелы в ее конце. Но в отличие от других примеров, она для проверки элемента строки и определения того, должен ли он быть удален, принимает не символ, а объект функции.
Перегружать rtrimws, как это сделано в предыдущем примере, необязательно, но это упрощает синтаксис использования функции, так как вызывающий код при ее использовании может опустить аргумент логической функции.
Но, увы, это решение требует, чтобы вы писали код сами. Если же вы предпочитаете использовать библиотеку — и именно это и следует делать, — то библиотека Boost String Algorithms предоставляет огромное количество функций для обрезки строки, и в ней на верняка есть то, что вам надо. На самом деле, в библиотеке String Algorithms имеется огромное количество удобных функций обрезки, и при возможности использования Boost на них следует посмотреть. Таблица 4.1 приводит шаблоны функций этой библиотеки, используемые для обрезки строк, включая некоторые вспомогательные функции. Так как это шаблоны функций, они имеют параметры шаблонов, представляющие различные используемые типы. Вот что они означают.
Seq
Это тип, удовлетворяющий требованиям к последовательностям стандарта C++.
Coll
Это тип, удовлетворяющий менее строгим требованиям, чем стандартная последовательность. Для того чтобы узнать, каким требованиям удовлетворяет коллекция, обратитесь к определениям Boost String Algorithms.
Pred
Это объект функции или указатель на функцию, которая принимает один аргумент и возвращает логическое значение — другими словами, унарный предикат. В некоторые функции обрезки для обрезки элементов, удовлетворяющих некоторому критерию, можно передать собственный унарный предикат.
OutIt
Это тип, который удовлетворяет требованиям выходного итератора, как определено в стандарте С++. В частности, он должен поддерживать инкрементирование и присвоение нового положения для добавления элементов в конец последовательности, на которую он указывает.
Табл. 4.1. Шаблоны функций обрезки строк Boost
Объявление	Описание
template<typename Seq> void trim(Seq& s, const locale& loc = locale());	Обрезает пробелы с обоих концов строки, используя для классификации пробельных символов функцию классификации локали
template<typename Seq, typename Pred> void trim_if(Seq& s, Pred p);	Обрезает с обоих концов последовательности s элементы для которых p(*it) равно true, где it — это итератор, указывающий на элемент последовательности. Обрезка прекращается, когда p(*it) = false
template<typename Seq> Seq trim_copy(const Seq& s, const locale& loc = locale());	Делает то же самое, что и trim, но вместо изменения s возвращает новую последовательность, содержащую обрезанные результаты
template<typename Seq, typename Pred> Seq trim_copy_if(const Seq& s, Pred p);	Делает то же самое, что и trim_if, но вместо изменения s возвращает новую последовательность, содержащую обрезанные результаты
template<typename OutIt, typename Coll, typename Pred> OutIt trim_copy_if(OutIt out, const Coll& c, Pred p);	Делает то же, что и предыдущая версия trim_copy_if, но с некоторыми отличиями. Во-первых, она дает гарантию строгой безопасности исключений. Во-вторых, она в качестве первого аргумента принимает выходной итератор и возвращает выходной итератор, указывающий на одну позицию после конца результирующей последовательности. Наконец, она принимает тип коллекции, а не последовательности. За дополнительной информацией обратитесь к списку перед этой таблицей
trim_left trim_right	Работает как trim, но только для левого или правого конца строки
trim_left_if trim_right_if	Работает как trim_if, но только для левого или правого конца строки
trim_left_copy trim_right_copy	Работает как trim_сору, но только для левого или правого конца строки
trim_left_copy_if trim_right_copy_if	Работает как trim_copy_if, но только для левого или правого конца строки. Обе функции имеют две версии — одна работает с последовательностью, а другая — с коллекцией
Первые четыре шаблона функции, описанные в табл. 4.1, — это базовая функциональность функций обрезки библиотеки String Algorithms. Остальные являются вариациями на их тему. Чтобы увидеть некоторые из них в действии, посмотрите на пример 4.5. Он показывает некоторые преимущества от использования этих функций перед методами string.
Пример 4.5. Использование функций обрезки строк Boost
#include <iostream>
#include <string>
#include <boost/algorithm/string.hpp>
using namespace std;
using namespace boost;
int main() {
 string s1 = " ведущие пробелы?";
 trim_left(s1); // Обрезка оригинальной строки
 string s2 = trim_left_copy(s1); // Обрезка, но оригинал остается без изменений
 cout << "s1 = " << s1 << endl;
 cout << "s2 = " << s2 << endl;
 s1 = "YYYYboostXXX";
 s2 = trim_copy_if(s1, is_any_of("XY")); // Используется предикат
 trim_if(s1, is_any_of("XY"));
 cout << "s1 = " << s1 << endl;
 cout << "s2 = " << s2 << endl;
 s1 = "1234 числа 9876";
 s2 = trim_copy_if(s1, is_digit());
 cout << "s1 = " << s1 << endl;
 cout << "s2 = " << s2 << endl;
 // Вложенные вызовы функций обрезки
 s1 = " ****Обрезка!*** ";
 s2 = trim_copy_if(trim_copy(s1), is_any_of("*"));
 cout << "s1 = " << s1 << endl;
 cout << "s2 = " << s2 << endl;
}
Пример 4.5 демонстрирует, как использовать функции обрезки строк Boost. Обычно способ их использования понятен из их названия, так что я не буду вдаваться в описания более подробные, чем даны в табл. 4.1. Единственная функция, имеющаяся в этом примере и отсутствующая в таблице, — это is_any_of. Это шаблон функции, который возвращает объект функции-предиката, используемый функциями серии trim_if. Она используется, когда требуется обрезать набор символов. Также есть аналогичная функция классификации, которая называется is_from_range и принимает два аргумента и возвращает унарный предикат, который возвращает истину, когда символ находится в заданном диапазоне. Например, чтобы обрезать в строке символы с а до d, требуется сделать что-то, похожее на следующее.
s1 = "abcdXXXabcd";
trim_if(s1, is_from_range('a', 'd'));
cout << "s1 = " << s1 << endl; // Теперь s1 = XXX
Заметьте, что эта конструкция чувствительна к регистру, так как диапазон от а до d не включает заглавных версий этих букв.
4.3. Хранение строк в последовательности
Проблема
Требуется сохранить набор строк в виде последовательности, которая ведет себя как массив.
Решение
Для хранения строк в виде массива используйте vector. Пример 4.6 показывает простой образец.
Пример 4 6. Хранение строк в векторе
#include <string>
#include <vector>
#include <iostream>
using namespace std;
int main() {
 vector<string> v;
 string s = "one";
 v.push_back(s);
 s = "two";
 v.push_back(s);
 s = "three";
 v.push_back(s);
 for (int i = 0; i < v.size(); ++i) {
  cout << v[i] << "\n";
 }
}
vector использует для произвольного доступа семантику массива (а также делает много другого), так что он прост и понятен в использовании. Однако vector — это только одна из многих последовательностей стандартной библиотеки. Чтобы узнать об этом побольше, читайте дальше.
Обсуждение
vector — это динамическая последовательность объектов, которая предоставляет произвольный доступ с помощью оператора в стиле массивов operator[]. Метод push_back при помощи копирующего конструктора копирует свой аргумент, добавляет копию в последний элемент вектора и увеличивает его размер на единицу. pop_back выполняет обратную операцию, удаляя последний элемент. Вставка и удаление элементов в конце вектора занимает постоянное время, а время вставки и удаления элементов в середине вектора линейно зависит от его размера. Это основы векторов. Кроме этого, они умеют еще много чего.
В большинстве случаев vector должен быть первым выбором вместо массива в стиле С. Во-первых, их размеры изменяются динамически, что означает, что эти размеры увеличиваются по мере необходимости. Не требуется проводить каких-либо исследований для выбора оптимального размера статического массива, как в случае с массивами С, — vector растет по мере надобности, а при необходимости может быть увеличен или уменьшен вручную. Во-вторых, vector при использовании метода at (но не при использовании operator[]) предлагает проверку границ, так что при ссылке на несуществующий индекс программа не обрушится и не продолжит выполнение с неверными данными. Посмотрите на пример 4.7, Он показывает, как работать с индексами, выходящими за границы массива.
Пример 4.7. Проверка границ для векторов
#include <iostream>
#include <vector>
#include <exception>
using namespace std;
int main() {
 char carr[] = {'a', 'b', 'c', 'd', 'e'};
 cout << carr[100000] << '\n'; // Оп, кто знает, что дальше
                               // произойдет
 vector<char> v;
 v.push_back('a');
 v.push_back('b');
 v.push_back('c');
 v.push_back('d');
 v push_back('e');
 try {
  cout << v.at(10000) << "\n"; // at проверяет границы и выбрасывает
 } catch(out_of_range& е) {    // out_of_range, если произошел выход за них
  cerr << e.what() << '\n';
 }
}
Перехват out_of_range, определенного в <stdexcept>, позволяет грамотно справиться с неправильными индексами. А также можно вызвать метод what, позволяющий в зависимости от используемой реализации получить осмысленное сообщение об ошибке, как возвращаемая в коде примера 4.7:
invalid vector<T> subscript
Однако vector не является единственной возможностью. В C++ имеется большое количество способов хранить последовательности. Кроме vector имеются list, set и двунаправленные очереди (deque — double-ended queue). Все они поддерживают множество одинаковых операций, и каждый поддерживает свои собственные. Кроме того, каждый имеет различную алгоритмическую сложность, требования по хранению и семантику. Так что имеется богатый выбор.
Посмотрите внимательно на пример 4.6. Вы, вероятно, обратите внимание, что я изменяю значение строки s до того, как добавляю ее в конец контейнера с помощью push_back. Логично ожидать такого вывода этого примера
three
three
three
Я поместил в вектор одну и ту же строку три раза, так что каждый раз, когда я переприсваиваю строку, разве не должны все элементы вектора указывать на одну и ту же строку? Нет. Это важный момент, касающийся контейнеров STL.
Контейнеры STL сохраняют копии объектов, помещаемых в них, а не сами объекты. Так что после помещения в контейнер всех трех строк в памяти остается четыре строки: три копии, созданные и хранящиеся в контейнере, и одна копия, которой присваиваются значения.
Ну и что? Было создано несколько новых копий: большое дело. Но это действительно большое дело, так как если используется большое количество строк, за каждую копию приходится платить процессорным временем, памятью или и тем и другим. Копирование элементов в контейнерах — это намеренное поведение STL, и все контейнеры организованы именно так.
Одним из решений (определенно не единственным) является хранение в контейнере указателей. Но помните, что контейнер не удаляет с помощью delete указатели при его уничтожении. Память для указателей выделяет ваш код, так что он и должен ее очищать. Это относится и к ситуации, когда происходит полное удаление контейнера и когда удаляется только один его элемент.
В целях создания альтернативного решения давайте рассмотрим еще одну возможность. Рассмотрим шаблон класса list, определенный в <list>, который является двусвязным списком (doubly linked list). Если планируется большое количество вставок и удалений элементов в середине последовательности или если требуется гарантировать, что итераторы, указывающие на элементы последовательности, не станут недействительными при ее изменении, используйте list. Пример 4.8 вместо vector для хранения нескольких строк типа string использует list. Также он для перебора этих строк и печати вместо оператора индекса, как это делается в случае с простыми массивами, использует for_each.
Пример 4.8. Хранение строк в списке
#include <string>
#include <list>
#include <algorithm>
#include <iostream>
using namespace std;
void write(const string& s) {
 cout << s << '\n';
}
int main() {
 list<string> lst;
 string s = "нож";
 lst.push_front(s);
 s = "вилка";
 lst.push_back(s);
 s = "ложка";
 lst.push_back(s);
 // У списка нет произвольного доступа, так что
 // требуется использовать for_each()
 for_each(lst.begin(), lst.end(), write);
}
Целью этого отступления от первоначальной проблемы (хранения строк в виде последовательностей) является краткое введение в последовательности STL. Здесь невозможно дать полноценное описание этого вопроса. За обзором STL обратитесь к главе 10 книги C++ in a Nutshell Рэя Лишнера (Ray Lischner) (O'Reilly).
4.4. Получение длины строки
Проблема
Требуется узнать длину строки.
Решение
Используйте метод length класса string.
std::string s = "Raising Arizona";
int i = s.length();
Обсуждение
Получение длины строки — это тривиальная задача, но она является хорошей возможностью обсудить схему размещения string (как узких, так и широких символов). string, в отличие от массивов строк, завершаемых нулем, в С являются динамическими и увеличиваются по мере надобности. Большая часть реализаций стандартной библиотеки начинают с относительно низкой емкости и увеличивают ее в два раза каждый раз, когда достигается предел. Знание того, как анализировать этот рост, если и не точного алгоритма, помогает диагностировать проблемы производительности, связанные со строками.
Символы в basic_string хранятся в буфере, который является единым фрагментом памяти статического размера. Этот буфер, используемый строкой, изначально имеет некий размер, и по мере добавления в строку символов он заполняется до тех пор, пока не будет достигнут предел его емкости. Когда это происходит, буфер увеличивается. В частности, выделяется новый буфер большего размера, символы копируются из старого буфера в новый, и старый буфер удаляется.
Определить размер буфера (не число символов, в нем содержащихся, а его максимальный размер) можно с помощью метода capacity. Если требуется вручную установить емкость и избежать ненужных копирований буфера, используйте метод reserve и передайте ему числовой аргумент, указывающий требуемый размер буфера. Также имеется максимально возможный размер буфера, получить который можно с помощью вызова max_size. Это все можно использовать, чтобы посмотреть на расходование памяти в данной реализации стандартной библиотеки. Посмотрите на пример 4.9, показывающий, как это сделать.
Пример 4.9. Длина строки и ее емкость
#include <string>
#include <iostream>
using namespace std;
int main() {
 string s = "";
 string sr = "";
 sr.reserve(9000);
 cout << "s.length = " << s.length( ) << '\n';
 cout << "s.capacity = " << s.capacity( ) << '\n';
 cout << "s.max.size = " << s.max_size() << '\n';
 cout << "sr.length = " << sr.length() << '\n';
 cout << "sr.capacity = " << sr.capacity() << '\n';
 cout << "sr.max_size = " << sr.max_size() << '\n';
 for (int i = 0; i < 10000; ++i) {
  if (s.length() == s.capacity()) {
   cout << "s достигла емкости " << s.length() << увеличение... \n";
  }
  if (sr.length() == sr.capacity()) {
   cout << "sr достигла емкости " << sr.length() << ", увеличение...\n";
  }
  s += 'x';
  sr += 'x';
 }
}
При использовании Visual C++ 7.1 вывод выглядит так.
s.length = 0
s.capacity = 15
s.max_size = 4294967294
sr.length = 0
sr.capacity = 9007
sr.max_size = 4294967294
s достигла емкости 15, увеличение...
s достигла емкости 31, увеличение...
s достигла емкости 47, увеличение...
s достигла емкости 70, увеличение...
s достигла емкости 105, увеличение...
s достигла емкости 157, увеличение...
s достигла емкости 235, увеличение...
s достигла емкости 352, увеличение...
s достигла емкости 528, увеличение...
s достигла емкости 792, увеличение...
s достигла емкости 1188, увеличение...
s достигла емкости 1782, увеличение...
s достигла емкости 2673, увеличение...
s достигла емкости 4009, увеличение...
s достигла емкости 6013, увеличение...
sr достигла емкости 9007, увеличение...
s достигла емкости 9019, увеличение...
Здесь происходит то, что буфер строки заполняется по мере добавления в него символов. Если буфер оказывается полон (т.е. длина = емкость), выделяется новый буфер, и символы оригинальной строки и новый добавляемый символ (или символы) копируются в этот новый буфер, s начинает заполняться с емкости 15 (зависит от компилятора), а затем увеличивается каждый раз примерно на 50%.
Если ожидается значительное увеличение строки или имеется большое количество строк, которые будут увеличиваться хотя бы немного, для минимизации числа перераспределений буфера используйте reserve. Также следует провести эксперименты с имеющейся реализацией стандартной библиотеки и посмотреть, как она выполняет увеличение строк.
Кстати, когда потребуется узнать, пуста ли строка, не сравнивайте ее размер с нулем, а просто вызовите метод empty. Это метод, который возвращает истину, если длина строки равна нулю.
4.5. Обращение строк
Проблема
Требуется обратить (реверсировать) строку.
Решение
Чтобы обратить строку «на месте», не используя временной строки, используйте шаблон функции reverse из заголовочного файла <algorithm>:
std::reverse(s.begin(), s.end());
Обсуждение
reverse работает очень просто: она изменяет диапазон, переданный ей, так, что его порядок меняется на обратный оригинальному. Время, необходимое для этого, линейно зависит от длины диапазона.
В случае, если требуется скопировать строку в другую строку, но в обратном порядке символов, используйте реверсивные итераторы, как здесь:
std::string s = "Los Angeles";
std::string rs;
rs.assign(s.rbegin(), s.rend());
rbegin и rend возвращают реверсивные итераторы. Реверсивные итераторы ведут себя так, как будто они просматривают последовательность в обратном порядке. rbegin возвращает итератор, который указывает на последний элемент, a rend возвращает итератор, указывающий на позицию перед первым элементом. Это в точности обратно тому, что делают begin и end.
Но должны ли вы обращать строку? С помощью rbegin и rend для обратной строки можно использовать все методы или алгоритмы, работающие с диапазонами итераторов. А если требуется выполнить поиск в строке, то можно использовать rfind, которая делает то же, что и find, но начинает с конца строки и движется к ее началу. Для больших строк или большого количества строк обращение может оказаться очень дорогостоящим, так что при возможности избегайте его.
4.6. Разделение строки
Проблема
Требуется разделить строку с разделителями на несколько строк. Например, может потребоваться разделить строку "Name|Address|Phone" на три отдельных строки — "Name", "Address" и "Phone", удалив при этом разделитель.
Решение
Для перехода от одного вхождения разделителя к следующему используйте метод find класса basic_string, а для копирования каждой подстроки используйте substr. Для хранения результатов используйте любую стандартную последовательность. Пример 4.10 использует vector.
Пример 4.10. Разделение строки с разделителями
#include <string>
#include <vector>
#include <functional>
#include <iostream>
using namespace std;
void split(const string& s, char c, vector<string>& v) {
 string::size_type i = 0;
 string::size_type j = s.find(c);
 while (j != string::npos) {
  v.push_back(s.substr(i, j-i));
  i = ++j;
  j = s.find(c, j);
  if (j == string::npos)
   v.push_back(s.substr(i, s.length()));
 }
}
int main() {
 vector<string> v;
 string s = "Account Name|Address 1|Address 2 |City";
 split(s, '|', v);
 for (int i = 0; i < v.size(); ++i) {
  cout << v[i] << '\n';
 }
}
Обсуждение
Превращение приведенного выше примера в шаблон функции, принимающий любой тип символов, тривиально — просто параметризуйте тип символов и замените случаи использования string на basic_string<T>.
template<typename T>
void split(const basic_string<T>& s, T c,
 vector<basic_string<T> >& v) {
 basic_string<T>::size_type i = 0;
 basic_string<T>::size_type j = s.find(c);
 while (j != basic_string<T>::npos) {
  v.push_back(s.substr(i, j-i));
  i = ++j;
  j = s.find(c, j);
  if (j == basic_string<T>::npos)
   v.push back(s.substr(i, s.length()));
 }
}
Логика при этом не меняется.
Однако обратите внимание, что между двумя последними угловыми скобками в последней строке заголовка функции добавлен один пробел. Это требуется для того, чтобы сказать компилятору, что это не оператор сдвига вправо.
Пример 4.10 разбивает строку с помощью простого алгоритма. Начиная с начала строки, он ищет первое вхождение разделителя с, а затем считает, что все, что стоит после начала строки или предыдущего найденного вхождения и до этого вхождения, является очередным фрагментом текста. Для поиска первого вхождения символа в оригинальной строке string пример использует метод find, а для копирования символов диапазона в новую string, помещаемую в vector, — метод substr. Это тот же самый принцип, который используется в функциях разбиения строк большинства скриптовых языков и является специальным случаем разделения строки текста на лексемы (tokenizing), описываемого в рецепте 4.7.
Разделение строки, использующей единственный символ-разделитель, является очень распространенной задачей, и неудивительно, что ее решение есть в библиотеке Boost String Algorithms. Оно просто в использовании. Чтобы увидеть, как разделить строку с помощью функции split из Boost, посмотрите на пример 4.11.
Пример 4.11. Разделение строки с помощью Boost
#include <iostream>
#include <string>
#include <list>
#include <boost/algorithm/string.hpp>
using namespace std;
using namespace boost;
int main() {
 string s = "one,two,three,four";
 list<string> results;
 split(results, s, is_any_of(",")); // Обратите внимание - это boost::split
 for (list<string>::const_iterator p = results.begin();
  p != results.end(); ++p) {
  cout << *p << endl;
 }
}
split — это шаблон функции, принимающий три аргумента. Он объявлен вот так.
template<typename Seq, typename Coll, typename Pred>
Seq& split(Seq& s, Coll& c, Pred p,
 token_compress_mode_type e = token_compress_off);
Seq, Coll и Pred представляют типы результирующей последовательности, входной коллекции и предиката, используемого для определения, является ли очередной объект разделителем. Аргумент последовательности — это последовательность, определенная по стандарту C++, содержащая нечто, что может хранить части того, что находится во входной коллекции. Так, например, в примере 4.11 был использован list<string>, но вместо него можно было бы использовать и vector<string>. Аргумент коллекции — это тип входной последовательности. Коллекция — это нестандартная концепция, которая похожа на последовательность, но с несколько меньшими требованиями (за подробностями обратитесь к документации по Boost по адресу www.boost.org). Аргумент предиката — это объект унарной функции или указатель на функцию, которая возвращает bool, указывающий, является ли ее аргумент разделителем или нет. Она вызывается для каждого элемента последовательности в виде f(*it), где it — это итератор, указывающий на элемент последовательности.
is_any_of — это удобный шаблон функции, поставляющийся в составе String Algorithms, которая облегчает жизнь при использовании нескольких разделителей. Он конструирует объект унарной функции, которая возвращает true, если переданный ей аргумент является членом набора. Другими словами:
bool b = is_any_of("abc")('a'); // b = true
Это облегчает проверку нескольких разделителей, не требуя самостоятельного написания объекта функции.
4.7. Разбиение строки на лексемы
Проблема
Требуется разбить строку на части, используя набор разделителей.
Решение
Для перебора элементов строки и поиска места нахождения следующих лексем и не-лексем используйте методы find_first_of и first_first_not_of. Пример 4.12 представляет простой класс StringTokenizer, выполняющий эту задачу.
Пример 4.12. Разбиение строки на лексемы
#include <string>
#include <iostream>
using namespace std;
// Класс, разбивающий строку на лексемы.
class StringTokenizer {
public:
 StringTokenizer(const string& s, const char* delim = NULL) :
  str_(s), count(-1), begin_(0), end_(0) {
  if (!delim)
   delim_ = " \f\n\r\t\v"; //по умолчанию пробельные символы
  else
   delim_ = delim;
  // Указывает на первую лексему
  begin_ = str_.find_first_not_of(delim);
  end_ = str.find_first_of(delim_, begin_);
 }
 size_t countTokens() {
  if (count_ >= 0) // если уже посчитали, то выход
   return(count_);
  string::size_type n = 0;
  string::size_type i = 0;
  for (;;) {
   // переход на первую лексему
   if ((i = str_.find_first_not_of(delim_, i)) == string::npos)
    break;
   // переход на следующий разделитель
   i = str_.find_first_of(delim_, i+1);
   n++;
   if (i == string::npos) break;
  }
  return (count_ = n);
 }
 bool hasMoreTokens() { return(begin_ != end_); }
 void nextToken(string& s) {
  if (begin_ != string::npos && end_ != string::npos) {
   s = str_.substr(begin_, end_-begin_);
   begin_ = str_.find_first_not_of(delim_, end_);
   end_ = str_.find_first_of(delim_, begin_);
  } else if (begin_ != string::npos && end_ == string::npos) {
   s = str_.substr(begin_, str_.length()-begin_);
   begin_ = str_.find_first_not_of(delim_, end_);
  }
 }
private:
 StringTokenizer() {}
 string delim_;
 string str_;
 int count_;
 int begin_;
 int end_;
};
int main() {
 string s = " razzle dazzle giddyup ";
 string tmp;
 StringTokenizer st(s);
 cout << "Здесь содержится" << st.countTokens() << " лексемы.\n";
 while (st.hasMoreTokens()) {
  st.nextToken(tmp);
  cout << "token = " << trap << '\n';
 }
}
Обсуждение
Разбиение строки с четко определенной структурой, как в примере 4.10, конечно, хорошо, но не все так просто. Предположим, что, вместо того чтобы просто разделить строку на основе единственного разделителя, требуется разбить строку на лексемы. Наиболее частым вариантом этой задачи является разделение на лексемы с игнорированием пробелов. Пример 4.12 дает реализацию класса StringTokenizer (аналогичного стандартному классу Java™ с таким же именем) для C++, который принимает символы-разделители, но по умолчанию использует пробелы.
Наиболее важные строки в StringTokenizer используют методы find_first_of и find_first_not_of шаблона класса basic_string. Их описание и примеры использования даны в рецепте 4.9. Пример 4.12 дает такой вывод.
Здесь содержится 3 лексемы.
token = razzle
token = dazzle
token = giddyup
StringTokenizer — это более гибкая форма функции split из примера 4.10. Он поддерживает свое состояние, так что можно просто последовательно переходить с одной лексемы на другую, не разбивая вначале всю строку на части. Также есть возможность подсчитать число лексем.
В StringTokenizer можно внести пару усовершенствований. Во-первых, для простоты StringTokenizer написан так, что он работает только с простыми строками — другими словами, строками из узких символов. Если требуется, чтобы один и тот же класс работал как с узкими, так и с широкими символами, параметризуйте тип символов, как это сделано в предыдущих рецептах. Другим улучшением является расширение StringTokenizer так, чтобы он обеспечивал более дружественное взаимодействие с последовательностями и был более гибок. Вы всегда можете сделать это сами, а можете использовать имеющийся класс разбиения на лексемы. Проект Boost содержит класс tokenizer, делающий все это. За подробностями обратитесь к www.boost.org.
Смотри также
Рецепт 4.24.
4.8. Объединение нескольких строк
Проблема
Имея последовательность строк, такую как вывод примера 4.10, вам требуется объединить их в одну длинную строку, возможно, с разделителями.
Решение
В цикле переберите всю последовательность строк и добавьте каждую из них в выходную строку. В качестве входа можно обрабатывать любую стандартную последовательность. Пример 4.13 использует vector из элементов типа string.
Пример 4.13. Объединение последовательности строк
#include <string>
#include <vector>
#include <iostream>
using namespace std;
void join(const vector<string>& v, char c, string& s) {
 s.clear();
 for (vector<string>::const_iterator p = v.begin();
  p ! = v.end(); ++p) {
  s += *p;
  if (p != v.end() - 1) s += c;
 }
}
int main() {
 vector<string> v;
 vector<string> v2;
 string s;
 v.push_back(string("fее"));
 v.push_back(string("fi"));
 v.push_back(string("foe"));
 v.push_back(string("fum"));
 join(v, '/', s);
 cout << s << '\n';
}
Обсуждение
Пример 4.13 содержит одну методику, которая несколько отличается от предыдущие примеров. Посмотрите на эту строку.
for (vector<string>::const_iterator p = v.begin();
Предыдущие примеры работы со строками использовали iterator'ы без части «const», но здесь без этого не обойтись, так как v объявлен как ссылка на объект const. Если имеется объект контейнера const, то для доступа к его элементам можно использовать только const_iterator. Это так потому, что простой iterator позволяет записывать в объект, на который он указывает, что, конечно, нельзя делать в случае с объектами контейнера типа const.
v объявлен как const по двум причинам. Во-первых, я знаю, что я не собираюсь изменять его содержимое, так что я хочу, чтобы компилятор выдал сообщение об ошибке, если это произойдет. Компилятор гораздо лучше меня в деле поиска таких вещей, особенно когда к такому присвоению приводит тонкая семантическая или синтаксическая ошибка. Во-вторых, я хочу показать пользователям этой функции, что я ничего не делаю с их контейнером, и const — это великолепный способ сделать это. Теперь я просто должен создать обобщенную версию, которая работает с различными типами символов.
Как и в рецепте 4.6, превращение join в общий шаблон функции очень просто. Все, что требуется сделать, — это изменить заголовок, параметризовав тип символов, как здесь:
template<typename T>
void join(const std::vector<std::basic_string<T> >& v, T c,
 std::basic_string<T>& s)
Но vector может оказаться не единственным возможным входом функции. Вам может потребоваться объединить строки в стиле С. Класс string C++ предпочтительнее строк в стиле С, так что если возникает такая задача, объединяйте их в C++ string. После этого всегда можно получить версию С, вызвав метод string c_str, который возвращает указатель const на завершающийся нулем массив символов.
Пример 4.14 предлагает общую версию join, которая объединяет массив символов в string. Так как новая общая версия параметризована по типу символов, она будет работать как для массивов узких, так и для массивов широких символов.
Пример 4.14 Объединение строк в стиле C
#include <string>
#include <iostream>
const static int MAGIC_NUMBER = 4;
template<typename T>
void join(T* arr[], size_t n, T c, std::basic_string<T>& s) {
 s.clear();
 for (int i = 0; i < n; ++i) {
  if (arr[i] != NULL)
   s += arr[i];
  if (i < n-1) s += c;
 }
}
int main() {
 std::wstring ws;
 wchar_t* arr[MAGIC_NUMBER];
 arr[0] = L"you";
 arr[1] = L"ate";
 arr[2] = L"my";
 arr[3] = L"breakfast";
 join(arr, MAGIC_NUMBER, L'/', ws);
}
4.9. Поиск в строках
Проблема
Требуется выполнить поиск в строке. Это может быть поиск одного символа, другой строки или одного из (или одного не из) неупорядоченного набора символов. И по каким-либо причинам требуется выполнять поиск в определенном порядке, например первое или последнее вхождение или первое или последнее вхождения относительно какого- либо положения в строке.
Решение
Используйте один из методов «find» из basic_string. Почти все методы поиска начинаются со слова «find», и их имена говорят достаточно о том, что они делают. Пример 4.15 показывает, как работают некоторые из этих методов поиска.
Пример 4.15. Поиск строк
#include <string>
#include <iostream>
int main() {
 std::string s = "Charles Darwin";
 std::cout << s.find("ar") << '\n'; // Поиск от
                                    // начала
 std::cout << s.rfind("ar") << "\n"; // Поиск с конца
 std::cout << s.find_first_of("swi") // Найти первое вхождение одного
  << '\n'; // из этих символов
 std::cout << s.find_first_not_of("Charles") // Найти первое,
  << '\n';                                   // что не входит в этот
                                             // набор
 std::cout << s.find_last_of("abg") << '\n'; // Найти первое вхождение любого
                                             // из этих символов,
                                             // начиная с конца
 std::cout << s.find_last_not_of("aDinrw") // Найти первое,
  << '\n';                                 // что не входит в этот
                                           // набор, начиная с конца
}
Все эти методы поиска обсуждаются более подробно в разделе «Обсуждение».
Обсуждение
Имеется шесть различных методов для поиска в строках, каждый из которых предоставляет четыре перегруженных варианта. Эти перегрузки позволяют использовать либо параметр basic_string, либо charT* (charT — это символьный тип). Каждый имеет параметр pos типа basic_string::size_type, который позволяет указать индекс, с которого следует начать поиск, и есть перегрузка с параметром n типа size_type, который позволяет выполнить поиск только n символов из набора.
Запомнить все эти методы довольно сложно, так что в табл. 4.2 дается краткая справка по каждому из них и их параметрам.
Табл. 4.2. Методы для поиска строк
Метод	Описание
size_type find(const basic_string& str, size_type pos = 0) const;	Возвращает индекс первого вхождения символа или подстроки начиная с начала или индекса, указанного в параметре pos.
size_type find (const charT* s, size_type pos, size_type n) const; size_type find (const charT* s, size_type pos = 0) const; size_type find(charT c, size_type pos = 0) const;	Если указан n, то при поиске используются первые n символов целевой строки
size_type rfind(...)	Находит первое вхождение символа или подстроки, начиная с конца строки и двигаясь к ее началу. Другими словами делает то же, что и find, но начинает поиск с конца строки
size_type find_first_of(...)	Находит первое вхождение любого символа из набора, переданного как basic_string или указатель на символы. Если указан n, то ищутся только первые n символов используемого набора
size_type find_last_of(...)	Находит последнее вхождение любого символа из набора, переданного как basic_string или указатель на символы. Если указан n, то ищутся только первые n символов используемого набора
size_type find_first_not_of(...)	Находит первое вхождение любого символа, не входящего в набор, переданный как basic_string или указатель на символы. Если указан n, то принимаются во внимание только первые n символов используемого набора
size_type find_last_not_of(...)	Находит последнее вхождение любого символа, не входящего в набор, переданный как basic_string или указатель на символы. Если указан n, то принимаются во внимание только первые n символов используемого набора
Все эти методы возвращают индекс вхождения искомого элемента, который имеет тип basic_string<T>::size_type. Если поиск заканчивается неудачей, возвращается basic_string<T>::npos, которое является специальным значением (обычно -1), указывающим, что поиск был неудачен. Даже хотя обычно это значение -1, сравнивать возвращаемое значение следует именно с npos, что обеспечит переносимость. Также это сделает код более понятным, так как сравнение с npos является явной проверкой, не содержащей магических чисел.
Имея такое многообразие алгоритмов поиска, у вас должна быть возможность найти то, что вы ищете, а если такой возможности нет, используйте свои собственные алгоритмы. Однако если basic_string не предоставляет то, что требуется, то перед написанием своего кода посмотрите на <algorithm>. Стандартные алгоритмы работают с последовательностями, используя итераторы и почти также часто — объекты функций. Для удобства и простоты переноса basic_string предоставляет итераторы, так что подключение итераторов string к стандартным алгоритмам является тривиальным. Скажем, вам требуется найти первое вхождение двух одинаковых символов подряд. Для поиска двух одинаковых расположенных рядом («расположенных рядом» означает, что их позиции отличаются на один шаг итератора, т.е. *iter == *(iter + 1)) символов в строке используйте шаблон функции adjacent_find.
std::string s = "There was a group named Kiss in the 70s";
std::string::iterator p =
 std::adjacent_find(s.begin(), s.end());
Результатом будет итератор, указывающий на первый из двух смежных элементов.
Если вам требуется написать собственный алгоритм работы со строками, не используйте basic_string так, как это делается со строками в стиле С, используя для доступа к элементам operator[]. Используйте существующие методы. Каждая функция поиска принимает параметр size_type, указывающий индекс, с которого должен начаться поиск. Последовательно используя функции поиска, можно пройти по всей строке. Рассмотрим пример 4.16, который подсчитывает число уникальных символов в строке.
Пример 4.16. Подсчет уникальных символов
#include <string>
#include <iostream>
template<typename T>
int countUnique(const std::basic_string<T>& s) {
 using std::basic_string;
 basic_string<T> chars;
 for (typename basic_string<T>::const_iterator p = s.begin();
  p != s.end(); ++p) {
  if (chars.find(*p) == basic.string<T>::npos)
  chars += *p;
 }
 return(chars.length());
}
int main() {
 std: :string s = "Abracadabra'";
 std::cout << countUnique(s) << '\n';
}
Функции поиска очень часто оказываются полезными. Когда требуется найти что- либо в строке типа string, они должны быть первым, что следует использовать.
4.10. Поиск n-го вхождения подстроки
Проблема
Имея источник source и шаблон pattern типа string, требуется найти n-е вхождение pattern в source.
Решение
Для поиска последовательных вхождений искомой подстроки используйте метод find. Пример 4.17 содержит простую функцию nthSubstr.
Пример 4.17. Поиск n-го вхождения подстроки
#include <string>
#include <iostream>
using namespace std;
int nthSubstr(int n, const strings s,
 const strings p) {
 string::size_type i = s.find(p); // Найти первое вхождение
 int j;
 for (j = 1; j < n && i != string::npos; ++j)
  i = s.find(p, i+1); // Найти следующее вхождение
 if (j == n) return(i);
 else return(-1);
}
int main() (
 string s = "the wind, the sea, the sky, the trees";
 string p = "the";
 cout << nthSubstr(1, s, p) << '\n';
 cout << nthSubstr(2, s, p) << '\n';
 cout << nthSubstr(5, s, p) << '\n';
}
Обсуждение
В функцию nthSubstr, имеющую вид, показанный в примере 4.17, можно внести пару улучшений. Во-первых, ее можно сделать общей, сделав из нее вместо обычной функции шаблон функции. Во-вторых, можно добавить параметр, позволяющий учитывать подстроки, которые перекрываются друг с другом. Под перекрывающимися подстроками я понимаю такие, у которых начало строки соответствует части конца такой же строки, как в строке «abracadabra», где последние четыре символа такие же, как и первые четыре. Это демонстрируется в примере 4.18.
Пример 4.18. Улучшенная версия nthSubstr
#include <string>
#include <iostream>
using namespace std;
template<typename T>
int nthSubstrg(int n, const basic_string<T>& s,
 const basic_string<T>& p, bool repeats = false) {
 string::size_type i = s.find(p);
 string::size_type adv = (repeats) ? 1 : p.length();
 int j;
 for (j = 1; j < n && i != basic_string<T>::npos; ++j)
  i = s.find(p, i+adv);
 if (j == n)
  return(i);
 else
  return(-1);
}
int main() {
 string s = AGATGCCATATATATACGATATCCTTA";
 string p = "ATAT";
 cout << p << " без повторений встречается в позиции "
  << nthSubstrg(3, s, p) << '\n';
 cout << p << " с повторениями встречается в позиции "
  << nthSubstrg(3, s, p, true) << '\n';
}
Вывод для строк, использованных в примере 4.18, выглядит так.
ATAT без повторений встречается в позиции 18
ATAT с повторениями встречается в позиции 11
Смотри также
Рецепт 4.9.
4.11. Удаление подстроки из строки
Проблема
Требуется удалить из строки подстроку.
Решение
Используйте методы basic_string find, erase и length:
std::string t = "Banana Republic";
std::string s = "nana";
std::string::size_type i = t.find(s);
if (i != std::string::npos) t.erase(i, s.length());
Этот код удаляет s.length() элементов, начиная с индекса, по которому find находит первое вхождение подстроки.
Обсуждение
На практике встречается огромное количество вариаций на тему поиска и удаления подстрок. Например, может потребоваться удалить все вхождения подстроки, а не одно из них. Или только последнее. Или седьмое. Каждый раз действия будут одни и те же: найдите индекс начала шаблона, который требуется удалить, затем вызовите erase для этого индекса и n последующих символов, где n — это длина строки шаблона. За описанием различных методов поиска подстрок обратитесь к рецепту 4.9.
Также велика вероятность, что вам потребуется сделать функцию удаления обобщенной, так чтобы ее можно было использовать с любыми типами символов. Пример 4.19 предлагает общую версию, которая удаляет все вхождения шаблона в строке.
Пример 4.19. Удаление всех подстрок из строки (обобщенная версия)
#include <string>
#include <iostream>
using namespace std;
template<typename T>
void removeSubstrs(basic_string<T>& s,
 const basic_string<T>& p) {
 basic_string<T>::size_type n = p.length();
 for (basic_string<T>::size_type i = s.find(p);
  i != basic_string<T>::npos; i = s.find(p))
  s.erase(i, n);
}
int main() {
 string s = "One fish, two fish, red fish, blue fish";
 string p = "fish";
 removeSubstrs(s, p);
 cout << s << '\n';
}
Здесь всю важную работу выполняет метод erase basic_string. В <string> он перегружен три раза. Использованная в примере 4.19 версия принимает индекс, с которого требуется начать удаление, и число удаляемых символов. Другая версия принимает в качестве аргументов начальный и конечный итераторы, а также есть версия, которая принимает единственный итератор и удаляет элемент, на который он указывает. Чтобы обеспечить оптимальную производительность при планировании удаления нескольких последовательных элементов, используйте первые две версии и не вызывайте s.erase(iter) несколько раз для удаления каждого из идущих подряд элементов. Другими словами, используйте методы, работающие с диапазонами, а не с одним элементом, особенно в случае тех методов, которые изменяют содержимое строки (или последовательности). В этом случае вы избежите дополнительных вызовов функции erase для каждого элемента последовательности и позволите реализации string более грамотно управлять ее содержимым.
4.12. Преобразование строки к нижнему или верхнему регистру
Проблема
Имеется строка, которую требуется преобразовать к нижнему или верхнему регистру.
Решение
Для преобразования символов к нижнему или верхнему регистру используйте функции toupper и tolower из заголовочного файла <cctype>. Пример 4.20 показывает, как использовать эти функции. Смотри также обсуждение альтернативных методик.
Пример 4.20. Преобразование регистра строки
#include <iostream>
#include <string>
#include <cctype>
#include <cwctype>
#include <stdexcept>
using namespace std;
void toUpper(basic_string<char>& s) {
 for (basic_string<char>::iterator p = s.begin();
 p != s.end(); ++p) {
  *p = toupper(*p); // toupper is for char
 }
}
void toUpper<basic_string<wchar_t>& s) {
 for (basic_string<wchar_t>::iterator p = s.begin();
  p != s.end(); ++p) {
  *p = towupper(*p); // towupper is for wchar_t
 }
}
void toLower(basic_string<char>& s) {
 for (basic_string<char>::iterator p = s.begin();
  p != s.end(); ++p) {
  *p = tolower(*p);
 }
}
void toLower(basic_string<wchar_t>& s) {
 for (basic_string<wchar_t>::iterator p = s.begin();
  p != s.end(); ++p) {
  *p = towlower(*p);
}
int main() {
 string s = "shazam";
 wstring ws = L"wham";
 toUpper(s); toUpper(ws);
 cout << "s = " << s << endl;
 wcout << "ws = " << ws << endl;
 toLower(s);
 toLower(ws);
 cout << "s = " << s << endl;
 wcout << "ws = " << ws << endl;
}
Этот код производит следующий вывод.
s = SHAZAM
ws = WHAM
s = shazam
ws = wham
Обсуждение
Кто-то может подумать, что стандартный класс string содержит метод, преобразующий всю строку к верхнему или нижнему регистру, но на самом деле это не так. Если требуется преобразовать строку символов к верхнему или нижнему регистру, это требуется делать самостоятельно.
Неудивительно, что имеется несколько способов преобразования регистра строки (и когда я говорю «строки», то имею в виду последовательность символов как узких, так и широких). Простейшим способом сделать это является использование одной из четырех функций преобразования символов toupper, towupper, tolower и towlower. Первая форма этих функций работает с узкими символами, а вторая форма (с дополнительной буквой w) является ее эквивалентом для широких символов.
Каждая из этих функций преобразует регистр символа, используя текущие правила локали для преобразования регистра. Верхний и нижний регистры зависят от символов, используемых в текущей локали. Некоторые символы не имеют верхнего или нижнего регистра, и в этом случае указанные функции возвращают переданный им символ. За дополнительной информацией о локалях обратитесь к главе 13. Возможности C++ по работе с различными локалями довольно сложны, и я не могут уделить им сейчас достаточно места.
Выполнение собственно преобразования символов просто. Рассмотрим функцию toUpper из примера 4.20.
void toUpper(basic_string<char>& s) {
 for (basic_string<char>::iterator p = s.begin();
 p != s.end(); ++p) {
  *p = toupper(*p);
 }
}
Строка, выделенная жирным, выполняет всю работу. Версия для широких символов почти идентична.
void toUpper(basic_string<wchar_t>& s) {
 for (basic_string<wchar_t>::iterator p = s.begin();
  p != s.end(); ++p) {
  *p = towupper(*p);
 }
}
Я перегрузил toupper для различных типов символов потому, что не существует общей функции toupper, преобразующей регистр символов (при условии, что не используются возможности заголовочного файла <locale>, который я описываю ниже). Две простые функции, как приведенные выше, выполняют всю работу.
Однако есть и другой способ выполнить эту задачу, и фактором, оказывающим влияние на выбор этого способа, является необходимость использовать явные локали. Следующие версии toUpper и toLower преобразуют регистр строк независимо от типа их символов, но при условии, что указанная локаль (а по умолчанию текущая) поддерживает преобразование регистра для данного типа символов.
template<typename С>
void toUpper2(basic_string<C>& s, const locale& loc = locale()) {
 typename basic_string<C>::iterator p;
 for (p = s.begin(); p ! = s.end(); ++p) {
  *p = use_facet<ctype<C> >(loc).toupper(*p);
 }
}
template<typename C>
void tolower2(basic_string<C>& s, const locale& loc = locale()) {
 typename basic_string<C>::iterator p;
 for (p = s.begin(), p ! = s.end(++p) {
  *p = use_facet<ctype<C> >(loc).tolower(*p);
 }
}
Строки, выделенные жирным, выполняют всю работу. Функционально они работают точно так же, как и функции для верхнего и нижнего регистров, использованные в примере 4.20, за исключением того, что они используют для этого возможности интернационализации из заголовочного файла <locale>. За более подробным обсуждением локалей и возможностей интернационализации обратитесь к главе 13.
4.13. Выполнение сравнения строк без учета регистра
Проблема
Имеются две строки и требуется узнать, не равны ли они, не учитывая регистр их символов. Например, «cat» не равно «dog», но «Cat» должна быть равна «cat», «CAT» или «caT».
Решение
Сравните строки, используя стандартный алгоритм equal (определенный в <algorithm>), и создайте свою собственную функцию сравнения, которая использует для сравнения версий с верхним регистром символов функцию toupper из <cctype> (или towupper из <cwctype> для широких символов). Пример 4.21 показывает обобщенное решение. Также он демонстрирует использование и гибкость STL. За полным объяснением обратитесь к обсуждению ниже.
Пример 4.21. Сравнение строк без учета регистра
1  #include <string>
2  #include <iostream>
3  #include <algorithm>
4  #include <cctype>
5  #include <cwctype>
6
7  using namespace std;
8
9  inline bool caseInsCharCompareN(char a, char b) {
10  return(toupper(a) == toupper(b));
11 }
12
13 inline bool caseInsCharCompareW(wchar_t a, wchar_t b) {
14  return(towupper(a) == towupper(b));
15 }
16
17 bool caseInsCompare(const string& s1, const string& s2) {
18  return((s1.size() == s2.size()) &&
19   equal(s1.begin(), s1.end(), s2.begin(), caseInsCharCompareN));
20 }
21
22 bool caseInsCompare(const wstring& s1, const wstring& s2) {
23  return((s1.size() == s2.size())
24  equal(s1.begin(), s1.end(), s2.begin(), caseInsCharCompareW));
25 }
26
27 int main() {
28  string s1 = "In the BEGINNING...";
29  string s2 = "In the beginning...";
30  wstring ws1 = L"The END";
31  wstring ws2 = L"the end";
32
33  if (caseInsCompare(s1, s2))
34   cout << "Equal!\n";
35
36  if (caseInsCompare(ws1, ws2))
37   cout << "Equal!\n";
38 }
Обсуждение
Критической частью сравнения строк без учета регистра является проверка равенства каждой соответствующей пары символов, так что давайте начнем обсуждение с него. Так как я в этом подходе использую стандартный алгоритм equal, но хочу использовать свой особый критерий сравнения, я должен создать отдельную функцию, выполняющую это сравнение.
Строки 9-15 примера 4.21 определяют функции, которые выполняют сравнение — caseInsCharCompareN и caseInsCharCompareW. Они для преобразования символов к верхнему регистру используют toupper и towupper, а затем сообщают, равны ли они.
После написания этих функций сравнения настает время использовать стандартный алгоритм, выполняющий применение этих функций сравнения к произвольной последовательности символов. Именно это делают функции caseInsCompare, определенные в строках 17-25 и использующие equal. Здесь сделано две перегрузки — по одной для каждого типа интересующих нас символов. Они обе делают одно и то же, но каждая использует для своего типа символов соответствующую функцию сравнения. Для этого примера я перегрузил две обычные функции, но этот же эффект может быть достигнут и с помощью шаблонов. Для пояснений обратитесь к врезке «Следует ли использовать шаблон?».
equal сравнивает две последовательности на равенство. Имеется две версии: одна использует operator==, а другая использует переданный ей функциональный объект двоичного предиката (т.е. такой, который принимает два аргумента и возвращает bool). В примере 4.21 caseInsCharCompareN и W — это функции двоичного предиката.
Но это не всё, что требуется сделать; также требуется сравнить размеры. Рассмотрим объявление equal.
template<typename InputIterator1, typename InputIterator2,
 typename BinaryPredicate>
bool equal(InputIterator1 first, InputIterator1 last1,
 InputIterator2 first2, BinaryPredicate pred);
Пусть n — это расстояние между first1 и last1, или, другими словами, длина первого диапазона. equal возвращает true, если первые n элементов обеих последовательностей равны. Это означает, что если есть две последовательности, где первые n элементов равны, но вторая содержит больше чем n элементов, то equal вернет true. Чтобы избежать такой ошибки требуется проверять размер.
Эту логику не обязательно инкапсулировать в функцию. Ваш или клиентский код может просто вызвать алгоритм напрямую, но проще запомнить и написать такое:
if (caseInsCompare(s1, s2)) { // они равны, делаем что-нибудь
чем такое:
if ((s1.size() == s2.size()) &&
std::equal(s1.begin(), s1.end(s2.begin(), caseInsCharCompare<char>)) {
 // они равны, делаем что-нибудь
когда требуется выполнить сравнение строк без учета регистра.
4.14. Выполнение поиска строк без учета регистра
Проблема
Требуется найти в строке подстроку, не учитывая разницу в регистре.
Решение
Используйте стандартные алгоритмы transform и search, определенные в <algorithm>, а также свои собственные функции сравнения символов, аналогичные уже показанным. Пример 4.22 показывает, как это делается.
Пример 4.22. Поиск строк без учета регистра
#include <string>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <cctype>
using namespace std;
inline bool caseInsCharCompSingle(char a. char b) {
 return(toupper(a) == b);
}
string::const_iterator caseInsFind(string& s, const string& p) {
 string tmp;
 transform(p.begin( ), p.end(), // Преобразуем шаблон
  back_inserter(tmp),           // к верхнему регистру
  toupper);
 return(search(s.begin(), s.end(), // Возвращаем итератор.
  tmp.begin(), tmp.end(),          // возвращаемый из
  caseInsCharCompSingle));         // search
}
int main() {
 string s = "row, row, row, your boat";
 string p = "YOUR";
 string::const_iterator ir = caseInsFind(s, p);
 if (it != s.end()) {
  cout << "Нашли!\n;
 }
}
Возвращая итератор, который указывает на элемент целевой строки, где начинается шаблонная строка, мы обеспечиваем совместимость с другими стандартными алгоритмами, так как большинство из них принимают в качестве аргумента итератор.
Обсуждение
Пример 4.22 демонстрирует обычный ход действий при работе со стандартными алгоритмами. Создайте функцию, которая выполняет работу, а затем подключите ее как объект функции к наиболее подходящему алгоритму. Здесь работу выполняет функция charInsCharCompSingle, но в отличие от примера 4.21 эта функция сравнения символов переводит к верхнему регистру только первый аргумент. Это сделано потому, что немного далее в caseInsFind я перед использованием строки шаблона в поиске преобразую ее к верхнему регистру полностью и тем самым избегаю многократного преобразования символов строки шаблона к верхнему регистру.
После того как функция сравнения будет готова, используйте для поиска стандартные алгоритмы transform и search. transform используется для преобразования к верхнему регистру всего шаблона (но не целевой строки). После этого используйте для поиска места вхождения подстроки search совместно с функцией сравнения.
Помните, что стандартные алгоритмы работают с последовательностями, а не со строками. Это общие алгоритмы, которые в основном (но не только) работают со стандартными контейнерами, но не делают никаких предположений о содержимом этих контейнеров. Все стандартные алгоритмы требуют передачи им функции сравнения (а в случае их отсутствия используют операторы по умолчанию), которые тем или иным способом сравнивают два элемента и возвращают bool, указывающий, дало ли сравнение истину или ложь.
В примере 4.22 есть одна вещь, которая выглядит странно. Вы видите, что caseInsCompare возвращает const_iterator, как в
string::const_iterator caseInsFind(const string& s,
 const string& p)
Что, если требуется изменить элемент, на который указывает возвращенный итератор? Тому есть причина. Она состоит в том, что константный итератор используется потому, что строки, которые передаются в caseInsFind, также передаются как const, и, следовательно, невозможно получить не-const итератор на const-строку. Если требуется итератор, который можно использовать для изменения строки, удалите const из параметров и измените объявление функции так, чтобы она возвращала string::iterator.
4.15. Преобразование между табуляциями и пробелами в текстовых файлах
Проблема
Имеется текстовый файл, содержащий табуляции или пробелы, и требуется преобразовать одни в другие. Например, может потребоваться заменить все табуляции на последовательности из трех пробелов или сделать наоборот и заменить все вхождения некоторого числа пробелов на табуляции.
Решение
Независимо от того, производится ли замена табуляций на пробелы или пробелов на табуляции, используйте классы ifstream и ofstream из <fstream>. В первом (более простом) случае прочтите данные по одному символу с помощью входного потока, изучите их и, если очередной символ — это табуляция, запишите в выходной поток некоторое количество пробелов. Пример 4.23 демонстрирует, как это делается.
Пример 4.23. Замена табуляций на пробелы
#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 if (!in || !out) return(EXIT_FAILURE);
 char c;
 while (in.get(c)) {
  if (c == '\t')
   out << " "; // 3 пробела
  else
   out << c;
 }
 out.close();
 if (out)
  return(EXIT_SUCCESS);
 else
  return(EXIT_FAILURE);
}
Если же требуется заменить пробелы на табуляции, обратитесь к примеру 4.24. Он содержит функцию spacesToTabs, которая читает из входного потока по одному символу, ища три последовательных пробела. Когда они найдены, она записывает в выходной поток табуляцию. Для всех остальных символов или меньшего количества пробелов в выходной поток записывается то, что было прочитано во входном.
Пример 4.24. Замена пробелов на табуляции
#include <iostream>
#include <istream>
#include <ostream>
#include <fstream>
#include <cstdlib>
using namespace std;
void spacesToTabs(istream& in, ostream& out, int spaceLimit) {
 int consecSpaces = 0;
 char c;
 while (in.get(c)) {
  if (c != ' ') {
   if (consecSpaces > 0) {
    for (int i = 0; i < consecSpaces; i++) {
     out.put(' ');
    }
    consecSpaces = 0;
   }
   out.put(c);
  } else {
   if (++consecSpaces == spaceLimit) {
    out.put('\t');
    consecSpaces = 0;
   }
  }
 }
}
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 if (!in || !out)
  return(EXIT_FAILURE);
 spacesToTabs(in, out, 3);
 out.сlose();
 if (out)
  return(EXIT_SUCCESS);
 else
  return(EXIT_FAILURE);
}
Обсуждение
Механизм обоих этих решений один и тот же, отличаются только алгоритмы. Символы читаются из входного потока с помощью get, а в выходной поток помещаются с помощью put. Логика, выполняющая преобразования, помещается между этими двумя функциями.
Вы, вероятно, заметили в примере 4.24, что в функции main in и out объявлены как переменные типов ifstream и ofstream соответственно и что параметры spacesToTabs — это istream и ostream. Это сделано для того, чтобы позволить spacesToTabs работать с любыми типами входных и выходных потоков (ну, не любыми типами потоков, а теми, которые наследуются от basic_istream или basic_ostream), а не только с файловыми потоками. Например, текст, который требуется переформатировать, может находиться в строковом потоке (istringstream и ostringstream из <sstream>). В этом случае сделайте что-то похожее на следующее.
istringstream istr;
ostringstream ostr;
// заполняем istr текстом...
spacesToTabs(istr, ostr);
Как и в случае со строками, потоки — это на самом деле шаблоны классов, параметризованные по типу символов, с которыми работает поток. Например, ifstream — это typedef для basic_ifstream<char>, a wifstream — это typedef для basic_ifstream<wchar_t>. Таким образом, если требуется, чтобы spacesToTabs из примеров 4.23 или 4.24 работала с потоками любых символов, то вместо typedef используйте эти шаблоны классов.
template<typename T>
void spacesToTabs(std::basic_istream<T>& in,
 std::basic_ostream<T>& out, int spaceLimit) { //...
4.16. Перенос строк в текстовом файле
Проблема
Требуется сделать перенос текста файла после определенного количества символов. Например, если требуется сделать перенос текста после 72 символов, то после каждого 72 символа файла требуется вставить символ новой строки. Если файл содержит текст, читаемый человеком, то, вероятно, потребуется избежать разделения слов.
Решение
Напишите функцию, которая использует входной и выходной потоки, читает символы с помощью istream::get(char), выполняет какие-либо действия и записывает символы с помощью ostream::put(char). Пример 4.25 показывает, как это делается с файлом, который содержит обычный текст, с учетом сохранения целостности слов.
Пример 4.25. Перенос текста
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cctype>
#include <functional>
using namespace std;
void textWrap(istream& in, ostream& out, size_t width) {
 string tmp;
 char cur = '\0';
 char last = '\0';
 size_t i = 0;
 while (in.get(cur)) {
  if (++i == width) {
   ltrimws(tmp);       // ltrim как в рецепте
   out << '\n' << tmp; // 4.1
   i = tmp.length();
   tmp.clear();
  } else if (isspace(cur) && // Это конец
   !isspace(last)) {         // слова
   out << tmp;
   tmp.clear();
  }
  tmp += cur;
  last = cur;
 }
}
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 int w = 72;
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 if (!in || !out)
  return(EXIT_FAILURE);
 if (argc == 4) w = atoi(argv[3]);
 textWrap(in, out, w);
 out.close();
 if (out)
  return(EXIT_SUCCESS);
 else
  return(EXIT_FAILURE);
}
Обсуждение
textWrap читает по одному символы из входного потока. Каждый символ добавляется к временной строке tmp до тех пор, пока не будет достигнут конец слов или максимальная длина строки. Если достигнут конец слова, а максимальная длина строки еще не достигнута, то временная строка записывается в выходной поток. В противном случае, если максимальная длина строки была превышена, в выходной поток записывается новая строка, пробел в начале временной строки удаляется, и строка записывается в выходной поток. Таким образом, textWrap записывает в выходной поток столько, сколько можно, но не превышая максимальной длины строки. Вместо разделения слов она переносит все слово на новую строку.
Пример 4.25 использует потоки почти так же, как и рецепт 4.15. За дополнительной информацией о потоках и их использовании обратитесь к этому рецепту.
Смотри также
Рецепт 4.15.
4.17. Подсчет числа символов, слов и строк в текстовом файле
Проблема
Требуется подсчитать число символов, слов и строк — или каких-либо других элементов текста — в текстовом файле.
Решение
Для чтения символов по одному используйте входной поток и по мере чтения символов, слов и строк увеличивайте счетчики. Пример 4.26 содержит функцию countStuff, которая именно это и делает.
Пример 4.26. Подсчет статистики по текстовому файлу
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cctype>
using namespace std;
void countStuff(istream& in,
 int& chars, int& words, int& lines) {
 char cur = '\0';
 char last = '\0';
 chars = words = lines = 0;
 while (in.get(cur)) {
  if (cur == '\n' ||
   (cur == '\f' && last == '\r'))
   lines++;
  else chars++;
  if (!std::isalnum(cur) && // Это конец
   std::isalnum(last))      // слова
   words++;
  last = cur;
 }
 if (chars > 0) {         // Изменить значения слов
  if (std::isalnum(last)) // и строк для специального
   words++;               // случая
  lines++;
 }
}
int main(int argc, char** argv) {
 if (argc < 2)
  return(EXIT _FAILURE);
 ifstream in(argv[1]);
 if (!in)
  exit(EXIT_FAILURE);
 int c, w, l;
 countStuff(in, c, w, l);
 cout << "символов: " << c << '\n';
 cout << "слов: " << w << '\n';
 cout << "строк: " << l << '\n';
}
Обсуждение
Этот алгоритм очень прост. С символами все просто: увеличивайте счетчик символов при каждом вызове get для входного потока. Со строками все не намного сложнее, так как способ представления концов строк зависит от операционной системы. К счастью, обычно это либо символ новой строки (\n), либо последовательность из символов возврата каретки и перевода строки (\r\n). Отслеживая текущий и предыдущий символы, можно легко обнаружить вхождения этой последовательности. Со словами все проще или сложнее, в зависимости от определения того, что такое «слово».
Для примера 4.26 я предположил, что слово это неразрывная последовательность буквенно-цифровых символов. В процессе просмотра каждого символа входного потока при обнаружении неалфавитно-цифрового символа я проверяю предыдущий символ — был ли он буквенно-цифровым или нет. Если был то это конец слова, и я увеличиваю счетчик слов. Определить, является ли символ буквенно-цифровым, можно с помощью функции isalnum из <cctype>. Но это еще не все — с помощью аналогичных функций можно проверять символы на целый ряд других качеств. Функции, которые предназначены для проверки характеристик символов, приведены в табл. 4.3. Для широких символов используйте функции с такими же именами, но с буквой «w» после «is», например iswSpace. Версии для широких символов объявлены в заголовочном файле <cwctype>.
Табл. 4.3. Функции для проверки символов из <cctype> и <cwctype>
Функция	Описание
isalpha iswalpha	Буквенные символы: a-z, A-Z (верхний или нижний регистр)
isupper iswupper	Буквенные символы верхнего регистра: A-Z
islower iswlower	Буквенные символы нижнего регистра: a-z
isdigit iswdigit	Числовые символы: 0-9
isxdigit iswxdigit	Шестнадцатеричные числовые символы: 0-9, a-f, A-F
isspace iswspace	Пробельные символы. ' ', \n, \t, \v, \r, \l
iscntrl iswcntrl	Управляющие символы: ASCII 0-31 и 127
ispunct iswpunct	Символы пунктуации, не принадлежащие предыдущим группам
isalnum iswalnum	isalpha или isdigit равны true
isprint iswprint	Печатаемые символы ASCII
isgraph iswgraph	isalpha, isdigit или ispunct равны true
После того как были прочтены все символы и достигнут конец файла, требуется сделать еще кое-что. Во-первых, строго говоря, цикл подсчитывает только переносы строк, а не сами строки. Следовательно, это значение будет на одну меньше, чем реальное число строк. Чтобы решить эту проблему, я, если файл содержит ненулевое число символов, просто увеличиваю счетчик строк на единицу. Во-вторых, если поток заканчивается на буквенно-цифровой символ, то поиск конца последнего слова не сработает, так как не будет следующего символа. Чтобы учесть это, я проверяю, является ли последний символ потока буквенно-цифровым (также только в том случае, если в файле содержится ненулевое число символов), и увеличиваю счетчик слов на единицу.
Методика использования потоков в примере 4.26 почти идентична той, которая описана в рецептах 4.14 и 4.15, но несколько проще, так как он только исследует файл, не внося никаких изменений.
Смотри также
Рецепты 4.14 и 4.15.
4.18. Подсчет вхождений каждого слова в текстовом файле
Проблема
Требуется подсчитать количество вхождений в текстовом файле каждого слова.
Решение
Для чтения из текстового файла непрерывных фрагментов текста используйте operator>>, определенный в <string>, а для сохранения каждого слова и его частоты в файле используйте map, определенный в <map>. Пример 4.27 демонстрирует, как это делается.
Пример 4.27. Подсчет частоты слов
1  #include <iostream>
2  #include <fstream>
3  #include <map>
4  #include <string>
5
6  typedef std::map<std::string, int> StrIntMap;
7
8  void countWords(std::istream& in, StrIntMap& words) {
9
10  std::string s;
11
12  while (in >> s) {
13   ++words[s];
14  }
15 }
16
17 int main(int argc, char** argv) {
18
19  if (argc < 2)
20   return(EXIT_FAILURE);
21
22  std::ifstream in(argv[1]);
23
24  if (!in)
25   exit(EXIT_FAILURE);
26
27  StrIntMap w;
28  countWords(in, w);
29
30  for (StrIntMap::iterator p = w.begin();
31   p != w.end(); ++p) {
32   std::cout << p->first << " присутствует "
33    << p->second << " раз.\n";
34  }
35 }
Обсуждение
Пример 4.27 кажется вполне простым, но в нем делается больше, чем кажется. Большая часть тонкостей связана с map, так что вначале давайте обсудим его.
Если вы не знакомы с map, то вам стоит узнать про него, map — это шаблон класса контейнера, который является частью STL. Он хранит пары ключ-значение в порядке, определяемом std::less или вашей собственной функцией сравнения. Типы ключей и значений, которые можно хранить в нем, зависят только от вашего воображения. В этом примере мы просто сохраняем string и int.
В строке 6 я для упрощения читаемости кода использовал typedef.
typedef map<string, int> StrIntMap;
Таким образом, StrIntMap — это map, который хранит пары string/int. Каждая string — это уникальное слово именно по этой причине я использую ее как ключ, — которое было прочитано из входного потока, а связанное с ней int — это число раз, которое это слово встретилось. Все, что осталось, — это прочитать все слова по одному, добавить их в map, если их там еще нет, и увеличить значение счетчика, если они там уже есть.
Это делает countWords. Основная логика кратка.
while (in >> s) {
 ++words[s];
}
operator>> читает из левого операнда (istream) непрерывные отрезки, не содержащие пробелов, и помещает их в правый операнд (string). После прочтения слова все, что требуется сделать, — это обновить статистику в map, и это делается в следующей строке.
++words[s];
map определяет operator[], позволяющий получить значение данного ключа (на самом деле он возвращает ссылку на само значение), так что для его инкремента просто инкрементируется значение, индексируемое с помощью заданного ключа. Но здесь могут возникнуть небольшие осложнения. Что, если ключа в map еще нет? Разве мы не попытаемся увеличить несуществующий элемент, и не обрушится ли программа, как в случае с обычным массивом? Нет, map определяет operator[] не так, как другие контейнеры STL или обычные массивы.
В map operator[] делает две вещи: если ключ еще не существует, он создает значение, используя конструктор типа значения по умолчанию, и добавляет в map эту новую пару ключ/значение, а если ключ уже существует, то никаких изменений не вносится. В обоих случаях возвращается ссылка на значение, определяемое ключом, даже если это значение было только что создано конструктором по умолчанию. Это удобная возможность (если вы знаете о ее существовании), так как он устраняет необходимость проверки в клиентском коде существования ключа перед его добавлением.
Теперь посмотрите на строки 32 и 33. Итератор указывает на члены, которые называются first и second — что это такое? map обманывает вас, используя для хранения пар имя/значение другой шаблон класса: шаблон класса pair, определенный в <utility> (уже включенный в <map>). При переборе элементов, хранящихся в map, вы получите ссылки на объекты pair. Работа с pair проста. Первый элемент пары хранится в элементе first, а второй хранится, естественно, в second.
В примере 4.27 я для чтения из входного потока непрерывных фрагментов текста использую operator>>, что отличается от некоторых других примеров. Я делаю это для демонстрации того, как это делается, но вам почти наверняка потребуется изменить его поведение в зависимости от определения «слова» текстового файла. Например, рассмотрим фрагмент вывода, генерируемого примером 4.27.
with присутствует 5 раз.
work присутствует 3 раз.
workers присутствует 3 раз.
workers, присутствует 1 раз.
years присутствует 2 раз.
years, присутствует 1 раз.
Обратите внимание, что точки в конце слов рассматриваются как части слов. Скорее всего, вам потребуется с помощью функций проверки символов из <cctype> и <cwctype> изменить определение слова так, чтобы оно означало только буквенно-цифровые символы, как это сделано в рецепте 4.17.
Смотри также
Рецепт 4.17 и табл. 4.3.
4.19. Добавление полей в текстовый файл
Проблема
Имеется текстовый файл, и в нем требуется сделать поля. Другими словами, требуется сдвинуть обе стороны каждой строки, содержащей какие-либо символы, так, чтобы длина всех строк стала одинаковой.
Решение
Пример 4.28 показывает, как добавить в файл поля с помощью потоков, string и шаблона функции getline.
Пример 4.28. Добавление полей в текстовый файл
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
using namespace std;
const static char PAD_CHAR = '.';
// addMargins принимает два потока и два числа. Потоки используются для
// ввода и вывода. Первое из двух чисел представляет
// ширину левого поля (т.е. число пробелов, вставляемых в
// начале каждой строки файла). Второе число представляет
// общую ширину строки.
void addMargins(istream& in, ostream& out,
 int left, int right) {
 string tmp;
 while (!in.eof()) {
  getline(in, tmp, '\n'); // getline определена
                          // в <string>
  tmp.insert(tmp.begin(), left, PAD_CHAR);
  rpad(tmp, right, PAD_CHAR); // rpad из рецепта
                              // 4.2
  out << tmp << '\n';
 }
}
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 if (!in || !out)
  return(EXIT_FAILURE);
 int left = 8;
 int right = 72;
 if (argc == 5) {
  left = atoi(argv[3]);
  right = atoi(argv[4]);
 }
 addMargins(in, out, left, right);
 out.close();
 if (out)
  return(EXIT_SUCCESS);
 else
  return(EXIT_FAILURE);
}
Этот пример делает несколько предположений о формате входного текста, так что внимательно прочтите следующий раздел.
Обсуждение
addMargins предполагает, что ввод выглядит примерно так.
The data is still inconclusive. But the weakness
in job creation and the apparent weakness in
high-paying jobs may be opposite sides of a coin.
Companies still seem cautious, relying on
temporary workers and anxious about rising health
care costs associated with full-time workers
Этот текст содержит переносы в позиции 50 символов (см. рецепт 4.16) и выровнен по левому краю (см. рецепт 4.20). addMargins также предполагает, что требуется, чтобы вывод выглядел подобно следующему, который использует для обозначения полей вместо пробелов точки.
.......The data is still inconclusive. But the weakness..............
.......in job creation and the apparent weakness in..................
.......high-paying jobs may be opposite sides of a coin..............
.......Companies still seem cautious, relying on.....................
.......temporary workers and anxious about rising health.............
.......care costs associated with full-time workers..................
По умолчанию левое поле содержит восемь символов, а общая длина строки составляет 72 символа. Конечно, если известно, что входной текст будет всегда выровнен по левому или правому краю, то можно просто дополнить оба конца каждой строки таким количеством символов, которое требуется. В любом случае логика очень проста. Многие методики, используемые в этом рецепте, уже описывались (потоки, дополнение string), так что я не буду здесь на них останавливаться. Единственная новая функция здесь — это getline.
Если требуется прочитать сразу целую строку текста или, более точно, прочитать текст до определенного разделителя, используйте шаблон функции getline, определенный в <string>, как это сделано в примере 4.28.
getline(in, tmp, '\n');
getline читает символы из входного потока и добавляет их в tmp до тех пор, пока не встретится разделитель '\n', который в tmp не добавляется. basic_istream содержит метод с таким же именем, но с другим поведением. Он сохраняет свой вывод в символьном буфере, а не в string. В данном случае я решил использовать преимущества метода из string, так как мне не хотелось читать строку в символьный буфер, а затем копировать ее в string. Таким образом, я использовал getline в версии string.
Смотри также
Рецепты 4.16 и 4.20.
4.20. Выравнивание текста в текстовом файле
Проблема
Требуется выровнять текст по правому или левому краю.
Решение
Используйте потоки и стандартные флаги форматирования потоков right и left, являющиеся частью ios_base, определенного в <ios>. Пример 4.29 показывает, как они работают.
Пример 4.29. Выравнивание текста
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
using namespace std;
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 int w = 72;
 if (argc == 4)
  w = atoi(argv[3]);
 string tmp;
 out.setf(ios_base::right); // Указать потоку на
                            // выравнивание по правому краю
 while (!in.eof()) {
  out.width(w);           // Сбросить ширину после
  getline(in, tmp, "\n"); // каждой записи
  out << tmp << '\n';
 }
 out.close();
}
Этот пример принимает три аргумента: входной файл, выходной файл и ширину выровненного по правому краю текста. Входной файл может иметь следующий вид.
With automatic download of Microsoft's (Nasdaq:
MSFT) enormous SP2 security patch to the Windows
XP operating system set to begin the industry
still waits to understand its ramifications. Home
users that have their preferences set to receive
operating system updates as they are made
available by Microsoft may be surprised to learn
that some of the software they already run on
their systems could be disabled by SP2 or may run
very differently.
Вывод будет иметь следующий вид.
   With automatic download of Microsoft's (Nasdaq:
  MSFT) enormous SP2 security patch to the Windows
     XP operating system set to begin the industry
 still waits to understand its ramifications. Home
  users that have their preferences set to receive
         operating system updates as they are made
  available by Microsoft may be surprised to learn
     that some of the software they already run on
 their systems could be disabled by SP2 or may run
                                 very differently.
Второй пример текста выровнен по правому краю и имеет в ширину 50 символов.
Обсуждение
Шаблон класса ios_base содержит большое количество флагов форматирования числовых и текстовых данных, читаемых из потоков или записываемых в них. Два флага, управляющих выравниванием текста, — это right и left. Они являются static const-членами ios_base и имеют тип fmtflags (который зависит от реализации). Все это хозяйство определено в <ios>.
Чтобы установить флаги форматирования, используйте ios_base::setf. Она объединяет переданные в нее и уже установленные ранее флаги потока с помощью операции OR (ИЛИ). Например, эта строка включает выравнивание по правому краю:
out.setf(std::ios_base::right);
Но выравнивание по правому краю не имеет смысла без установки правого поля, по которому требуется выравнивать. Чтобы установить это поле, используйте ios_base::width, как здесь.
out.width(w);
Этот код устанавливает ширину выходного поля для передаваемого значения, что означает, что при выравнивании текста по правому краю начало строки будет дополняться пробелами так, чтобы ее правый край достиг правого поля. Заметьте, что ширину я задаю в цикле, в то время как флаг right я выставляю перед ним. Это требуется делать потому, что после каждой записи в поток ширина сбрасывается в ноль. Флаги форматирования после записи не сбрасываются, так что их можно указать только один раз.
Однако всегда следует быть аккуратным и точным, так что при использовании флагов форматирования требуется сделать еще одну вещь: убрать их за собой.
Часто потоки, в которые производится запись, не принадлежат записывающему коду, особенно при написании библиотеки или API общего назначения. Например, если написать функцию журналирования, которая принимает выходной поток и string, изменяет string, устанавливает флаги форматирования и записывает string в поток, то могут возникнуть нежелательные побочные эффекты. После того как клиентский код вызывает эту функцию журналирования, его поток содержит другой набор флагов форматирования. Решением является копирование старых флагов и восстановление их по окончании работы.
Например, функция журналирования ошибок может выглядеть вот так.
using namespace std;
void logFrror(ostream& out, const string& s) {
 string tmp(s);
 tmp.insert(0, "ERROR: ");
 ios_base::fmtflags figs =  // setf возвращает
  out.setf(ios_base::left); // флаги, которые уже
                            // были установлены
 out.width(72);
 out << tmp << '\n';
 out.flags(flgs); // вернуть оригинальные
}
Метод flags работает аналогично setf, но не объединяет с помощью OR переданные ему флаги с уже установленными, а заменяет их. Таким образом, при вызове flags и передаче ему оригинальных флагов форматирования можно быть уверенным, что флаги будут восстановлены.
4.21. Замена в текстовом файле последовательностей пробелов на один пробел
Проблема
Имеется текстовый файл с последовательностями пробелов различной длины и требуется заменить каждое вхождение такой последовательности на единственный пробел.
Решение
Для чтения непрерывной последовательности непробельных символов из потока в строку используйте шаблон функции operator>>, определенный в <string>. Затем используйте его двойника operator<<, который записывает каждую из этих последовательностей в выходной поток, и после каждой из них добавьте по одному пробелу. Пример 4.30 дает краткий пример этой методики.
Пример 4 30. Замена последовательностей пробелов на один пробел
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main(int argc, char** argv) {
 if (argc < 3)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 ofstream out(argv[2]);
 if (!in || !out)
  return(EXIT_FAILURE);
 string tmp;
 in >> tmp;  // Прочитать первое слове
 out << tmp; // Записать его в выходной поток
 while (in >> tmp) { // operator>> игнорирует пробелы, так что все, что
  out << ' ';        // я должен сделать, - это записать пробел и каждую
  out << tmp;        // последовательность «непробелов»
 }
 out.close();
}
Обсуждение
Это просто сделать, если использовать потоки и строки. Даже если требуется реализовать другой вариант этого — например, чтобы сохранить переходы на новую строку, — эта методика будет работать. Если требуется добавить переходы на новые строки, для их расстановки в нужных местах используйте решение, представленное в рецепте 4.16.
Смотри также
Рецепты 4.15 и 4.16.
4.22. Автозамена текста при изменении буфера
Проблема
Имеется класс, который представляет некий тип текстового поля или документа, и по мере добавления в него текста требуется автоматически корректировать неправильно написанные слова, как это делает функция Autocorrect (Автозамена) в Microsoft Word.
Решение
Это можно реализовать в относительно небольшом коде, если использовать map, который определен в <map>, string и различные возможности стандартной библиотеки. Пример 4.31 показывает, как это делается.
Пример 4.31. Автозамена текста
#include <iostream>
#include <string>
#include <cctype>
#include <map>
using namespace std;
typedef map<string, string> StrStrMap;
// Класс для хранения текстовых полей
class TextAutoField {
public:
 TextAutoField(StrStrMap* const p) : pDict_(p) {}
 ~TextAutoField() {}
 void append(char c);
 void getText(string& s) {s = buf_;}
private:
 TextAutoField();
 string buf_;
 StrStrMap* const pDict ;
};
// Добавление с автозаменой
void TextAutoField::append(char c) {
 if ((isspace(c) || ispunct(c)) &&     // Выполнять автоза-
  buf_.length() > 0 &&                 // мену, только когда вводятся
  !isspace(buf_[buf_.length() - 1])) { // ws или punct
  string::size_type i = buf_.find_last_of(" \f\n\r\t\v");
  i = (i == string::npos) ? 0 : ++i;
  string tmp = buf_.substr(i, buf_.length() - i);
  StrStrMap::const_iterator p = DDict_->find(tmp);
  if (p != pDict_->end()) {          // Нашли, так что стираем
   buf_.erase(i, buf_.length() - i); // и заменяем
   buf_ += p->second;
  }
 }
 buf_ += с;
}
int main() {
 // Создаем map
 StrStrMap dict;
 TextAutoField txt(&dict);
 dict["taht"] = "that";
 dict["right"] = "wrong";
 dict["bug"] = "feature";
 string tmp = "He's right, taht's a bug.";
 cout << "Оригинальная версия: " << tmp << '\n';
 for (string::iterator p = tmp.begin(); p != tmp.end(); ++p) {
  txt.append(*p);
 }
 txt.getText(tmp);
 cout << "Исправленная версия. " << tmp << '\n';
}
Вывод примера 3.2 таков.
Оригинальная версия: He's right, taht's a bug.
Исправленная версия: He's wrong, that's a feature.
Обсуждение
string и map удобны в ситуациях, когда требуется отслеживать ассоциации string. TextAutoField — это простой текстовый буфер, использующий string для хранения данных. Интересной TextAutoField делает ее метод append, который «слушает» пробелы или знаки пунктуации и при их появлении выполняет обработку.
Чтобы сделать автозамену работающей, требуется две вещи. Во-первых, требуется некий словарь, который содержит неправильно написанные варианты слов и связанные с ними правильные написания, map хранит пары ключ/значение, где ключ и значение могут быть любого типа, так что он является идеальным кандидатом на эту роль. В начале примера 4.31 имеется typedef для пар string:
typedef map<string, string> StrStrMap;
За более подробным описанием map обратитесь к рецепту 4.18. TextAutoField хранит указатель на map, так как, вероятнее всего, для всех полей потребуется только один общий словарь.
Предполагая, что клиентский код помещает в map что-то осмысленное, append просто должен периодически проверять trap. В примере 4.31 append ждет появления пробела или знака пунктуации. Для проверки на пробел можно использовать isspace, а для поиска знаков пунктуации можно использовать ispunct. Обе эти функции для узких символов определены в <cctype> (см. табл. 4.3).
Если вы не знакомы с использованием итераторов и методов поиска в контейнерах STL, то код, который выполняет проверку, требует некоторых пояснений, string tmp содержит последний фрагмент текста, который был добавлен в TextAutoField. Чтобы увидеть, был ли он написан с ошибками, поищите его в словаре вот так.
StrStrMap::iterator p = pDict->find(tmp);
if (p != pDict_->end()) {
Здесь важно то, что map::find в случае успеха поиска возвращает итератор, который указывает на пару, содержащую соответствующий ключ. Если поиск не дал результатов, то возвращается итератор, указывающий на область памяти после последнего элемента map, на который указывает map::end (именно так работают контейнеры STL, поддерживающие find). Если слово в map найдено, стираем из буфера старое слово и заменяем его правильной версией.
buf_.erase(i, buf_.length() - i);
buf_ += p->second;
Добавьте символ, который инициировал весь процесс (либо пробел, либо знак пунктуации), и все.
Смотри также
Рецепты 4.17, 4.18 и табл. 4.3.
4.23. Чтение текстового файла с разделителями-запятыми
Проблема
Требуется прочитать текстовый файл, чье содержимое разделено запятыми и новыми строками (или любой другой парой разделителей). Записи разделяются одним символом, а поля записи разделяются другим символом. Например, текстовый файл с разделителями-запятыми, содержащий информацию о сотрудниках, может выглядеть вот так.
Smith, Bill, 5/1/2002, Active
Stanford, John, 4/5/1999, Inactive
Такие файлы обычно временно хранят наборы данных, экспортируемые из электронных таблиц, баз данных или других форматов файлов.
Решение
Пример 4.32 демонстрирует, как это делается. Если читать текст в string непрерывными кусками с помощью getline (шаблон функции определен в <string>), то для анализа текста и создания структуры данных можно использовать функцию split, которая была представлена в рецепте 4.6.
Пример 4.32. Чтение файла с разделителями
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;
void split(const string& s, char c, vector<string>& v) {
 int i = 0;
 int j = s.find(c);
 while (j >= 0) {
  v.push_back(s.substr(i, j-i));
  i = ++j;
  j = s.find(c, j);
  if (j < 0) {
   v.push_back(s.substr(i, s.length()));
  }
 }
}
void loadCSV(istream& in, vector<vector<string>*>& data) {
 vector<string>* p = NULL;
 string tmp;
 while (!in.eof()) {
  getline(in, tmp, '\n'); // Получить следующую строку
  p = new vector<string>();
  split(tmp, '.', *p); // Использовать split из
                       // Рецепта 4.7
  data.push_back(p);
  cout << tmp << '\n';
  tmp.clear();
 }
}
int main(int argc, char** argv) {
 if (argc < 2)
  return(EXIT_FAILURE);
 ifstream in(argv[1]);
 if (!in)
  return(EXIT_FAILURE);
 vector<vector<string>*> data;
 loadCSV(in, data);
 // Выполнить с данными какие-либо действия...
 for (vector<vector<string>*>::iterator p = data.begin();
  p != data end(); ++p) {
  delete *p; // Убедитесь, что p
 }           // разыменован!
}
Обсуждение
В примере 4.32 почти нет ничего, что еще не было бы описано, getline обсуждается в рецепте 4.19, a vector — в рецепте 4.3. Единственный фрагмент, заслуживающий упоминания, — это выделение памяти.
loadCSV создает новый vector для каждой прочитанной строки данных и сохраняет его в другом vector, состоящем из указателей на vector. Так как память для каждого из этих векторов выделяется из кучи, кто-то должен удалить ее, и этот кто-то — это вы (а не реализация vector).
vector ничего не знает о том, содержит ли он значение или указатель на значение или что-либо еще. Все, что он знает, — это то, что при его удалении он должен вызвать деструктор для каждого содержащегося в нем элемента. Если vector хранит объекты, то все нормально, объект будет удален правильно. Но если vector содержит указатели, то удалены будут указатели, а не объекты, на которые они указывают.
Есть два способа гарантировать освобождение памяти. Первый заключается в том, что сделано в примере 4.32 вручную, как здесь.
for (vector<vector<string>*>::iterator p = data.begin();
 p != data.end(); ++p) {
 delete *p;
}
Либо можно использовать указатель со счетчиком ссылок, такой как smart_ptr из проекта Boost, который станет частью будущего стандарта C++0x. Но реализация этого нетривиальна, так что я рекомендую почитать, что такое smart_ptr и как он работает. Для получения дополнительной информации по Boost посетите его домашнюю страницу по адресу www.boost.org.
4.24. Использование регулярных выражений для разделения строки
Проблема
Требуется разделить строку на лексемы, но необходимо выполнить более сложный поиск, чем показано в рецепте 4.7. Например, могут потребоваться лексемы, разделенные более чем одним символом или имеющие несколько различных форм. Это часто приводит к большому коду и путанице среди пользователей вашего класса или функции.
Решение
Используйте шаблон класса regex Boost. regex позволяет использовать для строк и текстовых данных регулярные выражения. Пример 4.33 показывает, как использовать regex для разделения строк.
Пример 4.33. Использование регулярных выражений Boost
#include <iostream>
#include <string>
#include <boost/regex.hpp>
int main() {
 std::string s = "who,lives-in-a,pineapple under the sea?";
 boost::regex re(',|:|-|\\s+"); // Создаем регулярное выражение
 boost::sregex_token_iterator   // Создаем итератор, используя
 p(s.begin(), s.end(), re, -1), // последовательность и это выражение
  boost::sregex_token_iterator end; // Создаем маркер
                                    // «конец-рег-выражения»
 while (p != end)
  std::cout << *p++ << '\n';
}
Обсуждение
Пример 4.33 показывает, как использовать regex для перебора соответствий регулярному выражению. Следующая строка создает регулярное выражение.
boost::regex re(' ,|:| -|\\s+");
Она гласит, что каждое соответствие регулярному выражению — это либо запятая, либо двоеточие, либо тире, либо один или несколько пробелов. Символ канала — это логический оператор OR, используемый для объединения разделителей. Следующие две строки создают итератор.
boost::sregex_token_iterator
p(s.begin(), s.end(), re, -1);
boost::sregex_token_iterator end;
Итератор p создается с помощью регулярного выражения и входной строки. После его создания p можно рассматривать как итератор для последовательности из стандартной библиотеки, sregex_token_iterator создается без аргументов и является специальным значением, представляющим конец последовательности лексем регулярного выражения, и, следовательно, может использоваться для проверки достижения конца.
Глава 5
Даты и время
5.0. Введение
Даты и время являются удивительно обширным и сложным вопросом. Как отражение этого факта, стандартная библиотека C++ не предоставляет подходящего типа данных для дат. C++ наследует структуры и функции для работы с датами и временем, а также пару функций ввода и вывода дат/времени с учетом локализации, от С. Однако решение можно найти в библиотеке date_time Library из состава Boost, написанной Джеффом Гарландом (Jeff Garland), которая является, по всей видимости, наиболее полной и всеобъемлющей из имеющихся библиотек для работы с датами и временем в С++. В некоторых рецептах я буду использовать именно ее. Сообщество C++ ожидает, что будущие расширения стандартной библиотеки в части работы с датами/временем будут основаны на библиотеке Boost date_time.
Библиотека Boost date_time включает две отдельные системы для работы с датами и временем: одна для работы со временем, и вторая для работы с датами, относящимися к григорианскому календарю. Рецепты описывают обе эти системы.
За дополнительной информацией о датах и времени, в частности об их чтении и записи, обратитесь к главе 13.
5.1. Получение текущей даты и времени
Проблема
Требуется получить от пользователя компьютера текущую дату и время — либо в формате локального времени, либо в формате универсального глобального времени (Coordinated Universal Time (UTC).
Григорианский календарь и високосные годы
Григорианский календарь — это наиболее широко используемый сегодня в западном мире календарь. Григорианской календарь создавался с целью исправить ошибку в юлианском календаре. Медленный процесс адаптации григорианского календаря начался в 1582 году.
Юлианский календарь говорит, что каждый четвертый год — это високосный год, но каждый сотый год — не високосный. Григорианской календарь ввел еще одно исключение — каждый 400-й год должен быть високосным.
Високосные годы предназначены для компенсации несинхронности вращения Земли вокруг Солнца и продолжительности дня. Другими словами, частное отделения продолжительности солнечного года на длительность дня — это не целое число. В результате если календарь не корректировать, то мы получим смещение сезонов, когда равноденствия и солнцестояния (которые определяют сезоны) будут все более и более рассинхронизированы с каждым новым годом.
Решение
Вызовите функцию time из заголовочного файла <ctime>, передав в качестве параметра значение 0. Результатом будет значение типа time_t. Для преобразования значения time_t в структуру tm, представляющую текущее время UTC (также известное как Greenwich Mean Time (время по Гринвичу), или GMT), используется функция gmtime, а для преобразования значения time_t в структуру tm, представляющую локальное время, используется функция localtime. Программа в примере 5.1 получает текущие дату/время, а затем преобразует их в локальное время и выводит на экран. Затем программа преобразует текущие дату/время во время/дату UTC и также выводит результат на экран.
Пример 5.1. Получение локального времени и времени UTC
#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
int main() {
 // Текущие дата/время используемой системы
 time_t now = time(0);
 // Преобразуем в структуру tm для локальной временной зоны
 tm* localtm = localtime(&now);
 cout << "Локальные дата и время. " << asctime(localtm) << endl;
 // Преобразуем в структуру tm для UTC
 tm* gmtm = gmtime(&now);
 if (gmtm ! = NULL) {
  cout << "Дата и время UTC: " << asctime(gmtm) << endl;
 } else {
  cerr << "Невозможно получить дату и время UTC" << endl;
  return EXIT_FAILURE;
 }
}
Обсуждение
Функция time возвращает тип time_t, который является зависящим от реализации арифметическим типом, представляющим временной период (интервал времени) с точностью до одной секунды. Наибольший интервал времени, который можно представить с помощью time_t, сохранив совместимость и переносимость кода, — это 2 147 483 648 секунд, или примерно 68 лет.
Вызов time(0) возвращает time_t, представляющее временной интервал от зависящего от реализации начала отсчета (обычно 0:00:00 1 января 1970 года) до текущего момента.
Ошибка 2038 года
Так как time_t может представлять интервалы времени длиной в 68 лет, а многие реализации для представления текущего времени в качестве начала отсчета используют 1970 год, в большинстве популярных реализаций C++ невозможно представлять даты и времена после 2038 года. Это означает, что если программисты не предпримут мер предосторожности, то в 2038 году большая часть программного обеспечения перестанет работать.
Наиболее удобное представление текущих даты и времени можно получить, преобразовав их с помощью функций localtime или gmtime в структуру tm. Структура tm содержит целочисленные поля, показанные в примере 5.2.
Пример 5.2. Содержимое структуры tm
struct tm {
 int tm_sec;   // секунды в минуте от 0 до 61 (60 и 61 для секунд координации)
 int tm_min;   // минуты в часе от 0 до 59
 int tm_hour;  // часы в сутках от 0 до 23
 int tm_mday;  // день месяца от 0 до 31
 int tm_mon;   // месяц года от 0 до 11
 int tm_year;  // год после 1900
 int tm_wday;  // дней после воскресенья
 int tm_yday;  // дней после 1-го января
 int tm_isdst; // часы летнего времени
};
При использовании функции gmtime не забудьте проверить ее возвращаемое значение. Если компьютер, на котором выполняется код, не имеет определенной локальной временной зоны (часового пояса), функция gmtime не сможет вычислить время UTC и вернет 0. Если передать 0 в функцию asctime, то результатом будет неопределенное поведение.
Функции localtime, gmtime и asctime возвращают указатели на статически размещенные в памяти объекты. Это более эффективно для библиотеки, не означает, что последующие вызовы будут изменять значение этих объектов. Код в примере 5.3 показывает, как это может привести к неожиданным эффектам.
Пример 5.3. Подводные камни использования asctime
void f() {
 char* x = asctime(localtime(time(0)));
 wait_for_15_seconds(); // выполняет длительную задачу обработки
 asctime(localtime(time(0)));
 cout << x << endl; // печатает текущее время, а не то что 15 секунд назад.
}
5.2. Форматирование даты/времени в виде строки
Проблема
Требуется преобразовать дату и/или время в строковый формат
Решение
Используйте шаблон класса time_put из заголовочного файла <locale>, как показано в примере 5.4.
Пример 5.4. Форматирование строки даты/времени
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <string>
#include <stdexcept>
#include <iterator>
#include <sstream>
using namespace std;
ostream& formatDateTime(ostream& out, const tm& t, const char* fmt) {
 const time_put<char>& dateWriter = use_facet<time_put<char> >(out.getloc());
 int n = strlen(fmt);
 if (dateWriter.put(out, out, ' ', &t, fmt, fmt + n).failed()) {
  throw runtime_error("невозможно отформатировать дату и время");
 }
 return out;
}
string dateTimeToString(const tm& t, const char* format) {
 stringstream s;
 formatDateTime(s, t.format);
 return s.str();
}
tm now() {
 time_t now = time(0);
 return *localtime(&now);
}
int main() {
 try {
  string s = dateTimeToString(now(), "%A %B, %d %Y %I:%M%p");
  cout << s << endl;
  s = dateTimeToString(now(), "%Y-%m-%d %H:%M:%S);
  cout << s << endl;
 } catch(...) {
  cerr << "невозможно отформатировать дату и время" << endl;
  return EXIT FAILURE.
 }
 return EXIT_SUCCESS;
}
Вывод программы из примера 5.4 будет содержать нечто подобное следующему, в зависимости от локальных настроек.
Sunday July, 24 2005 05:48PM 2005-07-24 17:48:11
Обсуждение
Метод put из time_put использует спецификатор форматирования строки, аналогичный строке формата функции С printf. Символы строки формата выводятся в выходной буфер по мере их появления при условии, что им не предшествует символ %. Символ, перед которым стоит %, — это спецификатор формата, который имеет специальное значение, приведенное в табл. 5.1. Спецификаторы формата также поддерживают модификаторы, такие как целое число, указывающее длину поля, как в %4B.
Tабл. 5.1. Спецификаторы формата даты/времени
Спецификатор	Описание
a	Сокращенное название дня недели (например, Mon (пн))
A	Полное название дня недели (например, Monday (понедельник))
b	Сокращенное название месяца (например, Dec (дек))
B	Полное название месяца (например, May (май))
c	Полные дата и время
d	День месяца (01-31)
H	Час (00-23)
I	Час (01-12)
j	День года (001-366)
m	Месяц (01-12)
M	Минуты (00-59)
p	Признак AM/PM
S	Секунды, включая до двух секунд координации
U	Номер недели (00-53), причем неделя 1 начинается в первое воскресенье
w	День недели (0-6), где 0 — это воскресенье
W	Номер недели (00-53), причем неделя 1 начинается в первый понедельник
x	Дата в формате MM/DD/YY
X	Время в формате HH/MM/SS и 24-часовыми часами
y	Год текущего столетия (00-99)
Y	Год
Z	Сокращение временной зоны (часового пояса), или пустая строка, если зона неизвестна
Библиотека Boost date_time, обсуждаемая в дальнейших рецептах, не содержит возможностей форматирования, предлагаемых time_put. Для удобства пример 5.5 содержит несколько процедур, преобразующих классы даты/времени Boost в формат структуры tm, так что вы можете использовать процедуры time_put.
Пример 5.5. Преобразование из классов даты/времени Boost в структуру tm
using boost::gregorian;
using boost::posix_time;
void dateToTmAux(const date& src, tm& dest) {
 dest.tm_mday = src.day();
 dest tm_year = src.year() - 1900;
 dest.tm_mon = src.month() - 1;
}
void ptimeToTmAux(const ptime& src, tm& dest) {
 dest.tm_sec = src.seconds();
 dest.tm_min = st.minutes();
 dest.tm_hour = src.hours();
 dateToTmAux(src.date(), dest);
}
tm ptimeToTm(const ptime& t) {
 tm ret = tm();
 ptimeToTmAux(t.ret);
 return ret;
}
Смотри также
Рецепт 13.3.
5.3. Выполнение вычислений с датами и временем
Проблема
Требуется узнать количество времени, прошедшего между двумя точками даты/времени.
Решение
Если обе временные точки находятся между 1970 и 2038 годами, то используйте тип time_t и функцию difftime, определенную в заголовочном файле <ctime>. Пример 5.6 показывает, как вычислить число дней, прошедших между двумя датами.
Пример 5.6. Вычисление даты и времени в формате time_t
#include <ctime>
#include <iostream>
#include <cstdlib>
using namespace std;
time_t dateToTimeT(int month, int day, int year) {
 // 5 января 2000 года передается как (1, 5, 2000)
 tm tmp = tm();
 tmp.tm_mday = day;
 tmp.tm_mon = month - 1;
 tmp.tm_year = year - 1900;
 return mktime(&tmp);
}
time_t badTime() {
 return time_t(-1);
}
time_t now() {
 return time(0);
}
int main() {
 time_t date1 = dateToTimeT(1,1,2000);
 time_t date2 = dateToTimeT(1,1,2001);
 if ((date1 == badTime()) || (date2 == badTime())) {
  cerr << "невозможно создать структуру time_t" << endl;
  return EXIT_FAILURE;
 }
 double sec = difftime(date2, date1);
 long days = static_cast<long>(sec / (60 * 60 — 24));
 cout << число дней между 1 января 2000 г. и 1 января 2001 г. составляет ";
 cout << days << endl;
 return EXIT_SUCCESS;
}
Программа из примера 5.6 должна вывести:
число дней между 1 января 2000 г. и 1 января 2001 г. составляет 366
Обратите внимание, что 2000 год високосный, так как, несмотря на то что он делится на 100, он также делится и на 400 и, следовательно, состоит из 366 дней.
Обсуждение
Тип time_t — это зависящий от реализации арифметический тип. Это означает, что это либо целый тип, либо тип с плавающей точкой, и, таким образом, он поддерживает основные арифметические операции. Его можно складывать, вычитать, делить, умножать и т.д. Чтобы вычислить интервал между двумя значениями time_t в секундах, используйте функцию difftime. Не думайте, что сам time_t содержит секунды, даже если это и так. Многие реализации C++ могут в ближайшем будущем молча изменить его так, чтобы он содержал доли секунд (это одна из причин, по которым difftime возвращает double).
Если ограничения time_t слишком жестки, то вместо него для вычисления временных интервалов потребуется использовать различные классы из библиотеки Boost date_time. Пример 5.7 показывает, как использовать классы Boost для вычисления числа дней в 20-м и 21-м столетиях.
Пример 5.7. Вычисление даты и времени с помощью date_duration
#include <iostream>
#include <boost/date_time/gregorian/gregorian.hpp>
using namespace std;
using namespace boost::gregorian;
int main() {
 date_duration dd = date(2000, 1, 1) - date(1900, 1, 1);
 cout << "Двадцатый век содержал " << dd.days() << " дней" << endl;
 dd = date(2100, 1, 1) - date(2000, 1, 1);
 cout << "Двадцать первый век будет содержать " <<
  dd.days() << " дней" << endl;
}
Программа из примера 5.7 должна вывести:
Двадцатый век содержал 36 524 дней
Двадцать первый век будет содержать 36 525 дней
5.4. Преобразование между часовыми поясами
Проблема
Требуется преобразовать текущее время из одного часового пояса в другой.
Решение
Чтобы выполнить преобразование между часовыми поясами, используйте процедуры преобразования часовых поясов из библиотеки Boost date_time. Пример 5.8 показывает, как, зная время в Нью-Йорке, определить время в Туксоне, Аризона.
Пример 5.8. Преобразование между часовыми поясами
#include <iostream>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/local_time_adjustor.hpp>
using namespace std;
using namespace boost::gregorian;
using namespace boost::date_time;
using namespace boost::posix_time;
typedef local_adjustor<ptime, -5, us_dst> EasternTZ;
typedef local_adjustor<ptime, -7, no_dst> ArizonaTZ;
ptime NYtoAZ(prime nytime) {
 ptime utctime = EasternTZ::local_to_utc(nytime);
 return ArizonaTZ::utc_to_local(utctime);
}
int main() {
 // May 1st 2004.
 boost::gregorian::date thedate(2004, 6, 1);
 ptime nytime(thedate, hours(19)); // 7 pm
 ptime aztime = NYtoAZ(nytime);
 cout << "1 мая 2004 г. когда было " << nytime.time_of_day().hours();
 cout << ":00 часов в Нью-Йорке, было " << aztime.time_of_day().hours();
 cout << ":00 часов в Аризоне" << endl;
}
Программа из примера 5.8 выводит следующее.
1 мая 2004 г., когда было 19:00 часов в Нью-Йорке, было 16:00 часов в Аризоне
Обсуждение
Преобразование часовых поясов в примере 5.8 выполняется в два шага. Вначале время преобразуется в UTC, а затем время в UTC преобразуется во второй часовой пояс. Заметьте, что часовые пояса в библиотеке Boost date_time представлены как типы, использующие шаблон класса local_adjustor. Каждый тип содержит функции преобразования, которые преобразуют из данного часового пояса в UTC (функция local_tc_utс) и из UTC в данный часовой пояс (функция utc_to_local).
5.5. Определение номера дня в году
Проблема
Требуется определить номер дня в году. Например, 1 января — это первый день в году, 5 февраля это 36-й день в году, и так далее. Но так как некоторые годы — високосные, то после 28 февраля указанный день может иметь не такой же номер, как и в другие годы.
Решение
Решение этой проблемы требует одновременного решения сразу нескольких проблем. Во-первых, требуется знать, сколько дней в каждом месяце, что в свою очередь требует определить, является ли год високосным. Пример 5.9 содержит процедуры, выполняющие эти вычисления.
Пример 5.9. Процедуры, определяющие номер дня в году
#include <iostream>
using namespace std;
enum MonthEnum {
 jan = 0, feb = 1, mar = 2, apr = 3, may = 4, jun = 5,
 jul = 6, aug = 7, sep = 8, oct = 9, nov = 10, dec = 11
};
bool isLeapYear(int y) {
 return (y % 4 == 0) && ((y % 100 != 0) || (y % 400 == 0));
}
const int arrayDaysInMonth[] = {
 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
int n;
int arrayFirstOfMonth[] = {
 n = 0,
 n += arrayDaysInMonth[jan],
 n += arrayDaysInMonth[feb],
 n += arrayDaysInMonth[mar],
 n += arrayDaysInMonth[apr],
 n += arrayDaysInMonth[may],
 n += arrayDaysInMonth[jun],
 n += arrayDaysInMonth[jul],
 n += arrayDaysInMonth[aug],
 n += arrayDaysInMonth[sep],
 n += arrayDaysInMonth[::oct],
 n += arrayDaysInMonth[nov]
};
int daysInMonth(MonthEnum month, int year) {
 if (month == feb) {
  return isLeapYear(year) ? 29 : 28;
 } else {
  return arrayDaysInMonth[month];
 }
}
int firstOfMonth(MonthEnum month, int year) {
 return arrayFirstOfMonth[month] + isLeapYear(year);
}
int dayOfYear(MonthEnum month, int monthDay, int year) {
 return firstOfMonth(month, year) + monthDay - 1;
}
int main() {
 cout << "1 июля 1971 г. был " << dayOfYear(jul, 1, 1971);
 cout << днем года" << endl;
}
Программа из примера 5.9 выводит следующее.
1 июля 1971 г. был 181 днем года
Обсуждение
Код примера 5.9 довольно прост, но содержит набор полезных функций для работы с датами в високосных годах. Обратите внимание, что я отбросил подход, который я называю «задокументируй и молись», использованный в предыдущих рецептах. Под этим я подразумеваю, что месяцы больше не представляются индексами, вместо которых используются перечисления. Это значительно снижает вероятность программистской ошибки при передаче месяца в функцию в качестве ее аргумента.
Вычисление високосного года, показанное в примере 5.9, выполняется в соответствии с современным григорианским календарем. Каждый четвертый год — високосный, за исключением каждого сотого, если он не делится на 400 (т.е. 1896 год был високосным, 1900 не был, 2000 был, 2004 был, 2100 год не будет).
5.6. Определение ограниченных типов значений
Проблема
Требуются самопроверяющиеся типы числовых данных, представляющие числа в ограниченном диапазоне допустимых значений, гаком как часы в сутках или минуты в часе.
Решение
При работе с датами и временем часто возникает необходимость ограничить целые значения диапазоном допустимых значений (т.е для секунд в минуте — от 0 до 59, для часов в сутках от 0 до 23, для дней в году — от 0 до 365). Вместо того чтобы каждый раз проверять эти значения при их передаче в функцию, предпочтительной является их автоматическая проверка с помощью перегруженного оператора присвоения. Так как имеется очень большое количество таких типов, следует реализовать один тип, который сможет работать с подобной проверкой для различных числовых диапазонов. Пример 5.10 представляет реализацию шаблона класса ConstrаinedValue, который облегчает задание диапазона целых чисел и определение других ограниченных типов.
Пример 5.10. constrained_value.hpp
#ifndef CONSTRAINED_VALUE_HPP
#define CONSTRAINED_VALUE_HPP
#include <cstdlib>
#include <iostream>
using namespace std;
template<class Policy_T>
struct ConstrainedValue {
public:
 // открытые typedef
 typedef typename Policy_T policy_type;
 typedef typename Policy_T::value_type value_type;
 typedef ConstrainedValue self;
 // конструктор по умолчанию
 ConstrainedValue() : m(Policy_T::default_value) {}
 ConstrainedValue(const self& x) : m(x.m) {}
 ConstrainedValue(const value_type& x) { Policy_T::assign(m, x); }
 operator value_type() const { return m; }
 // использует функцию присвоения, определенную политикой
 void assign(const value_type& x) {
  Policy_T::assign(m, x);
 }
 // операции присвоения
 self& operator=(const value_type& x) { assign(x); return *this; }
 self& operator+=(const value_type& x) { assign(m + x) return *this; }
 self& operator-=(const value_type& x) { assign(m - x) return *this; }
 self& operator*=(const value_type& x) { assign(m * x); return *this; }
 self& operator/=(const value_type& x) { assign(m / x); return *this; }
 self& operator%=(const value_type& x) { assign(m % x); return *this; }
 self& operator>>=(int x) { assign(m >> x); return *this; }
 self& operator<<=(int x) { assign(m << x); return *this; }
 // унарные операторы
 self operator-() { return self(-m); }
 self operator+() { return self(-m); }
 self operator!() { return self(!m); }
 self operator~() { return self(~m); }
 // бинарные операторы
 friend self operator+(self x, const value_type& y) { return x += y; }
 friend self operator-(self x, const value_type& y) { return x -= y; }
 friend self operator*(self x, const value_type& y) { return x *= y; }
 friend self operator/{self x, const value_type& y) { return x /= y; }
 friend self operator%(self x, const value_type& y) { return x %= y; }
 friend self operator+(const value_type& y, self x) { return x += y; }
 friend self operator-(const value_type& y, self x) { return x -= y; }
 friend self operator*(const value_type& y, self x) { return x *= y; }
 friend self operator/(const value_type& y, self x) { return x /= y; }
 friend self operator%(const value_type& y, self x) { return x %= y; }
 friend self operator>>(self x, int y) { return x >>= y; }
 friend self operator<<(self x, int y) { return x <<= y; }
 // потоковые операторы
 friend ostream& operator<<(ostream& o, self x) { о << x.m; return o; }
 friend istream& operator>>(istream& i, self x) {
  value_type tmp; i >> tmp; x.assign(tmp); return i;
 }
 // операторы сравнения
 friend bool operator<(const self& x, const self& y) { return x.m < y.m; }
 friend bool operator>(const self& x, const self& y) { return x.m > y.m; }
 friend bool operator<=(const self& x, const self& y) { return x.m <= y.m; }
 friend bool operator>=(const self& x, const self& y) { return x.m >= y.m; }
 friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
 friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
private:
 value_type m;
};
template<int Min_N, int Max_N>
struct RangedIntPolicy {
 typedef int value_type;
 const static value_type default_value = Min_N;
 static void assign(value_type& lvalue, const value_type& rvalue) {
  if ((rvalue < Min_N) || (rvalue > Max_N) {
   throw range_error("out of valid range");
  }
  lvalue = rvalue;
 }
};
#endif
Программа в примере 5.11 показывает, как использовать тип ConstrainedValue.
Пример 5.11. Использование constrained_value.hpp
#include "constrained_value.hpp"
typedef ConstrainedValue< RangedIntPolicy<1582, 4000> > GregYear;
typedef ConstrainedValue< RangedIntPolicy<1, 12> > GregMonth;
typedef ConstrainedValue< RangedIntPolicy<1, 31> > GregDayOfMonth;
using namespace std;
void gregOutputDate(GregDayOfMonth d, GregMonth m, GregYear y) {
 cout << m << "/" << d << "/" << y << endl;
}
int main() {
 try {
  gregOutputDate(14, 7, 2005);
 } catch(...) {
  cerr << "Оп, не должны сюда попасть << endl;
 }
 try {
  gregOutputDate(1, 5, 1148);
  cerr << "Оп, не должны сюда попасть" << endl;
 } catch(...) {
  cerr << "Уверены, что надо использовать григорианский календарь?" << endl;
 }
}
Вывод программы из примера 5.11 имеет вид:
7/14/2005
Уверены, что надо использовать григорианский календарь?
Обсуждение
Ограниченные типы значений обычно используются при работе с датами и временем, так как многие значения, связанные с датами/временем, — это целые числа, которые должны находиться в определенных диапазонах (например, месяц должен быть в интервале [0,11], а день месяца должен быть в интервале [0,30]). Проверять вручную параметр каждой функции на допустимый диапазон очень долго и чревато ошибками. Просто представьте, что требуется внести глобальное изменение в то, как программа, содержащая миллион строк кода, обрабатывает ошибки диапазона дат!
Шаблон класса ConstrainedValue, используемый вместе с шаблоном RangedIntPolicy, может использоваться для простого определения различных типов, выбрасывающих при присвоении значений, выходящих за диапазон, исключения. Пример 5.12 показывает некоторые примеры использования ConstrainedValue для определения новых самопроверяющихся целочисленных типов.
Пример 5.12. Использование ConstrainedValue
typedef ConstrainedValue< RangedIntPolicy <0, 59> > Seconds;
typedef ConstrainedValue< RangedIntPolicy <0, 59> > Minutes;
typedef ConstrainedValue< RangedIntPolicy <0, 23> > Hours;
typedef ConstrainedValue< RangedIntPolicy <0, 30> > MonthDays;
typedef ConstrainedValue< RangedIntPolicy <0, 6> > WeekDays;
typedef ConstrainedValue< RangedIntPolicy <0, 365> > YearDays;
typedef ConstrainedValue< RangedIntPolicy <0, 51> > Weeks.
Шаблон класса ConstrainedValue является примером основанного на политике дизайна. Политика — это класс, передаваемый в шаблон как параметр, который указывает аспекты реализации или поведения параметризованного класса. Политика, передаваемая в ConstrainedValue, должна предоставлять реализацию того, как выполнять присвоение между одними и теми же специализациями типа.
Использование политик может повысить гибкость классов, перенеся часть решений относительно типа на его пользователя. Политики обычно используются тогда, когда группа типов имеет общий интерфейс, но различается по реализациям. Также политики частично полезны при невозможности предугадать и удовлетворить все возможные сценарии использования данного типа.
Имеется множество других политик, которые можно использовать с типом ConstrainedValue. Например, вместо того чтобы выбрасывать исключение, можно присваивать значение по умолчанию или ближайшее допустимое значение. Более того, ограничения не обязательно должны иметь вид диапазонов: можно задать такое ограничение, когда значение всегда должно быть четным.
Глава 6
Управление данными с помощью контейнеров
6.0. Введение
Эта глава описывает структуры данных стандартной библиотеки, используемые для хранения данных. Часто они также называются контейнерами (containers), так как они содержат («contain») хранящиеся в них объекты. Также эта глава описывает другой тип контейнеров, который не является частью стандартной библиотеки, хотя и поставляется с большинством ее реализаций — хеш-контейнер.
Часть библиотеки, которая содержит контейнеры, часто называется Standard Template Library, или STL (стандартная библиотека шаблонов), именно так она называлась до ее включения в стандарт С++. STL включает не только контейнеры, обсуждаемые в этой главе, но и итераторы и алгоритмы, которые являются еще двумя строительными блоками STL, делающими STL гибкой библиотекой общего назначения. Так как эта глава в основном посвящена стандартным контейнерам, а не STL во всем ее многообразии, я буду называть контейнеры «стандартными контейнерами», а не «контейнерами STL», как это делается во многих книгах по С++. Хотя я по мере необходимости описываю итераторы и алгоритмы, более подробно они обсуждаются в главе 7.
Стандарт C++ использует для описания набора контейнеров точную терминологию. «Контейнер» в стандартной библиотеке C++ — это структура данных, имеющая четкий интерфейс, описанный в стандарте. Например, любой класс стандартной библиотеки С++, который называет себя контейнером, должен поддерживать метод begin, который не имеет параметров и возвращает iterator, указывающий на первый элемент в этом контейнере. Имеется большое количество обязательных конструкторов и функций-членов, определяющих, что такое контейнер в терминах С++. Также имеются необязательные методы, реализуемые только некоторыми контейнерами обычно теми, которые могут их эффективно реализовать.
Общий набор контейнеров подразделяется на два различных типа контейнеров: последовательные контейнеры и ассоциативные контейнеры. Последовательный контейнер (обычно называемый просто последовательностью) хранит объекты в порядке, указанном пользователем, и предоставляет необходимый для доступа и обработки элементов интерфейс (в дополнение к обязательному для контейнеров). Ассоциативные контейнеры хранят элементы в упорядоченном виде и, таким образом, не позволяют вставлять элементы в определенное место, хотя для увеличения эффективности при вставке можно указать дополнительные параметры. Как последовательности, так и ассоциативные контейнеры содержат обязательный интерфейс, но только последовательности имеют дополнительный набор операций, который поддерживается только теми последовательностями, для которых он эффективно реализуем. Эти дополнительные операции с последовательностями предоставляют большую гибкость и удобство, чем стандартный интерфейс.
Это выглядит очень похоже на наследование. Последовательность — это контейнер, ассоциативный контейнер — это контейнер, но контейнер — это не последовательность и не ассоциативный контейнер. Однако это не наследование в смысле С++, а наследование с точки зрения концепции, vector — это последовательность, но это самостоятельный класс. Он не наследует от класса container или подобного ему (реализации стандартной библиотеки имеют свободу в реализации vector и других контейнеров, но стандарт не предписывает реализации стандартной библиотеки включать базовый класс container). При разработке контейнеров было приложено большое количество усилий, и если вы хотите поподробнее узнать о них, обратитесь к книге Мэтта Остерна (Matt Austern) Generic Programming and the STL (Addison Wesley).
Эта глава содержит две части. Несколько первых рецептов рассказывают, как использовать vector, который является стандартной последовательностью и одной из наиболее популярных структурой данных. Они описывают, как эффективно и рационально использовать vector. Остальные рецепты описывают большую часть остальных широко применяемых стандартных контейнеров, включая два нестандартных хеш-контейнера, о которых я упоминал ранее.
6.1. Использование vector вместо массивов
Проблема
Требуется сохранить элементы (встроенные типы, объекты, указатели и т.п.) в виде последовательности, обеспечить произвольный доступ к ним, и не ограничивать место хранения массивом статического размера.
Решение
Используйте шаблон класса vector стандартной библиотеки, определенный в <vector>, и не используйте массивы. vector выглядит и ведет себя, как массив, но имеет перед ним большое количество преимуществ в части безопасности и удобства. Пример 6.1 показывает несколько обычных операций с vector.
Пример 6.1. Использование некоторых методов vector
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int main() {
 vector<int> intVec;
 vector<string> strVec;
 // Добавление элементов в "конец" вектора с помощью push_back
 intVec.push_back(3);
 intVec.push_back(9);
 intVec.push_back(6);
 string s = "Army";
 strVec.push_back(s);
 s = "Navy";
 strVec.push_back(s);
 s = "Air Force";
 strVec.push_back(s);
 // Для доступа к элементам используется operator[], как и для массивов
 for (vector<string>::size_type i = 0; i < intVec.size(); ++i) {
  cout << "intVec[" << i << "] = " << intVec[i] << '\n';
 }
 // Или можно использовать итераторы
 for (vector<string>::iterator p = strVec.begin();
  p != strVec.end(); ++p) {
  cout << *p << '\n';
 }
 // Если требуется безопасность, вместо operator[] используйте at(). Она
 // при использовании индекса > size() выбрасывает исключение out_of_range.
 try {
  intVec.at(300) = 2;
 } catch(out_of_range& e) {
  cerr << "out_of_range: " << e.what() << endl;
 }
}
Обсуждение
В целом, если требуется использовать массив, вместо него следует использовать vector. vector предлагает большую безопасность и гибкость, чем массив, а накладные расходы на производительность в большинстве случаев пренебрежимо малы, и если окажется, что они больше, чем можно себе позволить, производительность vector можно увеличить, использовав некоторые его методы.
Если вы не знакомы с контейнерами, поставляющимися в составе стандартной библиотеки, или не сталкивались с использованием шаблонов классов (и их написанием), то объявление vector в примере 6.1 требует некоторых пояснений. Объявление vector имеет следующий вид.
vector<typename Value, // Тип элемента, который будет храниться в этом векторе
 typename Allocator = allocator<Value> > // используемый распределитель (allocator)
                                         // памяти
Стандартные контейнеры параметризованы по типу объектов, которые будут в них храниться. Также есть параметр шаблона для используемого распределителя памяти, но по умолчанию он имеет стандартное значение и обычно не указывается, так что я его здесь обсуждать не буду.
Если вы хотите, чтобы vector хранил элементы типа int, объявите его, как в этом примере.
vector<int> intVec;
А если вам требуется, чтобы он хранил строки, просто измените тип аргумента vector.
vector<string> strVec;
vector может содержать любой тип С++, который поддерживает конструктор копирования и присвоение.
Следующее, что логически требуется сделать после создания экземпляра vector, — это что-либо поместить в него. В конец вектора элементы добавляются с помощью push_back.
intVec.push_back(3);
intVec.push_back(9);
intVec.push_back(6);
Это примерно эквивалентно добавлению элементов 0, 1 и 2 в массив. Это «примерно» эквивалентно потому, что, конечно, push_back — это метод, который возвращает void и помещает свой аргумент в конец вектора. operator[] возвращает ссылку на область памяти, на которую указывает индекс массива, push_back гарантирует, что во внутреннем буфере vector окажется достаточно места для добавления аргумента. Если место есть, то он добавляется в следующий неиспользуемый индекс, а если нет, то буфер увеличивается с помощью зависящего от реализации алгоритма, а затем в него добавляется аргумент
Также с помощью метода insert можно вставить элементы в середину вектора, хотя этого следует избегать из-за линейно возрастающей сложности этой операции. За более подробным обсуждением проблем производительности и их решения при использовании vector обратитесь к рецепту 6.2. Чтобы вставить элемент, получите итератор на точку, куда требуется его вставить (обсуждение итераторов приводится в рецепте 7.1).
string s = "Marines";
vector<string>::iterator p = find(strVec.begin()
strVec.end(), s);
if (s != strVec.end()) // Вставляет s непосредственно перед элементом,
 strVec.insert(p, s);  // на который указывает p
Перегруженные версии insert позволяют вставлять в вектор n копий объекта, а также вставлять целый диапазон другой последовательности (эта последовательность может быть другим vector, массивом, list и т.п.).
Вместо вставки можно просто присвоить вектору уже существующую другую последовательность, стерев при этом то, что в нем содержалось до этого. Это выполняет метод assign. Вектору можно присвоить диапазон значений или n копий одного и того же объекта, как здесь.
string sarr[3] = {"Ernie", "Bert", "Elmo"};
string s = "Oscar";
strVec.assign(&sarr[0], &sarr[3]); // Присвоить эту последовательность
strVec.assign(50, s);              // Присвоить 50 копий s
Если новая последовательность окажется больше, чем имеющийся размер буфера vector, то assign изменит размер буфера так, чтобы разместить в нем всю новую последовательность.
После того как данные помещены в vector, имеется несколько способов получения их назад. Вероятно, наиболее интуитивным является operator[], который возвращает ссылку или const-ссылку в зависимости от того, является ли вектор const или нет, на элемент по указанному индексу. В этом отношении он ведет себя почти как массив:
for (int i = 0; i < intVec.size(); ++i) {
 std::cout << "intVec[" << i << "] = "
  << intVec[i] << '\n'; // rvalue
}
intVec[2] = 32; // lvalue
operator[] также ведет себя как массив в том, что при использовании индекса, который больше, чем индекс последнего элемента vector, результат не определен, что обычно означает, что будут повреждены данные программы или она обрушится. Избежать этого можно, запросив число элементов, содержащихся в vector, с помощью size(). Однако использованию operator[] следует предпочитать итераторы, так как их использование является стандартным для перебора элементов любого стандартного контейнера.
for (vector<string>::iterator p = strVec.begin();
 p != strVec.end(); ++p) {
 std::cout << *p << '\n';
}
Итераторы являются наиболее мощным подходом, так как они позволяют обращаться с контейнерами одинаковым образом. Например, при написании алгоритма, который работает с последовательностями элементов, расположенными между двумя итераторами, он сможет работать с любым стандартным контейнером. Это общий подход. При использовании произвольного доступа с помощью operator[] вы ограничиваете себя использованием только тех контейнеров, которые поддерживают произвольный доступ. Первый подход позволяет алгоритмам стандартной библиотеки из <algorithm> одинаково работать со стандартными контейнерами (и другими типами, ведущими себя, как они).
Также vector предоставляет безопасность, которой просто невозможно достичь в случае обычных массивов. В отличие от массивов vector с помощью метода at предлагает проверку диапазонов. Если в at передается неправильный индекс, он выбрасывает исключение out_of_range, которое затем можно перехватить с помощью catch и адекватно на него отреагировать. Например:
try {
 intVec.at(300) = 2;
} catch(std::out_of_range& e) {
 std::cerr << "out_of_range: " << e.what() << std::endl;
}
Как вы знаете, если обратиться к элементу за пределами массива с помощью operator[], оператор сделает то, что ему сказано сделать, и вернет то, что находится в указанной области памяти. Это плохо, так как либо программа обрушится в результате попытки доступа к области памяти, к которой она доступа не имеет, либо она молча изменит содержимое области памяти, принадлежащей другому объекту кучи, что обычно еще хуже. operator[] для vector работает точно так же, но когда требуется обезопасить код, используйте at.
Итак, вот краткий курс по vector. Но что такое vector? Если вы используете С++, то вас, вероятно, волнуют проблемы производительности, и вам не понравится, если вам просто дадут что-то и скажут, что это работает. Вполне справедливо. За обсуждением работы vector и советами по его эффективному использованию обратитесь к рецепту 6.2.
Смотри также
Рецепт 6.2.
6.2. Эффективное использование vector
Проблема
Вы используете vector, и при этом имеются жесткие требования по объему или времени выполнения кода и требуется снизить или устранить все накладные расходы.
Решение
Поймите, как реализован vector, узнайте о сложности методов вставки и удаления и минимизируйте ненужные операции с памятью с помощью метода reserve. Пример 6.2 показывает некоторые из этих методик в действии.
Пример 6.2. Эффективное использование vector
#include <iostream>
#include <vector>
#include <string>
using std::vector;
using std::string;
void f(vector<string>& vec) {
 // Передача vec по ссылке (или,
 // если требуется, через указатель)
 // ...
}
int main() {
 vector<string> vec(500); // При создании vector говорим, что в него
                          // планируется поместить определенное количество
                          // объектов
 vector<string> vec2;
 // Заполняем vec...
 f(vec);
 vec2 reserve(500); // Или постфактум говорим vector,
                    // что требуется буфер достаточно большого
                    // размера для хранения объектов
                    // Заполняем vec2...
}
Обсуждение
Ключ к эффективному использованию vector лежит в знании его работы. Когда у вас есть четкое представление реализации vector, вопросы производительности становятся очевидными.
Как работает vector
vector — это по сути управляемый массив. Более конкретно, vector<T> — это непрерывный фрагмент памяти (т.е. массив), который достаточно велик для хранения n объектов типа T, где n больше или равно нулю и меньше или равно зависящему от реализации максимальному размеру. Обычно n увеличивается в процессе жизни контейнера при добавлении или удалении элементов, но оно никогда не уменьшается. Что отличает vector от массива — это автоматическое управление памятью массива, методы для вставки и получения элементов и методы, которые предоставляют метаданные о контейнере, такие как размер (число элементов) и емкость (размер буфера), а также информацию о типе: vector<T>::value_type — это тип T, vector<T>::pointer — это тип указатель-на-T и т.д. Два последних и некоторые другие являются частью любого стандартного контейнера, и они позволяют писать обобщенный код, который работает независимо от типа T. Рисунок 6.1 показывает графическое представление того, что предоставляют некоторые из методов vector, если vector имеет размер 7 и емкость 10.
Рис. 6.1. Внутренности vector
Если вам любопытно, как поставщик вашей стандартной библиотеки реализовал vector, скомпилируйте пример 6.1 и пройдите в отладчике все вызовы методов vector или откройте заголовочный файл <vector> реализации стандартной библиотеки и изучите его. Код, который вы там увидите, по большей части не является дружественным к читателю, но он должен осветить некоторые моменты. Во-первых, если вы еще не видели кода библиотеки, он даст вам представление о методиках реализации, используемых для написания эффективного, переносимого обобщенного кода. Во-вторых, он даст точное представление о том, что представляют собой используемые вами контейнеры. При написании кода, который должен работать с различными реализациями стандартной библиотеки, это следует сделать в любом случае.
Однако независимо от поставщика библиотеки почти все реализации векторов похожи. В них есть переменная экземпляра, которая указывает на массив из T, и элементы, добавляемые или присваиваемые вами, с помощью конструктора копирования или операции присвоения помешаются в элементы этого массива.
Обычно добавление объекта T в следующий доступный слот буфера выполняется с помощью копирующего конструктора и new, которому передается тип создаваемого объекта, а также адрес, по которому он должен быть создан. Если вместо этого явно присвоить значение слоту, используя его индекс (с помощью operator[] или at), то будет использован оператор присвоения T. Заметьте, что в обоих случаях объект клонируется либо с помощью конструктора копирования, либо T::operator=. vector не просто хранит адрес добавляемого объекта. Именно по этой причине любой тип, сохраняемый в векторе, должен поддерживать копирующий конструктор и присвоение. Эти свойства означают, что эквивалентный объект типа T может быть создан с помощью вызова конструктора копирования T или оператора присвоения. Это очень важно из-за семантики копирования vector — если конструктор копирования или присвоение объектов не работает, то результаты, получаемые из vector, могут отличаться от того, что в него помещалось. А это плохо.
После добавления некоторого набора объектов в vector его буфер заполняется, и для добавления новых объектов его требуется увеличить. Алгоритм увеличения размера зависит от реализации, но обычно буфер размера n увеличивается до 2n+1. Важным здесь является то, как vector увеличивает свой буфер. Вы не можете просто сказать операционной системе неопределенно увеличить свой фрагмент памяти кучи. Требуется запросить новый фрагмент, который больше уже имеющегося. В результате процесс увеличения размера буфера выглядит следующим образом.
1. Выделить память для нового буфера.
2. Скопировать старые данные в новый буфер.
3. Удалить старый буфер.
Это позволяет vector хранить все его объекты в одном непрерывном фрагменте памяти.
Оптимизация производительности vector
Предыдущий раздел должен дать вам представление о том, как объекты хранятся в векторе. Из этого обзора вам должны стать понятны главные моменты, связанные с производительностью, но в том случае, если вы еще не поняли, я расскажу о них.
Для начала, vector (или любой другой контейнер из стандартной библиотеки) не хранит объекты. Он хранит копии объектов. Это значит, что каждый раз, когда в vector заносится новый объект, он туда не «кладется». С помощью конструктора копирования или оператора присвоения он копируется в другое место. Аналогично при получении значения из vector происходит копирование того, что находится в векторе по указанному индексу, в локальную переменную. Рассмотрим простое присвоение элемента vector локальной переменной.
vector<MyObj> myVec;
// Поместить несколько объектов MyObj в myVec
MyObj obj = myVec[10]; // Скопировать объект с индексом 10
Это присвоение вызывает оператор присвоения obj, в качестве правого операнда которого используется объект, возвращенный myVec[10]. Накладные расходы на производительность при работе с большим количеством объектов резко возрастают, так что их лучше всего избегать.
Для снижения накладных расходов на копирование вместо помещения в vector самих объектов поместите в него указатели. Сохранение указателей потребует меньшего количества циклов ЦП на добавление и получение данных, так как указатели проще скопировать, чем объекты, и, кроме того, это снизит объем памяти, необходимый для буфера vector. Но помните, что при добавлении в контейнер стандартной библиотеки указателей контейнер не удаляет их при своем уничтожении. Контейнеры удаляют только содержащиеся в них объекты, т.е. переменные, которые хранят адреса объектов, но контейнер ничего не знает, хранится ли в нем указатель или объект. Все, что он знает, — это то, что это объект типа T.
Изменение размера буфера тоже не дешево. Копирование каждого элемента буфера требует много работы, и этого лучше всего избегать. Чтобы защититься от этого, явно укажите размер буфера. Имеется пара способов сделать это. Простейшим способом сделать это является указание размера при создании вектора.
vector<string> vec(1000);
Здесь резервируется место для 1000 строк, и при этом производится инициализация каждого слота буфера с помощью конструктора string по умолчанию. При этом подходе приходится платить за создание каждой из этих строк, но добавляются определенные меры безопасности в виде инициализации каждого элемента буфера пустой строкой. Это означает, что при ссылке на элемент, значение которого еще не было присвоено, будет просто получена пустая строка.
Если требуется проинициализировать буфер каким-то определенным значением, можно передать объект, который требуется скопировать в каждый слот буфера.
string defString = "uninitialized";
vector<string> vec(100, defString);
string s = vec[50]; // s = "uninitialized"
В этом варианте vec с помощью конструктора копирования создаст 100 элементов, содержащих значение из defString.
Другим способом резервирования пространства буфера является вызов метода reserve, расположенный после создания vector.
vector<string> vec;
vec reserve(1000);
Главным различием между вызовом reserve и указанием размера в конструкторе является то, что reserve не инициализирует слоты буфера каким-либо значением. В частности, это означает, что не следует ссылаться на индексы, в которые еще ничего не записано.
vector<string> vec(100);
string s = vec[50]; // без проблем: s содержит пустую строку
vector<string> vec2;
vec2.reserve(100);
s = vec2[50];      // Не определено
Использование резервирования или указание числа объектов по умолчанию в конструкторе помогает избежать ненужных перераспределений буфера, Это приводит к увеличению производительности, но также позволяет избежать и еще одной проблемы: каждый раз, когда происходит перераспределение буфера, все итераторы, имевшиеся на этот момент и указывающие на элементы, становятся недействительными.
Наконец, плохой идеей является вставка элементов в любое место, кроме конца вектора. Посмотрите на рис. 6.1. Так как vector — это просто массив с дополнительными прибамбасами, становится очевидно, почему следует добавлять элементы только в конец вектора. Объекты в vector хранятся последовательно, так что при вставке элемента в любое место, кроме конца, скажем, по индексу n, объекты с n+1 до конца должны быть сдвинуты на один (в сторону конца) и освободить место для нового элемента. Сложность этой операции линейна, что означает, что она оказывается дорогостоящей даже для векторов скромного размера. Удаление элемента вектора имеет такой же эффект: оно означает, что все индексы больше n должны быть сдвинуты на один слот вверх. Если требуется возможность вставки и удаления в произвольном месте контейнера, вместо вектора следует использовать list.
6.3. Копирование вектора
Проблема
Требуется скопировать содержимое одного vector в другой.
Решение
Имеется пара способов сделать это. Можно при создании vector использовать конструктор копирования, а можно использовать метод assign. Пример 6.3 показывает оба этих способа.
Пример 6.3. Копирование содержимого vector
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
// Вспомогательная функция для печати содержимого вектора
template<typename T>
void vecPrint (const vector<T>& vec) {
 cout << "{";
 for (typename vector<T>::const_iterator p = vec.begin();
  p != vec.end(); ++p) {
  cout << "{" << *p << "} ";
 }
 cout << "}" << endl;
}
int main() {
 vector<string> vec(5);
 string foo[] = {"My", "way", "or", "the", "highway"};
 vec[0] = "Today";
 vec[1] = "is";
 vec[2] = "a";
 vec[3] = "new";
 vec[4] = "day";
 vector<string> vec2(vec);
 vecPrint(vec2);
 vec.at(0) = "Tomorrow";
 vec2.assign(vec.begin(), vec.end()); // Копирование каждого элемента
 vecPrint(vec2);                      // с помощью присвоения
 vec2.assign(&foo[0], &foo[5]); // Присвоение работает для всего, что
 vecPrint(vec2);                // ведет себя как итератор
 vector<string>::iterator p;
 p = find(vec.begin(), vec.end(), "new");
 vec2.assign(vec.begin(), p); // Копирование подмножества полного диапазона
 vecPrint(vec2);              // vec
}
Обсуждение
Копирование vector просто. Имеется два способа сделать это. Можно скопировать один vector в другой с помощью конструктора копирования, как и любой другой объект, а можно использовать метод assign. О конструкторе копирования сказать почти нечего. Просто передайте в него vector, который требуется скопировать, и все.
vector<string> vec2(vec);
В этом случае vec2 будет содержать такое же число элементов, что и vec, и каждый из этих элементов будет копией элемента vec с таким же индексом. Каждый элемент копируется с помощью конструктора копирования string. Так как здесь используется конструктор, буфер vec2 имеет размер, достаточный для хранения всего, что есть в vec.
assign работает аналогично, за исключением того, что за кулисами выполняется дополнительная работа, связанная с тем, что теперь дело касается целевого vector который уже может содержать данные. Во-первых, требуется удалить элементы, которые оказались, так сказать, под ногами. Вначале assign для каждого из объектов, уже содержащихся в vec2, вызывает деструктор. После этого он проверяет размер буфера vec2, чтобы убедиться, что он достаточно большой, чтобы вместить то, что находится в vec. Если он не достаточен, assign изменяет размер буфера под размещение новых данных. Наконец, он копирует каждый элемент.
Кроме того, assign можно использовать для копирования подмножества последовательности. Например, если требуется скопировать подмножество элементов vec, просто укажите при вызове assign необходимый диапазон.
vector<string>::iterator p;
p = std::find(vec.begin(), vec.end(), "new");
vec2.assign(vec.begin(), p);
vecPrint(vec2);
В этом случае assign скопирует все до, но не включая, p. Причиной этого является соглашение, по которому во всех контейнерах и алгоритмах стандартной библиотеки assign(first, last) копирует элементы, на которые указывает first, до, но не включая, элемент, на который указывает last. Такой диапазон, который включает первый элемент, но не включает последний, часто обозначается как (first, last).
Используйте assign или конструктор копирования вместо самостоятельного циклического перебора. Это значит, не копируйте каждый элемент, перебирая vec и помещая элементы в конец vec2 в цикле. Это потребует от вас большой избыточности кода и отключит все оптимизации, которые могут присутствовать в реализации assign и конструктора копирования стандартной библиотеки.
6.4. Хранение указателей в векторе
Проблема
С целью повышения эффективности или по другим причинам невозможно хранить копии объектов в vector, но их требуется как-то разместить.
Решение
Сохраните в vector указатели на объекты, а не копии самих объектов. Но при этом не забудьте удалить объекты с помощью delete, так как vector этого за вас не сделает. Пример 6.4 показывает, как объявить vector указателей и работать с ним.
Пример 6.4. Использование векторов указателей
#include <iostream>
#include <vector>
using namespace std;
static const int NUM_OBJECTS = 10;
class MyClass { /*...*/ };
int main() {
 vector<MyClass*> vec;
 MyClass* p = NULL;
 // Загрузить в vector объекты MyClass
 for (int i = 0; i < NUM_OBJECTS; i++) {
  p = new MyClass();
  vec.push_back(p);
 }
 // Выполнить обработку данных, затем удалить объекты, когда
 // они уже не нужны
 for (vector<MyClass*>::iterator pObj = vec.begin();
  pObj != vec.end(); ++pObj) {
  delete *pObj; // заметьте, что здесь удаляется то на что указывает pObj,
                // который является указателем
 }
 vec.clear(); // Очистить содержимое, чтобы больше никто не попытался
              // удалить его еще раз
}
Обсуждение
Сохранить указатели в vector можно точно так же, как и все остальное. Объявите vector указателей таким образом:
vector<MyClass*> vec;
Здесь важно запомнить, что vector хранит значения, не обращая внимания на то, что они означают. Следовательно, он не знает, что для указателей перед их удалением следует использовать delete. Если выделить память, затем поместить указатели в память vector, то по окончании работы следует самостоятельно удалить память. Не дайте ввести себя в заблуждение термину «контейнер», думая, что если в vector сохранить указатель, то это подразумевает владение им.
После удаления указателей следует явно очистить vector — по той же причине, по которой следует присваивать переменным-указателям по окончании работы с ними значение NULL. Это предотвратит ошибочное повторное удаление.
6.5. Хранение объектов в списке
Проблема
Требуется хранить элементы в виде последовательности, но vector не соответствует всем требованиям. В частности, требуется иметь возможность эффективно добавлять и удалять элементы в середине последовательности, а не только в ее конце.
Решение
Для хранения данных используйте list, объявленный в <list>. list предлагает более высокую производительность и большую гибкость при изменении последовательности в произвольных местах. Пример 6.5 показывает, как использовать list, а также демонстрирует некоторые из его уникальных операций.
Пример 6.5. Использование list
#include <iostream>
#include <list>
#include <string>
#include <algorithm>
using namespace std;
// Простая функция для печати
template<typename T>
struct printer {
 void operator()(const T& s) {
  cout << s << '\n';
 }
};
bool inline even(int n) {
 return(n % 2 == 0);
}
printer<string> strPrinter;
printer<int> intPrinter;
int main() {
 list<string> lstOne;
 list<string> lstTwo;
 lstOne.push_back("Red");
 lstOne.push_back("Green");
 lstOne.push_back("Blue");
 lstTwo.push_front("Orange");
 lstTwo.push_front("Yellow");
 lstTwo.push_front("Fuschia");
 for_each(lstOne.begin(), // Напечатать каждый элемент списка,
  lstOne.end(),           // используя пользовательскую функцию печати
  strPrinter);
 lstOne.sort(); // list содержит методы для сортировки
 lstTwo.sort();
 lstOne.merge(lstTwo);    // Объединить два списка и напечатать
 for_each(lstOne.begin(), // результаты (перед объединением списки должны
  lstOne.end(),           // быть отсортированы)
  strPrinter);
 list<int> intLst;
 intLst.push_back(0);
 intLst.push_back(1);
 intLst.push_back(2);
 intLst.push_back(3);
 intLst.push_back(4);
 // Удалить все значения больше 2
 intLst.remove_if(bind2nd(greater<int>(), 2));
 for_each(intLst.begin(), intLst.end(), intPrinter);
 // Или удалить все четные значения
 intLst.remove_if(even);
}
Обсуждение
list — это последовательность, обеспечивающая постоянную сложность операций вставки и удаления элементов в произвольную позицию, но обладающая линейной сложностью их поиска. Обычно list реализуется как двухсвязный список, что означает, что каждый элемент хранится в узле, содержащем указатели на предыдущий и следующий элементы последовательности. Он обеспечивает все требования к контейнеру стандартной последовательности, полюс предоставляет несколько уникальных методов.
Объявление list не вызывает сложностей — просто укажите тип элементов, которые в нем будут храниться, и, опционально, класс распределителя памяти.
list<typename Value, // Тип элементов, хранящихся в списке
 typename Allocator = allocator<Value> > // Используемый распределитель
                                         // памяти
Параметр шаблона Value — это тип элементов, которые будут храниться в list. Это должен быть тип, который поддерживает конструктор копирования и присвоение. Allocator — это используемый класс распределителя памяти. По умолчанию используется стандартный распределитель (и в большинстве случаев его вполне достаточно).
Далее приведено типичное объявление list (см. пример 6.5).
list<string> lstOne;
После объявления списка поместите в него что-нибудь с помощью push_front или push_back, как здесь.
lstOne.push_back("Red"); // Добавление элементов в конец списка
lstOne.push_back("Green");
lstOne.push_back("Blue");
lstTwo.push_front("Orange"); // Добавление элементов в начало
lstTwo.push_front("Yellow");
lstTwo.push_front("Fuschia");
Помещение элементов в list занимает постоянное время, а не амортизированное постоянное время, как в случае с vector. Реализации list не требуется периодически изменять размер буфера, так что в них не будет возникать периодических падений производительности, как при использовании vector. list просто должен обновить набор указателей, и больше ничего.
Для удаления элементов из начала или конца list используйте pop_front или pop_back (без аргументов). Несмотря на их имя, методы «pop» не возвращают извлекаемый элемент, как это можно ожидать, исходя из обычной семантики стеков.
Обычно list выглядит так, как показано на рис. 6.2. Каждый узел содержит (по меньшей мере) три части: объект, в нем содержащийся, указатель на предыдущий узел и указатель на следующий узел. В оставшейся части рецепта я буду ссылаться на указатели на следующий и предыдущий узлы как next_ и prev_.
Рис. 6.2. Список с двунаправленными связями
Когда вы увидите, как реализован list, станет очевидно, почему некоторые операции имеют сложность, отличную от их сложности для vector. Добавление элемента в любое место list требует только изменения указателей next_ и prev_ предыдущего и следующего элементов. Приятным моментом в list является то, что при вставке и удалении элементов в помощью insert и erase устаревают значения только тех итераторов, которые указывают на затрагиваемый(е) объект(ы). Итераторы для других элементов не теряют актуальности.
Методы вставки и удаления — это insert и erase, insert в качестве первого аргумента принимает итератор, а в качестве второго — либо объект типа T, либо количество и затем объект типа T, либо начальный и конечный итераторы. Первый аргумент-итератор указывает на элемент, непосредственно перед которым должна произойти вставка. Перегрузки insert используются вот так.
list<string> strlst;
list<string>::iterator p;
// ...
string s = "Scion";
p = find(strLst.begin(), strLst.end(), // std::find из <algorithm>
 "Toyota");
strLst.insert(p, s);     // Вставить s сразу перед p
strLst.insert(p, 16, s); // Вставить 16 копий s непосредственно перед p
strLst insert(p, myOtherStrLst.begin(), // Вставить все, что содержится
 myOtherStrLst.end());                  // в myOtherStrLst, перед p
Удаление элементов аналогично.
p = find(strLst.begin(), strLst.end(), // std::find из <algorithm>
 "Toyota");
strLst1.erase(p); // Удаляем этот элемент
strLst2.erase(p, strLst.end()); // Удаляем от p до конца
strLst3.clear(); // Удаляем все элементы
В дополнение к методам стандартных контейнеров list предоставляет несколько своих. Первый — это splice.
splice делает то, что означает его имя: он объединяет два list в один. Вот как можно объединить lstTwo с lstOne из примера 6.5.
list<string>::iterator p = // Находим, куда вставить второй
 std::find(lstOne.begin(), // список
  lstOne.end(), "Green");
lstOne.splice(p, lstTwo); // Вставляем lstTwo непосредственно перед "Green"
p — это итератор, который указывает на элемент в lstOne. lstTwo вставляется в lstTwo непосредственно перед p. Как и в случае со вставкой, все, что здесь требуется сделать, — это изменить указатели next_ и prev_ соответствующих узлов, так что эта операция занимает постоянное время. После объединения lstTwo с lstOne первый очищается, и именно поэтому этот параметр не объявлен как const. Также можно вставить в lstOne один элемент или диапазон элементов из lstTwo. В обоих случаях элементы, объединяемые с другим списком, удаляются из первоначального.
Если списки отсортированы (list содержит свой собственный метод sort, std::sort с list не работает) и требуется объединить их в один, сохранив их порядок, то вместо splice используйте merge. merge объединяет два списка в один, и если два элемента оказываются одинаковыми, то в конечную версию попадает элемент из lstOne. Как и в случае со splice, список, переданный в качестве аргумента, по окончании объединения очищается.
Также list содержит несколько удобных операций для удаления элементов. Представьте, что вам требуется удалить все вхождения какого-либо элемента. Все, что для этого требуется сделать, это вызвать remove, передав такой аргумент, который при сравнении с элементами list будет давать (*p == item) != false, где p — это итератор list. remove вызывается вот так.
strLst.remove("Harry");
В результате из strLst будут удалены все элементы, у которых el == "Harry". Если требуется удалить элементы, которые удовлетворяют какому-либо предикату, такому как больше какого-либо значения, используйте remove_if.
bool inline even(int n) {
 return(n % 2 == 0);
}
list<int> intLst;
// Fill up intLst...
intLst.remove_if(even); // Удаляет все элементы, для которых even(*p)
                        // != false
Если предикаты более сложные, то попробуйте использовать какие-то из функторов из <functional>. Например, если требуется удалить элементы, которые больше определенного значения, используйте в remove_if объединение из greater (из <algorithm>) и bind2nd.
intLst.remove_if(std::bind2nd(std::greater<int>(), 2));
В результате этого из intLst будут удалены все значения, которые больше 2. Эта запись несколько необычна, но ничего сложного в ней нет. bind2nd принимает два аргумента — объект функции (назовем ее f) и значение (v) — и возвращает объект функции, который принимает один аргумент (arg) и вызывает f(arg, v). bind2nd — это простой способ делать подобные вещи без необходимости писать набор небольших функций.
list — это хорошая альтернатива вектору, когда требуется стандартный последовательный контейнер. Другое внутреннее представление list позволяет ему обеспечить другой уровень сложности многих стандартных операций с последовательностями и несколько дополнительных операций.
Смотри также
Рецепт 6.1.
6.6. Отображение строк на другие объекты
Проблема
Имеются объекты, которые требуется сохранить в памяти, и вы хотите хранить их по ключам типа string. Требуется иметь возможность быстро добавлять, удалять и получать элементы (с, как максимум, логарифмической сложностью).
Решение
Для отображения ключей (string) на значения (любой тип, который подчиняется семантике значений) используйте стандартный контейнер map, объявленный в <map>. Пример 6.6 показывает, как это делается.
Пример 6.6. Создание отображения строк
#include <iostream>
#include <map>
#include <string>
using namespace std;
int main() {
 map<string, string> strMap;
 strMap["Monday"] = "Montag";
 strMap["Tuesday"] = "Dienstag";
 strMap["Wednesday"] = "Mittwoch";
 strMap["Thursday"] = "Donnerstag";
 strMap["Friday"] = "Freitag";
 strMap["Saturday"] = "Samstag";
 // strMap.insert(make_pair("Sunday", "Sonntag"));
 strMap.insert(pair<string, string>("Sunday", "Sonntag"));
 for(map<string, string>::iterator p = strMap.begin();
  p != strMap.end(); ++p) {
  cout << "English: " << p->first
   << German: " << p->second << endl;
 }
 cout << endl;
 strMap.erase(strMap.find("Tuesday"));
 for (map<string, string>::iterator p = strMap.begin();
  p ! = strMap.end(); ++p) {
  cout << "English: " << p->first
   << ", German: " << p->second << endl;
 }
}
Обсуждение
map — это ассоциативный контейнер, который отображает ключи на значения, предоставляет логарифмическую сложность вставки и поиска и постоянную сложность удаления одного элемента. Обычно разработчики используют отображение для хранения объектов по их ключам типа string. Именно это делает пример 6.6. В этом случае отображаемый тип является строкой, но он может быть почти чем угодно.
Отображение объявляется вот так.
map<typename Key, // Тип ключа
 typename Value,  // Тип значения
 typename LessThanFun = std::less<Key>, // Функция/функтор,
                                        // используемые для сортировки
 typename Alloc = std::allocator<Key> > // Распределитель памяти
Key и Value — это типы ключа и связанного значения, которые хранятся в отображении. LessThanFun — это функция или функтор, который принимает два аргумента и возвращает истину, если первый меньше, чем второй. По умолчанию используется стандартный функтор less. Alloc — это распределитель памяти, и по умолчанию используется стандартный.
Использование map довольно просто. Объявите тип ключа и значения вот так.
map<string, string> strMan;
В результате будет создан map, в котором и ключ, и значение имеют тип string. С помощью operator[] поместите в отображение объекты, что интуитивно и легко читаемо.
strMap["Monday"] = Montag";
strMap["Tuesday"] = "Dienstag";
strMap["Wednesday"] = "Mittwoch"; // ...
В результате в map будут вставлены элементы с индексом (например, "Monday") в качестве ключа и правым операндом в качестве значения. Они хранятся в порядке, определяемом параметром шаблона LessThanFun, и если он не указан, то map использует std::less<Key>.
Чтобы получить значения из map, используйте operator[] в правой части присвоения, как здесь.
wedInGerman = strMap["Wednesday"];
В манере всех стандартных контейнеров значение, связанное с ключом "Wednesday", с помощью operator= копируется в объект wedInGerman.
operator[] — это удобный способ вставки или обновления элементов или получения значений из map, но он имеет побочный эффект, который может оказаться неожиданным. Строго говоря, operator[k] возвращает ссылку на значение, ассоциированное с k — независимо от того, существует ли k в map или нет. Если k уже находится в map, то возвращается ассоциированное с ним значение. Если нет, то k вставляется, а затем используется конструктор по умолчанию, который создает объект значения для этого ключа. Чтобы сделать это более понятным, рассмотрим, что делает следующий код.
map<string, string> mapZipCodes;     // Сейчас здесь ноль элементов
string myZip = mapZipCodes["Tempe"]; // В map пока что нет элементов,
                                     // но чему теперь равно count()?
Что находится в myZip и сколько теперь элементов в mapZipCodes? Так как operator[] вставляет указанный ключ, если он не существует, myZip содержит пустую строку, а в mapZipCodes содержится один элемент. Это может оказаться нежелательно, но независимо от вашего желания помните, что operator[] не является const-методом: всегда есть вероятность того, что он изменит состояние map, добавив узел.
Метод insert предоставляет альтернативный метод добавления пар в отображение, insert выполняет строгую вставку, а не вставку/обновление, как operator[]. При использовании map (но не multimap, который может содержать дублирующиеся ключи) insert, если ключ уже существует, не делает ничего. По сравнению с ним operator[], если ключ уже существует, заменяет значение объекта для этого ключа на новое.
Но синтаксис вставки требует несколько большей работы, чем operator[], и он связан с тем, как map хранит данные. Рассмотрим строку из примера 6.6.
strMap.insert(std::make_pair("Sunday", "Sonntag"));
map хранит пары ключ/значение в объекте pair, pair — это простой вспомогательный шаблон класса (объявленный в <utility> и включенный в <map>), который хранит два значения двух типов. Чтобы объявить pair из двух string, сделайте так.
pair<string, string> myPair;
Первый и второй элементы в pair доступны по открытым членам first и second. При использовании для доступа к элементам map оператора operator[] обычно работать с pair не приходится, но в случае со многими другими методами это придется делать, так что следует знать, как создавать и использовать объекты pair. Например, итераторы разыменовываются в простые объекты pair, так что при их использовании, как это делается в примере 6.6, следует знать, как получить ключ и его значение.
for (map<string, string> iterator p = strMap.begin();
 p != strMap.end(); ++p)
 cout << "English: " << p->first
  << ", German: " << p->second << endl;
Ключ хранится в first, а значение хранится в second.
Однако это не объясняет, почему я использовал make_pair. make_pair — это вспомогательный шаблон функции, который создает объект pair на основе двух переданных в него аргументов. Некоторые предпочитают этот подход вызову конструктора pair, так как шаблон класса не может догадаться о типах своих аргументов, в то время как шаблон функции может. Таким образом, эти две строки кода функционально эквивалентны.
strMap.insert(std::make_pair("Sunday", "Sonntag"));
strMap.insert(std::pair<string, string>("Sunday", "Sonntag"));
map не допускает наличия дублирующихся ключей. Если требуется разрешить дублирование ключей, следует использовать multimap, который является map, разрешающим наличие несколько одинаковых ключей. Его интерфейс идентичен map, но поведение методов в необходимых случаях отличается. В табл. 6.1 приведен перечень методов, которые есть в одном, но отсутствуют в другом, и пояснения различий в поведении общих методов, map и multimap содержат несколько typedef, которые описывают различные значения, хранящиеся в них. В табл. 6.1 они используются следующим образом:
key_type
Это тип ключа. В string map, объявленном как map<string, MyClass*>, key_type должен быть string.
mapped_type
Это тип значения, на которое отображается ключ. В string map, объявленном как map<string, MyClass*>, mapped_type должен быть MyClass*.
value_type
Это тип объекта, содержащего ключ и значение, которой, применительно к map и multimap, является pair<const key_type, mapped_type>.
Табл. 6.1. map и multimap
Метод	map, multimap или оба	Поведение
T& operator[] (const key_type& k)	map	Возвращает ссылку на объект значения, сохраненный с ключом k. Если k в map отсутствует, то он добавляется, а объект значения создается с помощью конструктора по умолчанию
iterator insert(const value_type& v) pair<iterator, bool> insert(const value_type& v)	Оба	Первая версия вставляет v в multimap и возвращает итератор, который указывает на вставленную пару pair. Вторая версия вставляет v и map при условии, что в map еще не содержится ключа, равного v. Возвращаемая pair содержит итератор который указывает на вставленную pair, если произошла вставка, и bool, указывающий, была ли вставка успешной
iterator find(const key_type& k)	Оба	Возвращает итератор или const_iterator, который указывает на mapped_type, соответствующий k. В multimap не гарантируется, что возвращаемый итератор будет указывать на первое значение, соответствующее k. Если ключа, равного k, нет, то возвращаемый итератор равен end()
Также табл 6.1 показывает разницу в поведении между map и multimap.
Если operator[] вам не подходит, т.е. другой способ найти ключ в map. Для этого можно использовать метод find.
map<string, string>::const_iterator p
 = strMap.find("Thursday");
if (p != strMap.end())
 cout << "Thursday = " << p->second << endl;
Но не забудьте, что при использовании multimap не гарантируется, что возвращаемый элемент будет первым элементом с ключом, равным искомому. Если нужен первый элемент, чей ключ не меньше определенного значения или не больше определенного значения, используйте lower_bound или upper_bound. lower_bound возвращает итератор, указывающий на первую пару ключ/значение, равную или большую, чем аргумент key_type. Другими словами, если ваш map содержит дни недели, как в примере 6.6, следующий код вернет итератор, который указывает на пару, содержащую "Friday" и "Freitag".
p = strMap.lower_bound("Foo");
if (p != strMap.end())
 cout << p->first << " = " << p->second << endl;
Это происходит благодаря тому, что первый ключ больше или равен "Foo". upper_bound работает аналогично, но с противоположным условием.
В начале этого обсуждения я упоминал, что элементы в map хранятся в отсортированном по ключам порядке, так что при переборе от begin до end каждый элемент будет «больше», чем предшествующий (а в multimap — больше или равен ему) Но при использовании более сложных ключей, чем string или числа, может потребоваться указать, как при вставке элементов в отображение следует сравнивать ключи.
По умолчанию ключи хранятся с помощью стандартного функтора less (объявленного в <functional>). less — это двоичная функция (принимает два аргумента одинакового типа), которая возвращает bool, указывающий на то, больше ли первый аргумент, чем второй, или нет. Другими словами, less(a, b) возвращает a < b. Если это не то, что вам требуется, создайте свой собственный функтор и объявите map с его помощью. Например, если в качестве ключа используется объект Person и каждый Person имеет имя и фамилию, то может потребоваться сравнивать фамилии и имена. Пример 6.7 показывает способ сделать это.
Пример 6.7. Использование собственного функтора сортировки
#include <iostream>
#include <map>
#include <string>
using namespace std;
class Person {
 friend class PersonLessThan;
public:
 Person(const string& first, const string& last) :
  lastName_(last), firstName_(first) {}
 // ...
 string getFirstName() const {return(firstName_);}
 string getLastName() const {return(lastName_);}
private:
 string lastName_;
 string firstName_;
};
class PersonLessThan {
public:
 bool operator()(const Person& per1,
  const Person& per2) const {
  if (per1.lastName_ < per2. lastName_)      // Сравнить фамилии,
   return(true);                             // а затем
  else if (per1.lastName_ == per2.lastName_) // имена
   return(per1.firstName_ < per2.firstName_);
  else
   return(false);
 }
};
int main() {
 map<Person, string, PersonLessThan> personMap;
 Person per1("Billy", "Silly"),
  per2("Johnny", "Goofball"),
  per3("Frank", "Stank"),
  реr4("Albert", "Goofball");
 personMap[per1] = "cool";
 personMap[per2] = "not cool";
 personMap[per3] = "not cool";
 personMap[per4] = "cool";
 for (map<Person, string, PersonLessThan>::const_iterator p =
  personMap.begin(); p != personMap.end(); ++p) {
  cout << p->first.getFirstName() << " " << p->first.getLastName()
   << " is " << p->second << endl;
 }
}
map — это прекрасный способ хранить пары ключ/значение. После того как вы поймете поведение его частей, таких как operator[] и хранение данных (в виде объектов pair<Key, Value>), map предоставит простоту в использовании и высокую производительность.
Смотри также
Рецепт 6.7.
6.7. Использование хеш-контейнеров
Проблема
Требуется сохранить ключи и значения, обеспечив постоянное время доступа к элементам, и не требуется хранения элементов в упорядоченном виде.
Решение
Используйте один из связанных с хешами контейнеров — hash_map или hash_set. Однако помните, что они не входят в число стандартных контейнеров, определяемых стандартом С++, а представляют собой расширения, включаемые большинством реализаций стандартной библиотеки. Пример 6.8 показывает, как использовать hash_set.
Пример 6.8. Хранение строк в hash_set
#include <iostream>
#include <string>
#include <hash_set>
int main() {
 hash_set<std::string> hsString;
 string s = "bravo";
 hsString.insert(s);
 s = "alpha";
 hsString.insert(s);
 s = "charlie";
 hsString.insert(s);
 for (hash set<string>::const_iterator p = hsString.begin();
  p != hsString.end(); ++p)
  cout << *p << endl; // заметьте, что здесь не гарантируется хранение
                      // в упорядоченном виде
}
Обсуждение
Контейнеры, основанные на хешах, — это популярные во всех языках структуры данных, и прискорбно, что стандарт C++ не требует их реализации. Однако если требуется использовать хеш-контейнер, то не все потеряно: высока вероятность, что используемая вами реализация стандартной библиотеки содержит hash_map и hash_set, но тот факт, что они не стандартизованы, означает, что их интерфейсы могут отличаться от одной реализации стандартной библиотеки к другой. Я опишу хеш-контейнеры, которые поставляются в составе реализации стандартной библиотеки STLPort.
STLPort — это свободно распространяемая переносимая реализация стандартной библиотеки, существующая уже довольно длительное время и предоставляющая хеш-контейнеры. При использовании другой библиотеки интерфейс может быть другим, но общая идея будет той же самой.
Главной особенностью хеш-контейнеров (называемых во многих книгах по ассоциативными хеш-контейнерами) является то, что они в общем случае предоставляют постоянное время поиска, вставки и удаления элементов, а в худшем случае эти операции имеют линейное время. Ценой постоянного времени выполнения этих операций является то, что в хеш-контейнере они хранятся в неупорядоченном виде, как в map.
Посмотрите на пример 6.8. Использование хеш-контейнера (в данном случае hash_set) довольно просто — объявите его как большинство других контейнеров и начните вставлять в него элементы.
hash_set<string> hsString; // hash_set строк
string s = "bravo";
hsString.insert(s); // Вставка копии s
Использование hash_map аналогично, за исключением того, что требуется, как минимум, указать типы данных используемых ключей и значений. Это аналогично map.
hash_map<string, string>
hmStrings; // Отображение строк на строки
string key = "key";
string val = "val";
hmStrings[key] = val;
Это только основы использования хеш-контейнеров. Также имеется набор параметров шаблона, которые позволяют указать используемую хеш-функцию, функцию, проверяющую ключи на эквивалентность, и объект, используемый для распределения памяти. Я опишу их немного позже.
В большинстве библиотек есть четыре хеш-контейнера, и они похожи на другие ассоциативные контейнеры стандартной библиотеки (т.е. map и set). Это hash_map, hash_multimap, hash_set и hash_multiset. хеш-контейнеры реализуются с помощью хеш- таблицы. Хеш-таблица — это структура данных, которая обеспечивает постоянное время доступа к элементам, используя для этого хеш-функцию перехода к месту, близкому к хранению искомого объекта, а не проход по древовидной структуре. Разница между hash_map и hash_set состоит в том, как данные хранятся в хеш-таблице.
Объявления контейнеров, использующих хеш-таблицу, в STLPort выглядят так.
hash_map<Key,             // Тип ключа
 Value,                   // Тип значения,
                          // связанного с ключом
 HashFun = hash<Key>,     // Используемая хеш-функция
 EqualKey = equal_to<Key> // Функция, используемая для
                          // проверки равенства ключей
 Alloc = alloc>;          // Используемый распределитель памяти
hash_set<Key,              // Тип ключа
 HashFun = hash<Key>,      // Используемая хеш-функция
 EqualKey = equal_to<Key>, // Функция, используемая для
                           // проверки равенства ключей
 Alloc = alloc>;           // Используемый распределитель памяти
hash_map — это хеш-таблица, которая хранит значения как объекты pair<const Key, Data>. Это означает, что когда я буду далее описывать хеш-таблицы, «элементы» в таблице будут означать пары ключ/значение. hash_map не хранит ключи значение по отдельности (как и map). hash_set просто хранит ключ как значение.
Параметр шаблона HashFun — это функция, которая превращает объекты типа Key в значения, которые могут быть сохранены как size_t. Более подробно это описывается ниже. Параметр шаблона EqualKey — это функция, которая принимает два аргумента и, если они эквивалентны, возвращает true. В контейнерах hash_map и hash_set два ключа не могут быть равны, hash_multimap и hash_multiset могут содержать по нескольку одинаковых ключей. Как и в случае с другими контейнерами, Alloc — это используемый распределитель памяти.
Хеш-таблица содержит две части. В ней есть относительно большой вектор, где каждый индекс это «участок». Каждый из участков является на самом деле указателем на первый узел в относительно коротком одно- или двухсвязном списке (в STLPort — односвязном). Именно в этих списках и хранятся данные. Чтобы получить число участков в хеш-контейнере, используйте метод bucket_count. Рисунок 6.3 дает представление о том, как выглядит в памяти хеш-отображение.
Рис. 6.3. Хеш-таблица
Рассмотрим использование hash_set из примера 6.8. При вставке элемента контейнер вначале должен определить, к какому участку он относится. Это делается с помощью вызова хеш-функции контейнера, передачи в нее ключа (хеш-функция обсуждается немного позже) и вычисления остатка от деления значения на число участков. В результате получается индекс в векторе участков.
Если вы незнакомы с тем, что такое «хеширование», то это очень простая концепция. Если есть какое-то значение (скажем, массив типа char), то хеш-функция для него — это функция, которая принимает один аргумент и возвращает значение хеша типа size_t (т.е. число). В идеале требуется хеш-функция, которая генерирует уникальные значения хешей, но она не обязана это делать. Эта функция в математическом смысле неоднозначна: несколько строк типа string могут иметь одно и то же значение хеша. Далее я скажу, почему это не страшно.
STLPort включает в <hash_map> и <hash_set> такую хеш-функцию как шаблон функции. Однако эта функция не работает для любого объекта, так как невозможно создать общей хеш-функции, которая бы работала с любым вводом. Вместо этого имеется несколько специализированных встроенных типов, наиболее часто используемых для ключей в хеш-таблицах. Например, если требуется посмотреть, как выглядит значение хеша, хешируйте строку символов.
std::hash<const char*> hashFun;
std::cout << "\"Hashomatic\" хешируется как "
 << hashFun("Hashomatic") << '\n';
Вы увидите что-то похожее на следующее.
"Hashomatic" хешируется как 189555649
STLPort предоставляет специализации для следующих типов: char*, const char*, char, unsigned char, signed char, short, unsigned short, int, unsigned int, long и unsigned long. Кажется, что их очень много, но в целом это означает, что библиотека содержит встроенные хеш-функции, которые поддерживают символьные строки и числа. Если требуется хешировать что-то другое, то просто укажите собственную хеш-функцию.
При помещении элемента в хеш-таблицу она определяет, какому участку принадлежит элемент, используя оператор взятия остатка от деления и число участков, т.е. hashFun(key) % bucket_count(). Это быстрый оператор, который указывает непосредственно на индекс в главном векторе, по которому начинается участок.
Хеш-контейнер можно использовать как обычный ассоциативный контейнер, используя для добавления элементов в, скажем, hash_map оператор operator[]. Разница заключается в том, что вы знаете, что вставка и поиск займут постоянное время, а не логарифмическое. Рассмотрим пример 6.9, который содержит простой класс, отображающий имена логинов на объекты Session. Он использует некоторые из возможностей хеш-контейнеров, описываемых в этом рецепте.
Пример 6.9. Простой менеджер сессий
#include <iostream>
#include <string>
#include <hash_map>
using namespace std;
class Session { /* ... */ };
// Облегчение читаемости с помощью typedef
typedef hash_map<string, Session*> SessionHashMap;
class SessionManager {
public:
 SessionManager() : sessionMap_(500) {} // Инициализация хеш-таблицы
                                        // 500-ми участками
 ~SessionManager() {
  for (SessionHashMap::iterator p = sessionMap_.begin();
   p != sessionMap_.end(); ++p)
   delete (*p).second; // Удаление объекта Session
 }
 Session* addSession(const string& login) {
  Session* p = NULL;
  if (!(p = getSession(login))) {
   p = new Session();
   sessionMap_[login] = d; // Присвоение новой сессии с помощью
  }                        // operator[]
  return(p);
 }
 Session* getSession(const string& login) {
  return(sessionMap_[login]);
 }
 // ...
private:
 SessionHashMap sessionMap_;
};
Каждый ключ отображается на единственный участок, а в участке может храниться несколько ключей. Участок это обычно одно- или двухсвязный список.
По хеш-функциям и таблицам написано огромное количество книг. Если вы заинтересовались этим вопросом, поищите в Google «C++ hash function».
Смотри также
Рецепт 6.6.
6.8. Хранение объектов в упорядоченном виде
Проблема
Требуется сохранить набор объектов в заданном порядке, например с целью доступа к упорядоченным диапазонам этих объектов без их пересортировки при каждом таком обращении.
Решение
Используйте ассоциативный контейнер set, объявленный в <set>, который хранит элементы в упорядоченном виде. По умолчанию он использует стандартный шаблон класса less (который для своих аргументов вызывает operator<), а можно передать в него собственный предикат сортировки. Пример 6.10 показывает, как сохранить строки в set.
Пример 6.10. Хранение строк в set
#include <iostream>
#include <set>
#include <string>
using namespace std;
int main() {
 set<string> setStr;
 string s = "Bill";
 setStr.insert(s);
 s = "Steve";
 setStr.insert(s);
 s = "Randy";
 setStr.insert(s);
 s = "Howard";
 setStr.insert(s);
 for (set<string>::const_iterator p = setStr.begin();
  p != setStr.end(); ++p)
  cout << *p << endl;
}
Так как значения хранятся в упорядоченном виде, вывод будет выглядеть так.
Bill
Howard
Randy
Steve
Обсуждение
set (набор) — это ассоциативный контейнер, который предоставляет логарифмическую сложность вставки и поиска и постоянную сложность удаления элементов (если требуется удалить найденный элемент), set — это уникальный ассоциативный контейнер, что означает, что никакие два элемента не могут быть равны, однако если требуется хранить несколько экземпляров одинаковых элементов, используйте multiset, set можно представить как набор в математическом смысле, т.е. коллекцию элементов, в дополнение обеспечивающую поддержание определенного порядка элементов.
Поддерживаются вставка и поиск элементов, но, как и список, набор не позволяет производить произвольный доступ к элементам. Если требуется получить что-то из набора, то можно найти элемент с помощью метода find или перебрать элементы с помощью set<T>::iterator или set<T>::const_iterator. Объявление набора имеет знакомый вид.
set<typename Key,                       // Тип элемента
 typename LessThanFun = std::less<Key>, // Функция/Функтор
                                        // используемый для сортировки
 typename Alloc = std::allocator<Key> > // Распределитель памяти
Указывать Key требуется всегда, иногда требуется предоставить собственную LessThanFun, а указывать собственный распределитель требуется очень редко (так что я не буду здесь его описывать).
Параметр шаблона Key — это, как и в случае с другими стандартными контейнерами, тип сохраняемых элементов. Для set он определяется через typedef как set<Key>::key_type, так что доступ к нему есть при выполнении программы. Класс Key должен обеспечивать конструктор копирования и присвоение, и все.
Пример 6.10 показывает, как использовать set для строк. Использование набора для хранения объектов других типов работает точно так же — объявите набор с именем класса в качестве параметра шаблона.
std::set<MyClass> setMyObjs;
Это все, что требуется сделать для использования набора простейшим образом. Но в большинстве случаев жизнь не будет такой простой. Например, при сохранении в наборе указателей использовать предикат сортировки по умолчанию нельзя, так как он просто отсортирует объекты по их адресам. Чтобы гарантировать, что элементы будут отсортированы правильно, требуется создать собственный предикат, выполняющий сравнение «меньше чем». Пример 6.11 показывает, как это делается.
Пример 6.11. Хранение указателей в set
#include <iostream>
#include <set>
#include <string>
#include <functional>
#include <cassert>
using namespace std;
// Класс для сравнения строк, переданных через указатели
struct strPtrLess {
 bool operator()(const string* p1,
  const string* p2) {
  assert(p1 && p2);
  return(*p1 < *p2);
 }
 int main() (
  set<string*, strPtrLess> setStrPtr; // Передаем специальный
                                      // «меньше чем» функтор
 string s1 = "Tom";
 string s2 = "Dick";
 string s3 = "Harry";
 setStrPtr.insert(&s1);
 setStrPtr.insert(&s2);
 setStrPtr.insert(&s3);
 for (set<string*, strPtrLess>::const_iterator p =
  setStrPtr.begin(); p != setStrPtr.end(); ++p)
  cout << **p << endl; // Разыменовываем итератор и то, на что
                       // он указывает
}
strPtrLess возвращает истину, если строка, на которую указывает p1, меньше, чем та, на которую указывает p2. Это делает его двоичным предикатом, так как он принимает два аргумента и возвращает bool. Так как operator< определен для string, для сравнения я использую именно его. На самом деле, если требуется использовать более общий подход, используйте для предиката сравнения шаблон класса
template<typename T>
class ptrLess {
public:
 bool operator()(const T* p1,
  const T* p2) {
  assert(p1 && p2);
  return(*p1 < *p2);
 }
};
Это работает для указателей на любые объекты, для которых определен operator<. Объявление набора с его использованием имеет такой вид.
set<string*, ptrLess<string> > setStrPtr;
set поддерживает многие из функций, поддерживаемых другими стандартными последовательными контейнерами (например, begin, end, size, max_size) и другими ассоциативными контейнерами (например, insert, erase, clear, find).
При использовании set помните, что при каждом изменении состояния набора выполняется его сортировка. Когда число его элементов велико, логарифмическая сложность добавления или удаления элементов может оказаться очень большой — вам действительно требуется, чтобы объекты сортировались каждый раз? Если нет, то для повышения производительности используйте vector или list и сортируйте его только тогда, когда это необходимо, что обычно имеет сложность порядка n*log(n).
6.9. Хранение контейнеров в контейнерах
Проблема
Имеется несколько экземпляров стандартного контейнера (list, set и т.п.) и требуется сохранить их в еще одном контейнере.
Решение
Сохраните в главном контейнере указатели на остальные контейнеры. Например, можно использовать map для хранения ключа типа string и указателя на set как значения. Пример 6.12 показывает простой класс журналирования транзакций, который хранит данные как map из пар, состоящих из string и указателей на set.
Пример 6.12. Хранение набора указателей в отображении
#include <iostream>
#include <set>
#include <map>
#include <string>
using namespace std;
typedef set<string> SetStr
typedef map<string, SetStr*> MapStrSetStr;
// Фиктивный класс базы данных
class DBConn {
public:
 void beginTxn() {}
 void endTxn() {}
 void execSql(string& sql) {}
};
class SimpleTxnLog {
public:
 SimpleTxrLog() {}
 ~SimpleTxrLog() {purge();}
 // Добавляем в список выражение SQL
 void addTxn(const string& id
  const string& sql) {
  SetStr* pSet = log_[id]; // Здесь создается запись для
  if (pSet == NULL) {      // данного id, если ее еще нет
   pSet = new SetStr();
   log_[id] = pSet;
  }
  pSet->insert(sol);
 }
 // Применение выражений SQL к базе данных, по одной транзакции
 // за один раз
 void apply() {
  for (MapStrSetStr::iterator p = log_.begin();
   p != log_.end(); ++p) {
   conn_->beginTxn();
   // Помните, что итератор отображения ссылается на объект
   // типа pair<Key,Val>. Указатель на набор хранится в p->second.
   for (SetStr::iterator pSql = p->second->begin();
    pSql != p->second->end(); ++pSql) {
    string s = *pSql;
    conn_->execSql(s);
    cout << "Executing SQL: " << s << endl;
   }
   conn_->endTxn();
   delete p->second;
  }
  log_.clear();
 }
 void purge() {
  for (MapStrSetStr::iterator p = log_.begin();
   p != log_.end(); ++p)
   delete p->second;
  log_.clear();
 }
 //...
private:
 MapStrSetStr log_;
 DBConn* conn_;
};
Обсуждение
Пример 6.12 предлагает ситуацию, где может потребоваться хранение одного контейнера в другом. Представьте, что требуется сохранить набор выражений SQL в виде пакета, выполнить их в будущем все сразу для реляционной базы данных. Именно это делает SimpleTxnLog. Чтобы сделать его еще полезнее, можно добавить в него другие методы, а для обеспечения безопасности — добавить обработку исключений, но целью этого примера является показать, как хранить один тип контейнеров в другом.
Для начала я создаю несколько typedef, облегчающих чтение кода.
typedef std::set<std::string> SetStr;
typedef std::map<std::string, SetStr*> MapStrSetStr;
При использовании шаблонов шаблонов (шаблонов… и т.д.) объявления становятся очень длинными, что затрудняет их чтение, так что облегчите себе жизнь, использовав typedef. Более того, использование typedef облегчает внесение изменений в объявление шаблонов, избавляя от необходимости выполнять поиск и замену во многих местах большого количества исходных файлов.
Класс DBConn — это фиктивный класс, который представляет подключение к реляционной базе данных. Интересно здесь то, как в SimpleTxnLog определяется метод addTxn. В начале этой функции я смотрю, существует ли уже объект набора для переданного id.
SetStr* pSet = log_[id];
log_ — это map (см. рецепт 6.6), так что operator[] выполняет поиск id и смотрит, связаны ли с ним какие-либо данные. Если да, то возвращается объект данных, и pSet не равен NULL. Если нет, он создается, и возвращается указатель, который будет равен NULL. Затем я проверяю, указывает ли на что-то pSet, и определяю, требуется ли создать еще один набор.
if (pSet == NULL) {
 pSet = new SetStr(); // SetStr = std::set<std::string>
 log_[id] = pSet;
}
Так как pSet — это копия объекта данных, хранящихся в map (указатель на набор), а не само значение, то после создания set я должен поместить его обратно в связанный с ним ключ в map. После этого все, что остается сделать, — это добавить элемент в набор и выйти.
pSet->insert(sql);
Выполнив указанные шаги, я в один контейнер (map) добавил указатель на адрес другого контейнера (set). Что я не делал — это добавление объекта set в map. Разница очень существенна. Так как контейнеры обладают семантикой копирования, следующий код приведет к копированию всего набора s в map.
set<string> s;
// Заполнить s данными...
log_[id] = s; // Скопировать s и добавить его копию в log_
Это приведет к огромному числу дополнительных нежелательных копирований. Следовательно, общее правило при использовании контейнеров из контейнеров — это использовать указатели на контейнеры.
Глава 7
Алгоритмы
7.0. Введение
Эта глава рассказывает, как работать со стандартными алгоритмами и как использовать их для стандартных контейнеров. Эти алгоритмы первоначально являлись частью того, что часто называется Standard Template Library (STL — стандартная библиотека шаблонов) и представляет собой набор алгоритмов, итераторов и контейнеров, которые теперь вошли в стандартную библиотеку (глава 6 содержит рецепты по работе со стандартными контейнерами). Я их буду называть просто стандартными алгоритмами, итераторами и контейнерами, но не забывайте, что это то же самое, что другие авторы называют частью STL. Одним из базовых элементов стандартной библиотеки являются итераторы, так что первый рецепт описывает, что они собой представляют и как их использовать. После этого идет несколько рецептов, которые объясняют, как использовать и расширять стандартные алгоритмы. Наконец, если вы не нашли ничего подходящего в стандартной библиотеке, то рецепт 7.10 расскажет, как написать собственный алгоритм.
Представленные здесь рецепты в основном предназначены для работы со стандартными контейнерами, и тому есть две причины. Во-первых, стандартные контейнеры очень распространены, и лучше изучить стандарт, чем изобретать колесо. Во-вторых, реализация алгоритмов из стандартной библиотеки предоставляет хороший пример для подражания в смысле взаимодействия и производительности. Если вы посмотрите, как профессионалы выполнили код стандартной библиотеки, вы, скорее всего, узнаете много нового и полезного для себя.
Все стандартные алгоритмы используют итераторы. Даже если вы знакомы с концепцией итераторов, которые рассматриваются в первом рецепте, посмотрите на табл. 7.1, которая содержит перечень соглашений, используемых в остальных рецептах главы при демонстрации объявлений функций стандартных алгоритмов.
Табл. 7.1. Сокращения категорий итераторов
Сокращение	Значение
In	Input iterator (Итератор ввода)
Out	Output iterator (Итератор вывода)
Fwd	Forward iterator (Однонаправленный итератор)
Bid	Bidirectional iterator (Двунаправленный итератор)
Rand	Random-access iterator (Итератор произвольного доступа)
Стандартные алгоритмы также используют функциональные объекты, или функторы. Функциональный объект — это класс, который переопределяет operator() так, что его можно вызвать как функцию. Функтор, который возвращает bool (и не поддерживает состояния, и, следовательно, называется чистым (pure), называется предикатом (predicate), и он является еще одной обычной функциональной особенностью стандартных алгоритмов. Обычно предикат принимает один или два аргумента: если он принимает один аргумент, то это унарный предикат, а если два — то бинарный предикат. Для краткости я при демонстрации объявлений функций использую сокращения, приведенные в табл. 7.2.
Табл. 7.2. Типы функторов
Имя типа	Описание
UnPred	Унарный предикат. Принимает один аргумент и возвращает bool
BinPred	Бинарный предикат. Принимает два аргумента и возвращает bool
UnFunc	Унарная функция. Принимает один аргумент и возвращает некое значение
BinFunc	Бинарная функция. Принимает два аргумента и возвращает некое значение
В большинстве случаев там, где требуется аргумент в виде функтора, может использоваться указатель на функцию. При использовании термина «функтор» я также подразумеваю указатель на функцию, если не указано иного.
7.1. Перебор элементов контейнера
Проблема
Имеется диапазон итераторов — скорее всего, из стандартного контейнера — и стандартные алгоритмы не удовлетворяют вашим требованиям, так что вам требуется выполнить итерации самостоятельно.
Решение
Для доступа к элементам контейнера и перехода от одного элемента к другому используйте iterator или const_iterator. В стандартной библиотеке алгоритмы и контейнеры взаимодействуют с помощью итераторов, и одной из базовых идей стандартных алгоритмов является то, что они избавляют вас от необходимости непосредственного использования итераторов, за исключением тех случаев, когда вы пишете собственный алгоритм. И даже в этом случае вы должны понимать различные типы итераторов с тем, чтобы эффективно использовать стандартные алгоритмы и контейнеры. Пример 7.1 представляет некоторые простые способы использования итераторов.
Пример 7.1. Использование итераторов с контейнерами
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
using namespace std;
static const int ARRAY_SIZE = 5;
template<typename T, typename FwdIter>
FwdIter fixOutliersUBound(FwdIter p1,
 FwdIter p2, const T& oldVal, const T& newVal) {
 for ( ; p1 != p2; ++p1) {
  if (greater<T>(*p1, oldVal)) {
   *p1 = newVal;
  }
 }
}
int main() {
 list<string> lstStr;
 lstStr.push_back("Please");
 lstStr.push_back("leave");
 lstStr.push_back("a");
 lstStr.push_back("message");
 // Создать итератор для последовательного перебора элементов списка
 for (list<string>::iterator p = lstStr.begin();
  p != lstStr.end(); ++p) {
  cout << *p << endl;
 }
 // Или можно использовать reverse_iterator для перебора от конца
 // к началу, rbegin возвращает reverse_iterator, указывающий
 // на последний элемент, a rend возвращает reverse_iterator, указывающий
 // на один-перед-первым.
 for (list<string>::reverse_iterator p = lstStr.rbegin();
  p != lstStr.rend(); ++p) {
  cout << *p << endl;
 }
 // Перебор диапазона элементов
 string arrStr[ARRAY_SIZE] = {"My", "cup", "cup", "runneth", "over"};
 for (string* p = &arrStr[0];
  p != &arrStr[ARRAY_SIZE]; ++p) {
  cout << *p << endl;
 }
 // Использование стандартных алгоритмов со стандартной последовательностью
 list<string> lstStrDest;
 unique_copy(&arrStr[0], &arrStr[ARRAY_SIZE],
  back_inserter(lstStrDest));
}
Обсуждение
Итератор — это тип, который используется для ссылки на единственный объект в контейнере. Стандартные контейнеры используют итераторы как основной механизм для доступа к содержащимся в них элементам. Итератор ведет себя как указатель; для доступа к объекту, на который указывает итератор, вы его разыменовываете (с помощью операторов * или ->), а для перевода итератора вперед или назад используется синтаксис, аналогичный арифметике указателей. Однако есть несколько причин, по которым итератор — это не то же самое, что указатель. Однако перед тем, как я покажу их, давайте рассмотрим основы использования итераторов.
Использование итераторов
Итератор объявляется с помощью типа, элементы которого с его помощью будут перебираться. Например, в примере 7.1 используется list<string>, так что итератор объявляется вот так.
list<string>::iterator p = lstStr.begin();
Если вы не работали со стандартными контейнерами, то часть этого объявления ::iterator может выглядеть несколько необычно. Это вложенный в шаблон класса list typedef, предназначенный именно для этой цели — чтобы пользователи контейнера могли создать итератор для данного конкретного экземпляра шаблона. Это стандартное соглашение, которому следуют все стандартные контейнеры. Например, можно объявить итератор для list<int> или для set<MyClass>, как здесь.
list<int>::iterator p1;
set<MyClass>::iterator p2;
Возвращаясь обратно к нашему примеру, итератор о инициализируется первым элементом последовательности, который возвращается методом begin. Чтобы перейти к следующему элементу, используется operator++. Можно использовать как префиксный инкремент так и постфиксный инкремент (p++), аналогично указателям на элементы массивов, но префиксный инкремент не создает временного значения, так что он более эффективен и является предпочтительным. Постфиксный инкремент (p++) должен создавать временную переменную, так как он возвращает значение p до его инкрементирования. Однако он не может инкрементировать значение после того, как вернет его, так что он вынужден делать копию текущего значения, инкрементировать текущее значение, а затем возвращать временное значение. Создание таких временных переменных с течением времени требует все больших и больших затрат, так что если вам не требуется именно постфиксное поведение, используйте префиксный инкремент.
Как только будет достигнут элемент end, переход на следующий элемент следует прекратить. Или, строго говоря, когда будет достигнут элемент, следующий за end. В отношении стандартных контейнеров принято некое мистическое значение, которое представляет элемент, идущий сразу за последним элементом последовательности, и именно оно возвращается методом end. Этот подход работает в цикле for, как в этом примере:
for (list<string>::iterator p = lstStr.begin();
 p != lstStr.end(); ++p) {
 cout << *p << endl;
}
Как только p станет равен end, p больше не может увеличиваться. Если контейнер пуст, то begin == end равно true, и тело цикла никогда не выполнится. (Однако для проверки пустоты контейнера следует использовать метод empty, а не сравнивать begin и end или использовать выражение вида size == 0.)
Это простое объяснение функциональности итераторов, но это не все. Во-первых, как только что было сказано, итератор работает как rvalue или lvalue, что означает, что его разыменованное значение можно присваивать другим переменным, а можно присвоить новое значение ему. Для того чтобы заменить все элементы в списке строк, можно написать нечто подобное следующему
for (list<string>::iterator p = lstStr.begin();
 p != lstStr.end(); ++p) {
 *p = "mustard";
}
Так как *p ссылается на объект типа string, для присвоения элементу контейнера новой строки используется выражение string::operator=(const char*). Но что, если lstStr — это объект типа const? В этом случае iterator не работает, так как его разыменовывание дает не-const объект. Здесь требуется использовать const_iterator, который возвращает только rvalue. Представьте, что вы решили написать простую функцию для печати содержимого контейнера. Естественно, что передавать контейнер следует как const-ссылку.
template<typename T>
void printElements(const T& cont) {
 for(T::const_iterator p = cont.begin();
  p ! = cont.end(); ++p) {
  cout << *p << endl;
 }
}
В этой ситуации следует использовать именно const, a const_iterator позволит компилятору не дать вам изменить *p.
Время от времени вам также может потребоваться перебирать элементы контейнера в обратном порядке. Это можно сделать с помощью обычного iterator, но также имеется reverse_iterator, который предназначен специально для этой задачи. reverse_iterator ведет себя точно так же, как и обычный iterator, за исключением того, что его инкремент и декремент работают противоположно обычному iterator и вместо использования методов begin и end контейнера с ним используются методы rbegin и rend, которые возвращают reverse_iterator. reverse_iterator позволяет просматривать последовательность в обратном порядке. Например, вместо инициализации reverse_iterator с помощью begin он инициализируется с помощью rbegin, который возвращает reverse_iterator, указывающий на последний элемент последовательности. operator++ перемещает его назад — по направлению к началу последовательности, rend возвращает reverse_iterator, который указывает на элемент, находящийся перед первым элементом. Вот как это выглядит.
for (list<string>::reverse_iterator p = lstStr.rbegin();
 p != lstStr.rend(); ++p) {
 cout << *p << endl;
}
Но может возникнуть ситуация, когда использовать reverse_iterator невозможно. В этом случае используйте обычный iterator, как здесь.
for (list<string>::iterator p = --lstStr.end();
 p != --lstStr.begin(); --p) {
 cout << *p << endl;
}
Наконец, если вы знаете, на сколько элементов вперед или назад следует выполнить перебор, используйте вычисление значения, на которое следует перевести итератор. Например, чтобы перейти в середину списка, сделайте вот так.
size_t i = lstStr.size();
list<string>::iterator p = begin();
p += i/2; // Переход к середине последовательности
Но помните: в зависимости от типа используемого контейнера эта операция может иметь как постоянную, так и линейную сложность. При использовании контейнеров, которые хранят элементы последовательно, таких как vector или deque, iterator может перейти на любое вычисленное значение за постоянное время. Но при использовании контейнера на основе узлов, такого как list, такая операция произвольного доступа недоступна. Вместо этого приходится перебирать все элементы, пока не будет найден нужный. Это очень дорого. Именно поэтому выбор контейнера, используемого в каждой конкретной ситуации, определяется требованиями к перебору элементов контейнера и их поиска в нем. (За более подробной информацией о работе стандартных контейнеров обратитесь к главе 6.)
При использовании контейнеров, допускающих произвольный доступ, для доступа к элементам использования operator[] с индексной переменной следует предпочитать iterator. Это особенно важно при написании обобщенного алгоритма в виде шаблона функции, так как не все контейнеры поддерживают iterator с произвольным доступом.
С итератором можно делает еще много чего, но не с любым iterator. iterator может принадлежать к одной из пяти категорий, обладающих разной степенью функциональности. Однако они не так просты, как иерархия классов, так что именно это я далее и опишу.
Категории итераторов
Итераторы, предоставляемые различными типами контейнеров, не обязательно все умеют делать одно и то же. Например, vector<T>::iterator позволяет использовать для перехода на некоторое количество элементов вперед operator+=, в то время как list<T>::iterator не позволяет. Разница между этими двумя типами итераторов определяется их категорией.
Категории итераторов — это, по сути, интерфейс (не технически; для реализации категорий итераторов абстрактные базовые классы не используются). Имеется пять категорий, и каждая предлагает увеличение возможностей. Вот как они выглядят — от наименее до наиболее функциональной.
Input iterator (Итератор ввода)
Итератор ввода поддерживает переход вперед с помощью p++ или ++p и разыменовывание с помощью *p. При его разыменовывании возвращается rvalue, iterator ввода используется для таких вещей, как потоки, где разыменовывание итератора ввода означает извлечение очередного элемента из потока, что позволяет прочесть только один конкретный элемент.
Output iterator (Итератор вывода)
Итератор вывода поддерживает переход вперед с помощью p++ или ++p и разыменовывание с помощью *p. От итератора ввода он отличается тем, что из него невозможно читать, а можно только записывать в него — по одному элементу за раз. Также, в отличие от итератора ввода, он возвращает не rvalue, a lvalue, так что в него можно записывать значение, а извлекать из него — нельзя.
Forward iterator (Однонаправленный итератор)
Однонаправленный итератор объединяет функциональность итераторов ввода и вывода: он поддерживает ++p и p++, а *p может рассматриваться как rvalue или lvalue. Однонаправленный итератор можно использовать везде, где требуется итератор ввода или вывода, используя то преимущество, что читать из него и записывать в него после его разыменовывания можно без ограничений
Bidirectional iterator (Двунаправленный итератор)
Как следует из его названия, двунаправленный iterator может перемещаться как вперед, так и назад. Это однонаправленный iterator, который может перемещаться назад с помощью --p или p--.
Random-access iterator (Итератор произвольного доступа)
Итератор произвольного доступа делает все, что делает двунаправленный iterator, но также поддерживает операции, аналогичные операциям с указателями.. Для доступа к элементу, расположенному в позиции n после p последовательности, можно использовать p[n], можно складывать его значение или вычитать из него с помощью +, +=, - или -=, перемещая его вперед или назад на заданное количество элементов. Также с помощью <, >, <= или >= можно сравнивать два итератора p1 и p2, определяя их относительный порядок (при условии, что они оба относятся к одной и той же последовательности).
Или можно представить все в виде диаграммы Венна. Она представлена на рис. 7.1.
Рис. 7.1. Категории итераторов
Большая часть стандартных контейнеров поддерживает как минимум двунаправленный iterator, некоторые (vector и deque) предоставляют iterator произвольного доступа. Категория итератора, поддерживаемая контейнером, определяется стандартом.
В большинстве случае вы будете использовать iterator для простейших задач: поиск элемента и его удаление или что-либо подобное. Для этой цели требуется только однонаправленный iterator, который доступен для всех контейнеров. Но когда потребуется написать нетривиальный алгоритм или использовать алгоритм из стандартной библиотеки, часто потребуется нечто большее, чем простой однонаправленный iterator. Но как определить, что вам требуется? Здесь на сцену выходят категории итераторов.
Различные категории итераторов позволяют стандартным (и нестандартным) алгоритмам указать диапазон требуемой функциональности. Обычно стандартные алгоритмы работают с диапазонами, указываемыми с помощью итераторов, а не с целыми контейнерами. Объявление стандартного алгоритма говорит, какую категорию iterator он ожидает». Например, std::sort требует итераторов произвольного доступа, так как ему требуется за постоянное время ссылаться на несмежные элементы. Таким образом, объявление sort выглядит вот так.
template<typename RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
По имени типа итератора можно определить, что он ожидает итератор произвольного доступа. Если попробовать откомпилировать sort для категории итератора, отличной от произвольного доступа, то она завершится ошибкой, так как младшие категории iterator не реализуют операций, аналогичных арифметике с указателями.
Категория итератора, предоставляемая определенным контейнером и требуемая определенным стандартным алгоритмом, — это то, что определяет, какой алгоритм с каким контейнером может работать. Многие из стандартных алгоритмов описаны далее в этой главе. Таблица 7.1 показывает сокращения, используемые в остальной части главы для указания типов итераторов, принимаемых алгоритмами в качестве аргументов.
Этот рецепт описывал итераторы, как они используются для контейнеров. Но шаблон итераторов используется не только для контейнеров, и, таким образом, имеются другие типы итераторов. Имеются потоковые итераторы, итераторы буферов потоков и итераторы хранения в необработанном виде, но они здесь не описываются.
Смотри также
Глава 6.
7.2. Удаление объектов из контейнера
Проблема
Требуется удалить объекты из контейнера.
Решение
Для удаления одного или диапазона элементов используйте метод контейнера erase или один из стандартных алгоритмов. Пример 7.2 показывает пару различных способов удаления элементов из последовательностей.
Пример 7.2. Удаление элементов из контейнера
#include <iostream>
#include <string>
#include <list>
#include <algorithm>
#include <functional>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
int main() {
 list<string> lstStr;
 lstStr.push_back("On");
 lstStr.push_back("a");
 lstStr.push_back("cloudy");
 lstStr.push_back("cloudy");
 lstStr.push_back("day");
 list<string>::iterator p;
 // Найти то что требуется, с помощью find
 p = find(lstStr.begin(), lstStr.end(), "day");
 p = lstStr.erase(p); // Теперь p указывает на последний элемент
 // Или для удаления всех вхождений чего-либо используйте remove
 lstStr.erase(remove(lstStr.begin(), lstStr.end(), "cloudy"),
  listStr.end());
 printContainer(lstStr); // См. 7.10
}
Обсуждение
Для удаления одного или нескольких элементов из контейнера используйте метод erase. Все контейнеры содержат два перегруженных erase: один принимает единственный аргумент iterator, который указывает на элемент, который требуется удалить, а другой принимает два аргумента, которые представляют диапазон удаляемых элементов. Чтобы удалить один элемент, получите iterator, указывающий на этот элемент, и передайте этот iterator в erase, как в примере 7.2.
p = find(lstStr.begin(), lstStr.end(), "day");
p = lstStr.erase(p);
В результате объект, на который указывает p, будет удален, для чего будет вызван его деструктор, а после этого оставшиеся элементы будут реорганизованы. Реорганизация зависит от типа контейнера, и, следовательно, сложность этой операции от контейнера к контейнеру будет различаться. Сигнатура и поведение при использовании последовательного контейнера и ассоциативного контейнера также будут различаться.
В последовательностях erase возвращает iterator, который ссылается на первый элемент, следующий непосредственно за последним удаленным элементом, что может оказаться end, если был удален последний элемент последовательности. Сложность этой операции для каждого контейнера различна, так как последовательности реализованы по- разному. Например, из-за того, что все элементы vector хранятся в непрерывном фрагменте памяти, удаление из него элемента, кроме первого и последнего, с целью заполнения образовавшегося промежутка требует сдвига всех последующих элементов в сторону начала. Это приводит к значительному снижению производительности (в линейном отношении), и именно по этой причине не следует использовать vector, если требуется удалять (или вставлять, что в данном случае приводит к таким же последствиям) элементы где-либо, кроме концов. Более подробно этот вопрос обсуждается в рецепте 6.2.
В ассоциативных контейнерах erase возвращает void. При удалении одного элемента сложность имеет вид амортизированной константы, а при удалении диапазона — логарифмической зависимости плюс количество удаляемых элементов. Причина этого заключается в том, что ассоциативные контейнеры часто реализуются как сбалансированные деревья (например, красно-черное дерево).
erase удобен, но не интересен. Если требуется большая гибкость в выражении того, что требуется удалить, следует обратить внимание на стандартные алгоритмы (из <algorithm>). Рассмотрим такую строку из примера 7.2.
lstStr.erase(std::remove(lstStr.begin(), lstStr.end(), "cloudy"),
 lstStr.end());
Обратите внимание, что я использую erase, но на этот раз по какой-то причине мне требуется удалить из list<string> все вхождения слова «cloudy», remove возвращает iterator, который передается в erase как начало удаляемого диапазона, a end передается в erase как конечная точка диапазона. В результате удаляются все объекты obj (вызывая их метод delete) из диапазона, для которого obj == "cloudy" равно истине. Но поведение этой строки может оказаться не совсем таким, как ожидается. Здесь мне требуется пояснить некоторую терминологию.
remove на самом деле ничего не удаляет. Он перемещает все, что не равно указанному значению, в начало последовательности и возвращает iterator, который ссылается на первый элемент, следующий за этими перемещенными элементами. Затем вы должны вызвать erase для контейнера, чтобы удалить объекты между [p, end), где p — это iterator, возвращенный remove.
remove также имеет несколько вариантов. Что, если требуется удалить элементы, которые удовлетворяют некоторому предикату, а не просто равны какому-то значению? Используйте remove_if. Например, представьте, что есть класс с именем Conn, который представляет какой-то тип соединений. Если это соединение простаивает больше определенного значения, его требуется удалить. Во-первых, создайте функтор, как здесь.
struct IdleConnFn :
 public std::unary_function<const Conn, bool> { // Включите эту строку,
 bool operator() (const Conn& c) const {        // чтобы он работал с
  if (с.getIdleTime() > TIMEOUT) {              // другими объектами из
   return(true);                                // <functional>
  } else return(false);
 }
} idle;
Затем вызовите remove_if с erase и передайте в него новый функтор, как здесь.
vec.erase(std::remove_if(vec.begin(), vec.end(), idle), vec.end());
Есть причина, по которой такие функторы следует наследовать от unary_function, unary_function определяет несколько typedef, используемых другими функторами из <functional>, и если они их не найдут, то другие функторы не скомпилируются. Например, если вы очень злы и хотите удалить все не задействованные в данный момент соединения, то в функторе проверки на простой можно использовать функтор not1.
vec.erase(std::remove_if(vec.begin(), vec.end(); std::not1(idle)),
 vec.end());
Наконец, вам может потребоваться сохранить первоначальную последовательность (может, с помощью const) и скопировать результаты, кроме некоторых элементов, в новую последовательность. Это можно сделать с помощью remove_copy и remove_copy_if, которые работают аналогично remove и remove_if, за исключением того, что здесь также требуется передавать iterator вывода, в который будут записываться результирующие данные. Например, чтобы скопировать из одного списка в другой строку, сделайте так.
std::remove_copy(lstStr.begin(), lstStr.end(), lstStr2, "cloudy");
При использовании remove_copy или любого стандартного алгоритма, записывающего в выходной диапазон, следует помнить, что выходной диапазон должен уже быть достаточно большим, чтобы в нем поместились элементы, которые туда будут записываться.
erase и remove (и связанные с ними алгоритмы) предлагают удобный способ удалять определенные элементы последовательностей. Они предоставляют простую альтернативу самостоятельному перебору и поиску нужных элементов с последующим их удалением по одному.
Смотри также
Рецепты 6.2 и 7.1.
7.3. Случайное перемешивание данных
Проблема
Имеется последовательность данных и требуется перемешать их так, чтобы они были расположены в случайном порядке.
Решение
Используйте стандартный алгоритм random_shuffle, определенный в <algorithm>. random_shuffle принимает два итератора произвольного доступа и (необязательно) функтор генератора случайных чисел и реорганизует случайным образом элементы заданного диапазона. Пример 7.3 показывает, как это делается.
Пример 7.3. Случайное перемешивание последовательностей
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
int main() {
 vector<int> v;
 back_insert_iterator<std::vector<int> > p = back_inserter(v);
 for (int i = 0; i < 10; ++i) *p = i;
 printContainer(v, true);
 random_shuffle(v.begin(), v.end());
 printContainer(v, true);
}
Вывод должен выглядеть примерно так.
-----
0123456789
-----
8192057346
Обсуждение
random_shuffle очень прост в использовании. Дайте ему диапазон, и он перемешает этот диапазон случайным образом. Имеется две версии, и их прототипы выглядят так.
void random_shuffle(RndIter first, RndIter last);
void random_shuffle(RndIter first, RndIter last, RandFunc& rand);
В первой версии используется зависящая от реализации функция генерации случайных чисел, которой должно быть достаточно для большинства задач. Если ее недостаточно — например, требуется неоднородное распределение, такое, как гауссово — то можно написать собственную функцию, которую можно передать во вторую версию.
Этот генератор случайных чисел должен быть функтором с единственным аргументом, возвращающим единственное значение, и оба они должны преобразовываться в iterator_traits<RndIter>::difference_type. В большинстве случаев для этого подойдет целое число. Например, вот мой псевдогенератор случайных чисел.
struct RanNumGenFtor {
 size_t operator()(size_t n) const {
  return(rand() % n);
 }
} rnd;
random_shuffle(v.begin(), vend(), rnd);
Приложения random_shuffle ограничены последовательностями, которые предоставляют итераторы случайного доступа (string, vector и deque), массивами или собственными контейнерами, удовлетворяющими этому требованию. Перемешать случайным образом ассоциативный контейнер невозможно, так как его содержимое всегда хранится в упорядоченном виде. На самом деле для ассоциативных контейнеров не всегда можно использовать алгоритм, изменяющий его диапазон (и который часто называется видоизменяющим (mutating) алгоритмом).
7.4. Сравнение диапазонов
Проблема
Имеется два диапазона и требуется сравнить их на равенство или определить, какой из них меньше, чем другой, основываясь на каком-либо порядке сортировки элементов.
Решение
В зависимости от типа выполняемого сравнения используйте один из стандартных алгоритмов — equal, lexicographical_compare или mismatch, определенных в <algorithm>. Пример 7.4 показывает некоторые из них в действии.
Пример 7.4. Различные типы сравнения
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "utils.h"
using namespace std;
using namespace utils;
int main() {
 vector<string> vec1, vec2;
 vec1.push_back("Charles");
 vec1.push_back("in");
 vec1.push_back("Charge");
 vec2.push_back("Charles");
 vec2.push_back("in");
 vec2.push_back("charge"); // Обратите внимание на строчную "с"
 if (equal(vec1.begin(), vec1.end(), vec2.begin())) {
  cout << "Два диапазона равны!" << endl;
 } else {
  cout << "Два диапазона HE равны!" << endl;
 }
 string s1 = "abcde";
 string s2 = "abcdf";
 string s3 = "abc";
 cout << boolalpha // Отображает логические значения как "true" или "false"
  << lexicographical_compare(s1.begin(), s1.end(),
   s1.begin(), s1.end()) << endl;
 cout << lexicographical_compare(s1.begin(), s1.end(),
  s2.begin(), s2.end()) << endl;
 cout << lexicographical_compare(s2.begin(), s2.end(),
  s1.begin(), s1.end()) << endl;
 cout << lexicographical_compare(s1.begin(), s1.end(),
  s3.begin(), s3.end()) << endl;
 cout << lexicographical_compare(s3.begin(), s3.end(),
  s1.begin(), s1.end()) << endl;
 pair<string::iterator, string::iterator> iters =
  mismatch(s1.begin(), s1.end(), s2.begin());
 cout << "first mismatch = " << *(iters.first) << endl;
 cout << "second mismatch = " << *(iters.second) << endl;
}
Вывод примера 7.4 выглядит так.
Два диапазона НЕ равны!
false
true
false
false
true
first mismatch = e
second mismatch = f
Обсуждение
Для сравнения двух последовательностей на равенство используйте equal. Он принимает три или четыре аргумента, в зависимости от используемой версии. Вот как объявлен equal.
bool equal(In1 first1, In1 last1, In2 first2);
bool equal(In1 first1, In1 last1, In2 first2, BinPred pred);
equal с помощью operator== сравнивает каждый элемент между first1 и last1 с элементами, начиная с first2. Если указать pred, то equal для проверки будет использовать его. Перед вызовом equal убедитесь, что каждая последовательность имеет одинаковую длину. Он предполагает, что второй диапазон не меньше первого, и если это не так, то его поведение не определено.
Если требуется узнать, где и как последовательности отличаются, используйте lexicographical_compare или mismatch. lexicographical_compare сравнивает две последовательности и возвращает истину, если первая лексикографически меньше второй, что означает, что каждая пара элементов в двух последовательностях сравнивается с помощью оператора <. Объявление lexicographical_compare выглядит вот так.
bool lexicographical_compare(In1 first1, In1 last1,
 In2 first2, In2 last2);
bool lexicographical_compare(In1 first1, In1 last1,
 In2 first2, In2 last2, Compare comp);
Если operator< возвращает истину или первая последовательность заканчивается раньше второй, то возвращается истина. В противном случае возвращается ложь. Рассмотрим последовательность символов из примера 7.4.
string s1 = "abcde";
string s2 = "abcdf";
string s3 = "abc";
lexicographical_compare(s1.begin(), s1.end(), // abcde < abcde
 s1.begin(), s1.end());                       // = false
lexicographical_compare(s1.begin(), s1.end(), // abcde < abcdf
 s2.begin(s2.end());                          // = true
lexicographical_compare(s2.begin(), s2.end(), // abcdf < abcde
 s1.begin(), s1.end());                       // = false
lexicographical_compare(s1.begin(), s1.end(), // abcde < abc
 s3.begin(s3.end());                          // = false
lexicographical_compare(s3.begin(), s3.end(), // abc < abcde
 s1.begin(), s1.end());                       // = true
Сложность lexicographical_compare линейна и выполняет число сравнений, равное длине меньшей из двух последовательностей, или до тех пор, пока один из элементов в одной из последовательностей не окажется меньше соответствующего элемента другой. Сравнения реализованы полностью на основе operator<, так что если iter1 и iter2 — это итераторы двух последовательностей, то сравнение останавливается тогда, когда *iter1 < *iter2 или *iter2 < *iter1.
mismatch говорит, где две последовательности различаются. Однако его объявление несколько отличается от equal и lexicographical_compare, так как он возвращает не bool, a pair<> итераторов. Вот оно.
pair<In1, In2> mismatch(In1 first1, In1 last1, In2 first2);
pair<In1, In2> mismatch(In1 first1, In1 last1, In2 first2, BinPred);
Два возвращаемых итератора указывают на различные элементы каждой из последовательностей. Рассмотрим пример 7.4.
string s1 = "abcde";
string s2 = "abcdf";
pair<string::iterator, string::iterator> iters =
 mismatch(s1.begin(), s1.end(), s2.begin());
cout << "first mismatch = " << *(iters.first) << '\n'; // 'e'
cout << "second mismatch = " << *(iters.second) << '\n'; // 'f'
Вы должны убедиться, что длина второго диапазона не меньше первого. Если вторая последовательность короче первой, mismatch не сможет узнать этого и продолжит выполнение сравнения элементов за границей второй последовательности, что приведет к непредсказуемому поведению. Кроме того, если несовпадений нет, то первый итератор будет указывать на last1, который может оказаться недействительным (например, если в качестве last1 передать end().
Вы, должно быть, заметили по объявлениям каждой из этих функций, что типы итераторов для каждой из этих последовательностей различны. Это означает, что две последовательности могут быть контейнерами разных типов, но при условии, что типы элементов, на которые указывают итераторы, имеют определенный для них operator<. Например, можно сравнивать string и vector<char>.
string s = "Coke";
vector<char> v;
v.push.back('c');
v.push_back('o');
v.push_back('k');
v.push_back('e');
std::cout << std::lexicographical_compare(s.begin(), s.end(),
 v.begin(), v.end()) << '\n';
Здесь каждый символ двух последовательностей сравнивается вне зависимости от типа контейнера, в которых они хранятся.
Стандартная библиотека C++ предоставляет несколько различных способов сравнения последовательностей. Если ни один из них вам не подходит, посмотрите на их исходный код — он является хорошим примером того, как надо писать собственные эффективные обобщенные алгоритмы.
Смотри также
Рецепт 7.1.
7.5. Объединение данных
Проблема
Имеется две отсортированные последовательности и их требуется объединить.
Решение
Используйте либо шаблон функции merge, либо шаблон функции inplace_merge. merge объединяет две последовательности и помещает результат в третью, a inplace_merge объединяет две последовательно расположенные последовательности. Пример 7.5 показывает, как это делается.
Пример 7.5. Объединение двух последовательностей
#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <algorithm>
#include <iterator>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
int main() {
 vector<string> v1, v2, v3;
 v1.push_back("a");
 v1.push_back("c");
 v1.push_back("e");
 v2.push_back("b");
 v2.push_back("d");
 v2.push_back("f");
 v3.reserve(v1.size() + v2.size() + 1);
 // Используйте back_inserter от итератора, чтобы избежать необходимости
 // помещать в контейнер набор объектов по умолчанию. Но это не означает,
 // что не требуется использовать reserve!
 merge(v1.begin(), v1.end(), v2.begin(), v2.end(),
  back_inserter<vector<string> >(v3));
 printContainer(v3);
 // Теперь выполняем действия
 random_shuffle(v3.begin(), v3.end());
 sort(v3.begin(), v3.begin() + v3.size() / 2);
 sort(v3.begin() + v3.size() / 2, v3.end());
 printContainer(v3);
 inplace_merge(v3.begin(), v3.begin() + 3, v3.end());
 printContainer(v3);
 // Однако если используется два списка, используйте list::merge.
 // Как правило, ...
 list<string> lstStr1, lstStr2;
 lstStr1.push_back("Frank");
 lstStr1.push_back("Rizzo");
 lstStr1.push_back("Bill");
 lstStr1.push_back("Cheetoh");
 lstStr2.push_back("Allie");
 lstStr2.push_back("McBeal");
 lstStr2.push_back("Slick");
 lstStr2.push_back("Willie");
 lstStr1.sort(); // Отсортировать, иначе объединение выдаст мусор!
 lstStr2.sort();
 lstStr1.merge(lstStr2); // Заметьте, что это работает только для другого
                         // списка того же типа
 printContainer(lstStr1);
}
Вывод примера 7.5 выглядит так.
-----
a
b
с
d
e
f
-----
b
d
e
a
c
f
-----
a
b
с
d
e
f
Allie
Bill
Cheetoh
Frank
McBeal
Rizzo
Slick
Willie
Обсуждение
merge объединяет две последовательности и помещает результат в третью — опционально используя функтор сравнения, указанный пользователем и определяющий, когда один элемент меньше другого, а по умолчанию используя operator<. Сложность линейна: число выполняемых merge сравнений равно сумме длин двух последовательностей минус один. Типы элементов в обеих последовательностях должны быть сравниваемы с помощью operator< (или указанного вами функтора сравнения) и должны быть преобразуемы к типу элементов выходной последовательности при помощи конструктора копирования или присвоения; или должен быть определен оператор преобразования, определенный так, чтобы тип элементов выходной последовательности имел для обоих типов операторы присвоения и конструкторы копирования.
Объявления merge выглядят вот так
void merge(In1 first1, In1 last1, In2 first2, In2 last2, Out result);
void merge(In1 first1, In1 last1, In2 first2, In2 last2, Out result,
 BinPred comp)
Использование merge довольно просто. Обе последовательности должны быть отсортированы (иначе вывод будет представлять собой мусор), и ни одна из них при использовании merge не изменяется. Итератор вывода, в который помещаются результаты, должен иметь достаточно места для помещения в него числа элементов, равного сумме длин входных последовательностей. Этого можно добиться, явно зарезервировав достаточно места либо, как это сделано в примере 7.5, использовав back_inserter:
merge(v1.begin(), v1.end(), v2.begin(), v2.end(),
 back_inserter(v3));
back_inserter — это класс, определенный в <iterator>, который предоставляет удобный способ создания выходного итератора, который каждый раз, когда ему присваивается значение, вызывает для последовательности метод push_back. Таким образом, вам не требуется явно изменять размер выходной последовательности. Следующий вызов создает back_inserter для vector<string> с именем v3.
back_inserter(v3);
Указывать аргументы шаблона не требуется, так как back_inserter — это шаблон функции, а не класса, так что тип аргументов, с которыми он вызван, определяется автоматически. Эквивалентный вызов с явным указанием аргументов шаблона выглядит вот так.
back_inserter<vector<string> >(v3);
Однако заметьте, что иногда вам потребуется явно указывать размер выходной последовательности, особенно при использовании в качестве такой последовательности vector, vector при добавлении в него элементов с помощью push_back может потребовать изменений своего размера, а это очень дорогостоящая операция. За подробностями обратитесь к рецепту 6.2.
Если в последовательностях есть два одинаковых элемента, то элемент из первой последовательности будет предшествовать элементу из второй. Следовательно, если дважды вызвать merge, поменяв для второго вызова последовательности местами, результирующие выходные последовательности будут различаться (предсказуемо и правильно, но различаться).
Объединение двух list — это хороший пример ситуации, где можно использовать метод последовательности или аналогичный стандартный алгоритм. Следует предпочесть метод стандартному алгоритму, делающему то же самое, но это не всегда работает, и вот пример, который показывает, почему.
Рассмотрим список строк из примера 7.5:
lstStr1.sort(); // Сортируем, или объединение даст мусор!
lstStr2.sort(),
 lstStr1.merge(lstStr2); // Это list::merge
Есть две причины, по которым этот код отличается от вызова std::merge. Во-первых, оба списка list должны иметь один и тот же тип элементов. Это требование следует из объявления list::merge, которое имеет вид:
void merge(list<T, Alloc>& lst);
template <typename Compare>
void merge(list<T, Alloc>& lst, Compare comp)
Где T — это такой же тип, как и в самом шаблоне класса списка. Так что, например, невозможно объединить список из символьных массивов с завершающим нулем со списком из строк типа string.
Второе отличие состоит в том, что list::merge стирает входную последовательность, в то время как std::merge оставляет две входные последовательности неизменными. Скорее всего list::merge будет обладать лучшей производительностью, так как в большинстве случаев элементы списка не копируются, а перекомпонуются, но такая перекомпоновка не гарантируется, так что с целью выяснения реального поведения требуются эксперименты.
Также объединить две непрерывные последовательности можно с помощью inplace_merge. inplace_merge отличается от merge, так как он объединяет две последовательности «на месте». Другими словами, если есть две непрерывные последовательности (т.е. они являются частями одной и той же последовательности) и они отсортированы и требуется отсортировать общую последовательность, то вместо алгоритма сортировки можно использовать inplace_merge. Преимущество inplace_merge заключается в том, что при наличии достаточного объема памяти его работа занимает линейное количество времени. Если же памяти недостаточно, то он занимает n log n, что равно средней сложности сортировки.
Объявление inplace_merge несколько отличается от merge:
void inplace_merge(Bid first, Bid mid, Bid last);
void inplace_merge(Bid first, Bid mid, Bid last, BinPred comp)
inplace_merge требует двунаправленных итераторов, так что он не является взаимозаменяемым с merge, но в большинстве случаев должен работать. Как и merge, для определения относительного порядка элементов он по умолчанию использует operator<, а при наличии — comp.
7.6. Сортировка диапазона
Проблема
Имеется диапазон элементов, которые требуется отсортировать.
Решение
Для сортировки диапазонов имеется целый набор алгоритмов. Можно выполнить обычную сортировку (в восходящем или нисходящем порядке) с помощью sort, определенного в <algorithm>, а можно использовать одну из других функций сортировки, таких как partial_sort. Посмотрите на пример 7.6, показывающий как это сделать
Пример 7.6. Сортировка
#include <iostream>
#include <istream>
#include <string>
#include <list>
#include <vector>
#include <algorithm>
#include <iterator>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
int main() {
 cout << "Введите набор строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end; // Здесь создается "маркер"
 vector<string> v(start, end);
 // Стандартный алгоритм sort сортирует элементы диапазона. Он
 // требует итератор произвольного доступа, так что он работает для vector.
 sort(v.begin(), v.end());
 printContainer(v);
 random_shuffle(v.begin(), v.end()); // См. 7.2
 string* arr = new string[v.size()];
 // Копируем элементы в массив
 copy(v.begin(), v.end(), &arr[0]);
 // Сортировка работает для любого типа диапазонов, но при условии, что
 // ее аргументы ведут себя как итераторы произвольного доступа.
 sort(&arr[0], &arr[v.size()]);
 printRange(&arr[0], &arr[v.size()]);
 // Создаем список с такими же элементами
 list<string> lst(v.begin(), v.end());
 lst.sort(); // Самостоятельная версия sort работать не будет, здесь требуется
         // использовать list::sort. Заметьте, что невозможно отсортировать
         // только часть списка.
 printContainer(lst);
}
Запуск примера 7.6 может выглядеть вот так.
Введите набор строк: a z b y c x d w
^Z
-----
a b c d w x y z
-----
w b y c a x z d
-----
a b c d w x y z
-----
a b c d w x y z
Обсуждение
Сортировка — это очень часто выполняющаяся операция, и есть два способа отсортировать последовательность. Можно обеспечить хранение элементов в определенном порядке с помощью ассоциативного контейнера, но при этом длительность операции вставки будет иметь логарифмическую зависимость от размера последовательности. Либо можно сортировать элементы только по мере надобности с помощью sort, имеющей несколько опций.
Стандартный алгоритм sort делает именно то, что от него ожидается: он сортирует элементы диапазона в восходящем порядке с помощью operator<. Он объявлен вот так.
void sort(Rnd first, Rnd last);
void sort(Rnd first, Rnd last, BinPred comp);
Как и в большинстве других алгоритмов, если operator< не удовлетворяет вашим требованиям, можно указать собственный оператор сравнения. В среднем случае сложность имеет зависимость n log n. В худшем случае она может быть квадратичной.
Если требуется, чтобы одинаковые элементы сохранили свой первоначальный порядок, используйте stable_sort. Он имеет такую же сигнатуру, но гарантирует, что порядок эквивалентных элементов изменен не будет. Его сложность при наличии достаточного объема памяти в худшем случае составляет n log n. Если памяти недостаточно, то сложность может оказаться равной n(log n)².
Однако sort работает не для всех контейнеров. Он требует итераторов произвольного доступа, так что при использовании контейнера, не предоставляющего таких итераторов, он неприменим. Итераторы произвольного доступа предоставляют стандартные последовательные контейнеры deque, vector и string/wstring (которые не являются контейнерами, но удовлетворяют большинству требований к ним), list — это единственный, который такого итератора не предоставляет. Если требуется отсортировать список, используйте list::sort. Например, в примере 7.6 вы, вероятно, заметили, что list::sort не принимает никаких аргументов.
lst.sort();
Это отличает его от std::sort, с помощью которого можно отсортировать только часть последовательности. Если требуется отсортировать часть последовательности, то не следует использовать list.
Концепция сортировки очень проста, но есть несколько вариаций на тему ее реализации в стандартной библиотеке. Следующий перечень описывает эти вариации.
partial_sort
Принимает три итератора произвольного доступа — first, middle и last — и (необязательно) функтор сравнения. Он имеет два постусловия: элементы диапазона (first, middle) будут меньше, чем элементы диапазона (middle, last), и диапазон (first, middle) будет отсортирован с помощью operator< или указанного функтора сравнения. Другими словами, он сортирует только первые n элементов.
partial_sort_сору
Делает то же, что и partial_sort, но помещает результаты в выходной диапазон. Он берет первые n элементов из исходного диапазона и в соответствующем порядке копирует их в результирующий диапазон. Если результирующий диапазон (n) короче, чем исходный диапазон (m), то в результирующий диапазон копируется только n элементов.
nth_element
Принимает три итератора произвольного доступа — first, nth и last — и необязательный функтор сравнения. Он помешает элемент, на который ссылается nth, в то место, где он находился бы, если бы весь диапазон был отсортирован. Следовательно, все элементы диапазона (first, nth) будут меньше, чем элемент в позиции nth (те, что находятся в диапазоне (nth, last) не сортируются, но больше, чем те, что предшествуют nth). Этот алгоритм следует использовать тогда, когда требуется отсортировать только один или несколько элементов диапазона и избежать затрат на сортировку всего диапазона.
Также можно разделить элементы диапазона в соответствии с каким-либо критерием (функтором), и это является предметом обсуждения рецепта 7.7.
Смотри также
Рецепт 7.7.
7.7. Разделение диапазона
Проблема
Имеется диапазон элементов, которые требуется каким-либо образом разделить на группы. Например, необходимо переместить в начало диапазона все элементы, которые меньше определенного значения.
Решение
Для перемещения элементов используйте стандартный алгоритм partition с предикатом-функтором. См. пример 7.7.
Пример 7.7. Разделение диапазона
#include <iostream>
#include <istream>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include "utils.h" // Для printContainer(): см. рецепт 7.10
using namespace std;
int main() {
 cout << "Введите набор строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end; // Здесь создается "маркер"
 vector<string> v(start, end);
 // Реорганизуем элементы в v так, чтобы те, которые меньше,
 // чем "foo", оказались перед остальными.
 vector<string>::iterator p =
  partition(v.begin(), v.end(),
  bind2nd(less<string>(), "foo"));
 printContainer(v);
 cout << "*p = " << *p << endl;
}
Вывод примера 7.7 выглядит примерно так.
Введите набор строк: a d f j k l
^Z
-----
a d f j k l
*p = j
После работы partition итератор p указывает на первый элемент, для которого less(*p, "foo") не равно true.
Обсуждение
partition принимает начало и конец диапазона и предикат и перемешает все элементы, для которых предикат равен true, в начало диапазона. Он возвращает итератор, указывающий на первый элемент, для которого предикат не равен true, или на конец диапазона, если все элементы удовлетворяют предикату. Он объявлен вот так.
Bi partition(Bi first, Bi last, Pred pred);
pred — это функтор, который принимает один аргумент и возвращает true или false. Предиката по умолчанию не существует — вы должны указать такой предикат, который удовлетворяет требованию разделения диапазона. При этом можно написать свой предикат, а можно использовать один из предикатов стандартной библиотеки. Например, в примере 7.7 можно видеть, что я для создания функтора использовал less и bind2nd.
vector<string>::iterator p =
partition(v.begin(), v.end(),
bind2nd(less<string>(), "foo"));
Здесь все элементы, которые меньше "foo", перемещаются в начало последовательности. bind2nd здесь необязателен, но он удобен для автоматического создания функтора, который принимает один аргумент и возвращает результат вычисления less<string>(*i, "foo") для каждого i-го элемента последовательности. Если требуется, чтобы одинаковые элементы сохранили свой первоначальный порядок, то следует использовать stable_partition.
partition и другие алгоритмы, которые меняют порядок элементов диапазона, не работают со стандартными ассоциативными контейнерами set, multiset, map и multimap. Причиной этого является то, что ассоциативные контейнеры хранят свои элементы в упорядоченном виде и перемещать и удалять элементы разрешается только самим контейнерам. Использовать partition можно с любым диапазоном, для которого можно получить, по крайней мере, двунаправленный итератор, и это выполняется для всех стандартных последовательных контейнеров, включая deque, vector и list.
Смотри также
Рецепт 7.9.
7.8. Выполнение для последовательностей операций над множествами
Проблема
Имеются последовательности, которые требуется реорганизовать с помощью операций над множествами, таких как объединение (union), различие (difference) или пересечение (intersection).
Решение
Для этой цели используйте специальные функции стандартной библиотеки. set_union, set_difference и set_intersection. Каждая из них выполняет соответствующую операцию над множеством и помещает результат в выходной диапазон. Их использование показано в примере 7.8.
Пример 7.8. Использование операций над множествами
#include <iostream>
#include <algorithm>
#include <string>
#include <set>
#include <iterator>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
int main() {
 cout << "Введите несколько строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end;
 set<string> s1(start, end);
 cin.clear();
 cout << "Введите еще несколько строк: ";
 set<string> s2(++start, end);
 set<string> setUnion;
 set<string> setInter;
 set<string> setDiff;
 set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
  inserter(setUnion, setUnion.begin()));
 set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
  inserter(setDiff, setDiff.begin()));
 set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
  inserter(setInter,setInter.begin()));
 cout << "Объединение:\n";
 printContainer(setUnion);
 cout << "Различие:\n";
 printContainer(setDiff);
 cout << "Пересечение:\n";
 printContainer(setInter);
}
Вывод этой программы выглядит примерно так (printContainer просто печатает содержимое контейнера).
Введите несколько строк: a b c d
^Z
Введите еще несколько строк: d е f g
^Z
Объединение: a b с d e f g
Различие: a b c
Пересечение: d
Обсуждение
Операции с множествами в стандартной библиотеке выглядят и работают сходным образом. Каждая принимает два диапазона, выполняет свою операцию с ними и помешает результаты в выходной итератор. Вы должны убедиться, что для выходной последовательности имеется достаточно места, или использовать inserter или back_inserter (как использовать back_inserter, рассказывается в рецепте 7.5).
Объявление set_union выглядит вот так.
Out set_union(In first1, In last1, In first2, In last2, Out result);
Объявления set_difference, set_intersection и set_symmetric_difference выглядят точно так же.
Чтобы использовать эти функции, сделайте так, как показано в примере 7.8. Например, чтобы найти пересечение двух множеств, вызовите set_intersection вот так.
set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
 inserter(setInter, setInter.begin()));
Последний аргумент set_intersection требует некоторых пояснений, inserter — это шаблон функции, определенный в <iterator>, который принимает контейнер и итератор и возвращает выходной итератор, который при записи в него значения вызывает для первого аргумента inserter метод insert. При его использовании для последовательного контейнера он вставляет значения перед iterator, переданным в качестве второго аргумента. При его использовании для ассоциативного контейнера, как это делается в показанном выше фрагменте кода, этот итератор игнорируется, и элементы вставляются в соответствии с критерием сортировки контейнера.
set — это удобный пример для наших целей, но операции над множествами работают для любых последовательностей, а не только для set. Например, операции над множествами можно выполнить для list:
list<string> lst1, lst2, lst3;
// Заполняем их данными
lst1.sort(); // Элементы должны быть отсортированы
lst2.sort();
set_symmetric_difference(lst1 begin(), lst1.end(),
lst2.begin(), lst2.end(), back_inserter(lst3));
Однако так как list хранит данные в неотсортированном виде, его вначале требуется отсортировать иначе результаты операций над множествами будут неверными. Также обратите внимание, что в этом примере вместо inserter используется back_inserter. back_inserter работает аналогично inserter, за исключением того, что для добавления элементов в контейнер он использует push_back. Вы не обязаны действовать точно так же. Например, можно изменить размер выходного контейнера так, чтобы он стал достаточно большим
lst3.resize(lst1.size() + lst2.size()),
set_symmetric_difference(lst1.begin(), lst1.end(),
 lst2.begin(), lst2.end(), lst3.begin());
Если выходная последовательность будет достаточно большой, то можно просто передать итератор, указывающий на первый элемент последовательности, используя begin.
Если вы не знаете, что такое set_symmetric_difference, я вам расскажу. Это объединение разностей двух множеств, определенных в прямом и обратном порядке. Это значит, что если а и b — это множества, то симметричная разность — это а - b b - а. Другими словами, симметричная разность — это множество всех элементов, которые присутствуют в одном из множеств, но отсутствуют в другом.
Есть еще один момент, который следует знать при работе с операциями над множествами. Так как последовательности не обязаны быть уникальными, можно получить «множество» с повторяющимися значениями. Конечно, строго математически множество не может содержать повторяющиеся значения, так что этот момент может быть не очевиден, Рассмотрим, как будет выглядеть вывод примера 7.8, если вместо set использовать list (при запуске примера 7.8 можно вводить повторяющиеся значения, но они не будут добавлены в set, так как set::insert не выполняется для элементов, которые уже присутствуют в set).
Введите несколько строк: a a a b с с
^Z
Введите еще несколько строк: a a b b с
^Z
Объединение a a a b b с с
Различие: a c
Пересечение: a a b с
Здесь операции над множествами перебирают обе последовательности и сравнивают соответствующие значения, определяя, что следует поместить в выходную последовательность.
Наконец, операции над множествами в их оригинальном виде (использующие для сравнения элементов operator<) могут не работать так, как вам требуется, если последовательности содержат указатели. Чтобы обойти эту проблему, напишите функтор, который сравнивает объекты указателей, как в рецепте 7.4.
Смотри также
Рецепт 7.4.
7.9. Преобразование элементов последовательности
Проблема
Имеется последовательность элементов, и с каждым элементом требуется выполнить какие-либо действия — либо на месте, либо скопировав их в другую последовательность.
Решение
Используйте стандартные алгоритмы transform или for_each. Они оба просты, но позволяют выполнить почти любые действия с элементами последовательностей. Пример 7.9 показывает, как это делается.
Пример 7.9. Преобразование данных
#include <iostream>
#include <istream>
#include <string>
#include <list>
#include <algorithm>
#include <iterator>
#include <cctype>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
// Преобразуем строки к верхнему регистру
string strToUpper(const string& s) {
 string tmp;
 for (string::const_iterator p = s.begin(); p != s.end(); ++p)
  tmp += toupper(*p);
 return(tmp);
}
string strAppend(const string& s1, const string& s2) {
 return(s1 + s2);
}
int main() {
 cout << "Введите несколько строк: ";
 istream_iterator<string> start(cin);
 istream iterator<string> end;
 list<string> lst(start, end), out;
 // Используем преобразование с помощью унарной функции...
 transform(lst.begin(), lst.end(), back_inserter(out),
  strToUpper);
 printContainer(out);
 cin.clear();
 cout << Введите другой набор строк: ";
 list<string> lst2(++start, end);
 out.clear();
 // ...или бинарную функцию и другую входную последовательность
 transform(lst.begin(), lst.end(), lst2.begin(),
  back_inserter(out), StrAppend);
 printContainer(out);
}
Обсуждение
Очевидно, что для преобразования данных используется transform. Он имеет две формы. Первая форма принимает последовательность, итератор вывод и унарный функтор. Он применяет функтор к каждому элементу последовательности и присваивает возвращаемое значение следующему значению, на которое указывает итератор вывода. Итератор вывода может быть другой последовательностью или началом оригинальной последовательности. В этом отношении transfоrm может выполнять преобразование как «на месте», так и копируя результат в другую последовательность.
Вот как выглядит объявление transform.
Out transform(In first, In last, Out result, UnFunc f);
Out transform(In first1, In last1, In first2, In last2,
 Out result, BinFunc f);
Обе версии возвращают итератор, который указывает на один после конца результирующей последовательности.
Использование обеих версий очень просто. Чтобы скопировать строку из одной последовательности в другую, но с преобразованием ее к верхнему регистру, сделайте так, как в примере 7.9.
std::transform(lst.begin(), lst.end(),
 std::back_inserter(out), strToUpper);
Если требуется изменить первоначальную последовательность, просто передайте в качестве результирующего итератора начало этой последовательности.
std::transform(lst.begin(), lst.end(),
 lst.begin(), strToUpper);
Использование двух последовательностей и бинарной операции работает точно так же. и в качестве выходной последовательности можно использовать одну из входных.
Если требуется преобразовать элементы на месте, можно избежать накладных расходов на присвоение каждому элементу возвращаемого значения некоторой функции. Или, если функтор, который требуется использовать, изменяет свой объект-источник, то можно использовать for_each.
void strToUpperInPlace(string& s) {
 for (string::iterator p = s.begin(); p != s.end(); ++p)
  *p = std::toupper(*p);
}
// ...
std::for_each(lst.begin(), lst.end(), strToUpperInPlace);
Если же все, что требуется сделать, — это изменить саму последовательность, не изменяя каждый из ее элементов, то в рецепте 7.6 описывается множество стандартных алгоритмов для реорганизации элементов в последовательностях.
Смотри также
Рецепты 7.1 и 7.6.
7.10. Написание собственного алгоритма
Проблема
Для диапазона требуется выполнить алгоритм, и ни один из стандартных алгоритмов не удовлетворяет требованиям.
Решение
Напишите алгоритм в виде шаблона функции и с помощью имен параметров шаблона укажите свои требования к итератору. В примере 7.10 показан измененный стандартный алгоритм сору.
Пример 7.10. Написание собственного алгоритма
#include <iostream>
#include <istream>
#include <iterator>
#include <string>
#include <functional>
#include <vector>
#include <list>
#include "utils.h" // Для printContainer(): см. 7.10
using namespace std;
template<typename In, typename Out, typename UnPred>
Out copyIf(In first, In last, Out result, UnPred pred) {
 for ( ; first != last; ++first)
  if (pred(*first)) *results = *first;
 return(result);
}
int main() {
 cout << "Введите несколько строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end; // Здесь создается "маркер"
 vector<string> v(start, end);
 list<string> lst;
 copyIf(v.begin(), v.end(), back_inserter<list<string> >(lst),
  bind2nd(less<string>(), "cookie"));
 printContainer(lst);
}
Запуск примера 7.10 будет выглядеть примерно так.
Введите несколько строк: apple banana danish eclaire
^Z
-----
apple banana
Вы видите, что он копирует в результирующий диапазон только те значения, которые меньше, чем «cookie».
Обсуждение
Стандартная библиотека содержит шаблон функции сору, который копирует элементы из одного диапазона в другой, но нет стандартной версии, которая принимает предикат и выполняет условное копирование элементов (т.е. алгоритм copy_if), так что пример 7.10 делает именно это. Его поведение довольно просто: при наличии диапазона-источника и начала диапазона-приемника производится копирование в целевой диапазон элементов, для которых унарный функтор-предикат возвращает true.
Этот алгоритм прост, но в его реализации есть еще кое-что, что привлекает внимание. Посмотрев на объявление, вы увидите, что в нем присутствует три параметра шаблона.
template<typename In, typename Out, typename UnPred>
Out copyIf(In first, In last, Out result UnPred pred) {
Первый параметр шаблона In — это тип входного итератора. Так как это входной диапазон, все, что должен иметь возможность сделать с ним copyIf, — это извлечь разыменованное значение этого итератора и перевести итератор на следующий элемент. Это дает описание категории итератора ввода (категории итераторов описаны в рецепте 7.1), так что с помощью указания имени параметра шаблона In мы объявляем именно этот тип итератора. Стандартного соглашения здесь нет (In и Out — это мои соглашения, которые я описал в первом рецепте этой главы), но вы легко можете придумать свои собственные соглашения об именах: InIter, Input_T или даже InputIterator. Второй параметр шаблона Out — это тип итератора, который указывает на диапазон, в который будут копироваться элементы, copyIf должен иметь возможность записать разыменованное значение в выходной итератор и увеличить его значение, что дает нам описание оператора вывода. Объявив требования к итераторам с помощью имен параметров шаблона, вы делаете соглашения о вызовах алгоритма понятными без документации. Но зачем использовать две разные категории итераторов?
Имеется, по крайней мере, две причины использования в copyIf двух различных категорий итераторов. Во-первых, операции с каждым диапазоном несколько отличаются друг от друга, и так как мне никогда не потребуется возвращаться назад по входному диапазону или присваивать ему значения, все, что мне требуется, — это итератор ввода. Аналогично мне никогда не потребуется читать из выходного диапазона, так что все, что здесь требуется, — это итератор вывода. Имеются требования к каждому из итераторов, которые не применимы к другому итератору, так что нет никакого смысла использовать для обоих диапазонов, например, два двунаправленных итератора. Во-вторых, использование различных типов итераторов позволяет вызывающему коду читать из одного типа диапазона и записывать в другой. В примере 7.10 я читаю из vector и записываю в list.
vector<string> v(start, end);
list<string> lst;
copyIf(v.begin(), v.end(), back_inserter<list<string> >(lst),
 bind2nd(less<string>(), "cookie"));
Если попробовать сделать то же самое, использовав в алгоритме один и тот же тип итераторов, то он просто не скомпилируется.
В примере 7.10 я в качестве начала выходного диапазона передаю back_inserter, а не, скажем, итератор, возвращаемый lst.begin. Это делается потому, что lst не содержит элементов, и в этом алгоритме (как и в стандартном алгоритме копирования) целевой диапазон должен быть достаточно большим, чтобы вместить все элементы, которые будут в него скопированы. В противном случае увеличение итератора вывода в copyIf приведет к неопределенному поведению. back_inserter возвращает итератор вывода, который при его увеличении вызывает для контейнера метод push_back. В результате этого при каждом увеличении выходного итератора размер lst увеличивается на один. Более подробно шаблон класса back_inserter я описываю в рецепте 7.5.
При написании собственного алгоритма для работы с диапазонами (т.е. со стандартными контейнерами) вы должны работать с аргументами-итераторами, а не с аргументами-контейнерами. У вас может возникнуть желание объявить copyIf так, чтобы он принимал два контейнера, а не итератор исходного и результирующего диапазонов, но это менее обобщенное решение, чем диапазоны. Во-первых, если передавать аргументы-контейнеры, то станет невозможно работать с подмножеством элементов контейнера. Далее, в теле copyIf появится зависимость от методов контейнеров begin и end, которые дадут требуемый диапазон, и возвращаемый тип будет зависеть от типа контейнера, используемого в качестве выходного. Это означает, что использование в copyIf нестандартных диапазонов, таких как встроенные массивы или собственные контейнеры, работать не будет. Именно по этим и некоторым другим причинам все стандартные алгоритмы оперируют с диапазонами.
Наконец, если вы пишете свой алгоритм, дважды убедитесь, что стандартные алгоритмы вас не устраивают. На первый взгляд они могут казаться очень простыми алгоритмами, но их кажущаяся простота проистекает из их обобщенности, и в девяти случаях из десяти их можно расширить так, что они подойдут для новых задач. Иногда следует стремиться к повторному использованию стандартных алгоритмов, так как это дает гарантию переносимости и эффективности.
Смотри также
Рецепт 7.5.
7.11. Печать диапазона в поток
Проблема
Имеется диапазон элементов, который требуется напечатать в поток, например, в cout с целью отладки.
Решение
Напишите шаблон функции, который принимает диапазон или контейнер, перебирает все его элементы и использует алгоритм сору и ostream_iterator для записи. Если требуется дополнительное форматирование, напишите свой простой алгоритм, который перебирает диапазон и печатает каждый элемент в поток. (См. пример 7.11)
Пример 7.11. Печать диапазона в поток
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;
int main() {
 // Итератор ввода - это противоположность итератору вывода: он
 // читает элементы из потока так. как будто это контейнер.
 cout << "Введите несколько строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end;
 vector<string> v(start, end);
 // Используем выходной поток как контейнер, используя
 // output_iterator. Он создает итератор вывода, для которого запись
 // в каждый элемент эквивалентна записи в поток.
 copy(v.begin(), v.end(), ostreamIterator<string>(cout, ", "));
}
Вывод примера 7.11 может выглядеть так.
Введите несколько строк: z x y a b с
^Z
z, x, y, a, b, с,
Обсуждение
Потоковый итератор — это итератор, который основан на потоке, а не на диапазоне элементов контейнера, и позволяет рассматривать поток как итератор ввода (читать из разыменованного значения и увеличивать итератор) или итератор вывода (аналогично итератору ввода, но для записи в разыменованное значение вместо чтения из него). Это облегчает чтение значений (особенно строк) из потока, что делается в нескольких других примерах этой главы, и запись значений в поток, что делается в примере 7.11. Я знаю, что этот рецепт посвящен записи диапазона в поток, но позвольте мне немного отойти от этой задачи и, поскольку я использую потоковые итераторы во многих примерах этой главы, объяснить, что это такое.
В примере 7.11 показаны три ключевые части istream_iterator. Первая часть — это создание istream_iterator, указывающего на начало потокового ввода. Это делается вот так.
istream_iterator<string> start(cin);
В результате создается итератор с именем start, который указывает на первый элемент входной последовательности, точно так же, как vec.begin (vec — это vector) возвращает итератор, который указывает на первый элемент в векторе. Аргумент шаблона string говорит istream_iterator, что элементы в этой последовательности имеют тип string. Аргумент конструктора cin — это входной поток, из которого производится чтение. Однако это абстракция, так как первого элемента не существует, поскольку из cin еще ничего прочитано не было. Это произойдет несколько позже.
Вторая часть итератора входного потока — это маркер конца, который создается вот так.
istream_iterator<string> end;
Стандартные контейнеры используют специальное значение «один после конца», указывающее на точку, где должно остановиться использование алгоритма. Так как итератор входного потока не имеет в памяти последнего элемента, он для создания логической конечной точки, представляющей точку остановки использования алгоритма, использует конструктор без аргументов.
Последней частью методики использования istream_iterator является его использование для извлечения значений. Удобным способом вытащить в контейнер все значения, введенные в поток, является использование конструктора диапазона контейнера. Например, если создать vector с двумя итераторами, то его конструктор скопирует в контейнер все элементы диапазона, определяемого итераторами. Если передать только что созданные итераторы start и end, то это будет выглядеть так.
vector<string> v(start, end);
Именно здесь происходит чтение значений из потока. При создании v он начинает со start и перебирает все значения, пока не достигнет end. Каждый раз, когда v читает из *start, происходит нечто эквивалентное такому вызову cin.
cin >> v[i]; // v - это vector<string>
Другими словами, следующее значение, извлекаемое из cin, преобразуется в string и вставляется в vector.
При использовании cin как входного потока маркер конца файла, который отмечает конец потока, определяется используемой платформой. В Windows для завершения входного потока требуется нажать на Enter, Ctrl-Z, Enter. Чтобы увидеть, что требуется сделать на вашей платформе, проведите эксперименты, но велика вероятность, что будут использоваться эти же клавиши.
Итераторы выходных потоков ведут себя аналогично итераторам потоков ввода. В примере 7.11 я копирую значения из своего vector в cout, создав для этого ostream_iterator, который указывает на cout, следующим образом.
copy(v.begin(), v.end(), ostream_iterator<string>(cout, ", "));
Аргумент шаблона ostream_iterator говорит, что записываемые элементы будут иметь тип string. Первый аргумент конструктора ostream_iterator — это поток, в который будет производиться запись (и который может быть любым потоком вывода, включая ofstream и ostringstream), а второй это используемый разделитель. Это дает удобный способ выводить диапазон значений на стандартный вывод, что я часто делаю при отладке.
Если требуется дополнительное управление внешним видом вывода, например вывод последовательности в квадратных или фигурных скобках или отсутствие последнего разделителя в конце последовательности, то это потребует всего нескольких дополнительных строк кода. Пример 7.12 показывает тело printContainer и printRange, первая из которых используется в примерах этой главы.
Пример 7.12. Написание собственной функции печати
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;
template<typename C>
void printContainer(const C& c, char delim = ',', ostream& out = cout) {
 printRange(c.begin(), c.end(), delim, out);
}
template<typename Fwd>
void printRange(Fwd first, Fwd last, char delim = ',', ostream& out = cout) {
 out << "{";
 while (first != last) {
  out << *first;
  if (++first != last)
   out << delim << ' ';
 }
 out << "}" << endl;
}
int main() {
 cout << "Введите набор строк: ";
 istream_iterator<string> start(cin);
 istream_iterator<string> end;
 vector<string> v(start, end);
 printContainer(v);
 printRange(v.begin(), v.end(), ';', cout);
}
Функция printRange представляет собой более общий подход, так как оперирует с диапазонами (более подробно это объясняется в рецепте 7.10), но printContainer более удобна для печати целого контейнера. Имеется множество других способов сделать это. В голову также приходит определение версии operator<<, которая бы работала с выходным потоком и контейнером, и использование стандартного алгоритма for_each с собственным функтором для записи элементов в поток.
Глава 8
Классы
8.0. Введение
Эта глава содержит решения проблем, часто возникающих при работе с классами С++. Рецепты по большей части независимы, но разбиты на две части, каждая из которых занимает примерно по половине главы. Первая половина главы содержит решения проблем, которые могут возникнуть при создании объектов классов, таких как использование функции для создания объекта (которая часто называется шаблоном фабрики) или использование конструкторов и деструкторов для управления ресурсами. Вторая половина содержит решения проблем, возникающих после создания объектов, таких как определение типа объекта во время выполнения, а также некоторые методики реализации наподобие создания интерфейса с помощью абстрактного базового класса.
Конечно, классы — это главная особенность С++, которая обеспечивает возможность объектно-ориентированного программирования, и с ними можно выполнять очень много разных действий. Эта глава не содержит рецептов, объясняющих основы классов: виртуальные функции (полиморфизм), наследование и инкапсуляцию. Я полагаю, что вы уже знакомы с этими основными принципами объектно-ориентированного проектирования независимо от используемого языка программирования. Напротив, целью этой главы является описание принципов некоторых механических сложностей, с которыми можно столкнуться при реализации объектно-ориентированного дизайна на С++.
Объектно-ориентированное проектирование и связанные с ним шаблоны проектирования — это обширный вопрос, и имеется большое количество различной литературы на эту тему. В этой главе я упоминаю названия только некоторых шаблонов проектирования, и это шаблоны, для которых возможности C++ обеспечивают элегантное или, возможно, не совсем очевидное решение. Если вы не знакомы с концепцией шаблонов проектирования, я рекомендую прочесть книгу Design Patterns (Addison Wesley), поскольку это полезная вещь при разработке программного обеспечения. Однако для этой главы знание шаблонов проектирования не требуется.
8.1. Инициализация переменных-членов класса
Проблема
Требуется инициализировать переменные-члены, которые имеют встроенные типы, являются указателями или ссылками.
Решение
Для установки начальных значений переменных членов используйте список инициализации. Пример 8.1 показывает, как это делается для встроенных типов, указателей и ссылок.
Пример 8.1. Инициализация членов класса
#include <string>
using namespace std;
class Foo {
public:
 Foo() : counter_(0), str_(NULL) {}
 Foo(int c, string* p) : counter_(c), str_(p) {}
private:
 int counter_;
 string* str_;
};
int main() {
 string s = "bar";
 Foo(2, &s);
}
Обсуждение
Переменные встроенных типов следует всегда инициализировать, особенно если они являются членами класса. С другой стороны, переменные класса должны иметь конструктор, который корректно инициализирует их состояние, так что самостоятельно инициализировать их не требуется. Сохранить неинициализированное состояние переменных встроенных типов, когда они содержат мусор, — значит напрашиваться на проблемы. Но в C++ есть несколько различных способов выполнить инициализацию, и они описываются в этом рецепте.
Простейшими объектами инициализации являются встроенные типы. Работать с int, char и указателями очень просто. Рассмотрим простой класс и его конструктор по умолчанию.
class Foo {
public:
 Foo() : counter_(0), str_(NULL) {}
 Foo(int c, string* p) : counter_(c), str_(p) {}
private:
 int counter_;
 string* str_;
};
Для инициализации переменных-членов используется список инициализации, в результате чего тело конструктора освобождается от этой задачи. Тело конструктора может при этом содержать логику, выполняемую при создании объектов, а инициализацию переменных-членов становится легко найти. Это не столь значительное преимущество по сравнению с присвоением начальных значений в теле конструктора, но все его преимущества становятся очевидны при создании переменных-членов типа класса или ссылок или при попытке эффективного использования исключений.
Члены инициализируются в порядке их указания в объявлении класса, а не в порядке объявления их в списке инициализации.
Используя тот же класс Foo, как и в примере 8.1, рассмотрим переменную-член класса.
class Foo {
public:
 Foo() : counter_(0), str_(NULL), cls_(0) {}
 Foo(int с, string* p) :
  counter_(c), str_(p), cls_(0) {}
private:
 int counter_;
 string* str_;
 SomeClass cls_;
};
В конструкторе по умолчанию Foo инициализировать cls_ не требуется, так как будет вызван ее конструктор по умолчанию. Но если требуется создать Foo с аргументами, то следует добавить аргумент в список инициализации, как это сделано выше, а не делать присвоение в теле конструктора. Используя список инициализации, вы избежите дополнительного шага создания cls_ (так как при присвоении cls_ значения в теле конструктора cls_ вначале создается с использованием конструктора по умолчанию, а затем с помощью оператора присвоения выполняется присвоение нового значения), а также получите автоматическую обработку исключений. Если объект создается в списке инициализации и этот объект в процессе его создания выбрасывает исключение, то среда выполнения удаляет все ранее созданные объекты списка и передает исключение в код, вызывавший конструктор. С другой стороны, при присвоении аргумента в теле конструктора такое исключение необходимо обрабатывать с помощью блока try/catch.
Ссылки более сложны: инициализация переменной-ссылки (и const-членов) требует обязательного использования списка инициализации. В соответствии со стандартом ссылка всегда должна ссылаться на одну переменную и никогда не может измениться и ссылаться на другую переменную. Переменная-ссылка никогда не может не ссылаться на какой-либо объект. Следовательно, чтобы присвоить что-то осмысленное переменной-члену, являющейся ссылкой, это должно происходить при инициализации, т.е. в списке инициализации.
Следующая запись в C++ недопустима.
int& x;
Это значит, что невозможно объявить переменную-ссылку без ее инициализации. Вместо этого ее требуется инициализировать каким-либо объектом. Для переменных, не являющихся членами класса, инициализация может выглядеть вот так.
int а;
int& x = a;
Это все замечательно, но приводит к возникновению проблемы при создании классов. Предположим, вам требуется переменная-член класса, являющаяся ссылкой, как здесь.
class HasARef {
public:
 int& ref;
};
Большинство компиляторов примет эту запись, но только до тех пор, пока вы не попытаетесь создать экземпляр этого класса, как здесь.
HasARef me;
В этот момент вы получите ошибку. Вот какую ошибку выдаст gcc.
error: structure 'me' with uninitialized reference members
(ошибка: структура 'me' с неинициализированными членами-ссылками)
Вместо этого следует использовать список инициализации.
class HasARef {
public:
 int &ref;
 HasARef(int &aref) : ref(aref) {}
};
Затем при создании экземпляра класса требуется указать переменную, на которую будет ссылаться переменная ref, как здесь.
int var;
HasARef me(var);
Именно так следует безопасно и эффективно инициализировать переменные-члены. В общем случае всегда, когда это возможно, используйте список инициализации и избегайте инициализации переменных-членов в теле конструктора. Даже если требуется выполнить какие-либо действия с переменными в теле конструктора, список инициализации можно использовать для установки начальных значений, а затем обновить их в теле конструктора.
Смотри также
Рецепт 9.2.
8.2. Использование функции для создания объектов (шаблон фабрики)
Проблема
Вместо создания объекта в куче с помощью new вам требуется функция (член или самостоятельная), выполняющая создание объекта, тип которого определяется динамически. Такое поведение достигается с помощью шаблона проектирования Abstract Factory (абстрактная фабрика).
Решение
Здесь есть две возможности. Вы можете:
• создать функцию, которая создает экземпляр объекта в куче и возвращает указатель на этот объект (или обновляет переданный в нее указатель, записывая в него адрес нового объекта);
• создать функцию, которая создает и возвращает временный объект.
Пример 8.2 показывает оба этих способа. Класс Session в этом примере может быть любым классом, объекты которого должны не создаваться непосредственно в коде (т.е. с помощью new), а их создание должно управляться каким-либо другим классом. В этом примере управляющий класс — это SessionFactory.
Пример 8.2. Функции, создающие объекты
#include <iostream>
class Session {};
class SessionFactory {
public:
 Session Create();
 Session* CreatePtr();
 void Create(Session*& p);
 // ...
};
// Возвращаем копию объекта в стеке
Session SessionFactory::Create() {
 Session s;
 return(s);
}
// Возвращаем указатель на объект в куче
Session* SessionFactory::CreatePtr() {
 return(new Session());
}
// Обновляем переданный указатель, записывая адрес
// нового объекта
void SessionFactory::Create(Session*& p) {
 p = new Session();
}
static SessionFactory f; // Единственный объект фабрики
int main() {
 Session* p1;
 Session* p2 = new Session();
 *p2 = f.Create();   // Просто присваиваем объект, полученный из Create
 p1 = f.CreatePtr(); // или полученный указатель на объект в куче
 f.Create(p1);       // или обновляем указатель новым адресом
}
Обсуждение
Пример 8.2 показывает несколько различных способов написания функции, возвращающей объект. Сделать так вместо обращения к new может потребоваться, если создаваемый объект берется из пула, связан с оборудованием или удаление объектов должно управляться не вызывающим кодом. Существует множество причин использовать этот подход (и именно поэтому существует шаблон проектирования для него), я привел только некоторые. К счастью, реализация шаблона фабрики в C++ очень проста.
Наиболее часто используют возврат адреса нового объекта в куче или обновление адреса указателя, переданного как аргумент. Их реализация показана в примере 8.2, и она тривиальна и не требует дальнейших пояснений. Однако возврат из функции целого объекта используется реже — возможно, потому, что это требует больших накладных расходов.
При возврате временного объекта в стеке тела функции создается временный объект. При выходе из функции компилятор копирует данные из временного объекта в другой временный объект, который и возвращается из функции, Наконец, в вызывающей функции объекту с помощью оператора присвоения присваивается значение временного объекта. Это означает, что на самом деле создается два объекта: объект в функции фабрики и временный объект, который возвращается из функции, содержимое которого затем копируется в целевой объект. Здесь осуществляется большое количество копирований (хотя компилятор может оптимизировать временный объект), так что при работе с большими объектами или частыми вызовами этой функции фабрики внимательно следите за тем, что в ней происходит.
Также эта методика копирования временных объектов работает только для объектов, которые ведут себя как объекты значений, что означает, что когда он копируется, то новая версия будет эквивалентна оригинальной. Для большинства объектов это выполняется, но для некоторых — нет. Например, рассмотрим создание объекта класса, прослушивающего сетевой порт. При создании экземпляра объекта он может начинать прослушивать целевой порт, так что скопировать его в новый объект не получится, так как при этом появятся два объекта, пытающиеся слушать один и тот же порт. В этом случае следует возвращать адрес объекта в куче.
Если вы пишете функцию или метод, создающий объекты, то посмотрите также рецепт 8.12. Используя шаблоны, функций можно написать одну функцию, которая будет возвращать новый объект любого типа. Например:
template<typename T>
T* createObject() {
 return(new T());
}
MyClass* p1 = createObject();
MyOtherClass* p2 = createObject();
// ...
Этот подход удобен, если требуется единственная функция фабрики, которая сможет одинаковым образом создавать объекты любых классов (или группы связанных классов), что позволит избежать избыточного многократного кодирования функции фабрики.
Смотри также
Рецепт 8.12.
8.3. Использование конструкторов и деструкторов для управления ресурсами (RAII)
Проблема
Для класса, представляющего некоторый ресурс, требуется использовать конструктор для получения этого ресурса и деструктор для его освобождения. Эта методика часто называется «получение ресурсов как инициализация» (resource acquisition is initialization — RAII).
Решение
Выделите или получите ресурс в конструкторе и освободите этот ресурс в деструкторе. Это снизит объем кода, который пользователь класса должен будет написать для обработки исключений. Простая иллюстрация этой методики показана в примере 8.3.
Пример 8.3. Использование конструкторов и деструкторов
#include <iostream>
#include <string>
using namespace std;
class Socket {
public:
 Socket(const string& hostname) {}
};
class HttpRequest {
public:
 HttpRequest(const string& hostname) :
  sock_(new Socket(hostname)) {}
 void send(string soapMsg) {sock << soapMsg;}
 ~HttpRequest() {delete sock_;}
private:
 Socket* sock_;
};
void sendMyData(string soapMsg, string host) {
 HttpRequest req(host);
 req.send(soapMsg);
 // Здесь делать ничего не требуется, так как когда req выходит
 // за диапазон, все очищается.
}
int main() {
 string s = "xml";
 sendMyData(s, "www.oreilly.com");
}
Обсуждение
Гарантии, даваемые конструкторами и деструкторами, представляют собой удобный способ заставить компьютер выполнить всю очистку за вас. Обычно инициализация объекта и выделение используемых ресурсов производится в конструкторе, а очистка — в деструкторе. Это нормально. Но программисты имеют склонность использовать последовательность событий «создание-открытие-использование-закрытие», когда пользователю класса требуется выполнять явные открытия и закрытия ресурсов. Класс файла является хорошим примером.
Примерно так звучит обычный аргумент в пользу RAII. Я легко мог бы создать в примере 8.3 свой класс HttpRequest, который заставил бы пользователя выполнить несколько больше работы. Например:
class HttpRequest {
public:
 HttpRequest();
 void open(const std::string& hostname);
 void send(std::string soapMsg);
 void close();
 ~HttpRequest();
private:
 Socket* sock_;
};
При таком подходе соответствующая версия sendMyData может выглядеть так.
void sendMyData(std::string soapMsg, std::string host) {
 HttpRequest req;
 try {
  req.open();
  req.send(soapMsg);
  req.close();
 } catch (std::exception& e) {
  req.close(); // Do something useful...
 }
}
Здесь требуется выполнить больше работы без каких бы то ни было преимуществ. Этот дизайн заставляет пользователя писать больше кода и работать с исключениями, очищая ваш класс (при условии, что в деструкторе close не вызывается).
Подход RAII имеет широкое применение, особенно когда требуется гарантировать, что при выбрасывании исключения будет выполнен «откат» каких-либо действий, позволяя при этом не загромождать код бесконечными try/catch. Рассмотрим настольное приложение, которое в процессе выполнения какой-либо работы отображает в строке состояния или заголовка сообщение.
void MyWindow : thisTakesALongTime() {
 StatusBarMessage("Copying files...");
 // ...
}
Все, что класс StatusBarMessage должен сделать, — это использовать информацию о статусе для обновления соответствующего окна при создании и вернуть его первоначальное состояние при удалении. Вот ключевой момент: если функция завершает работу или выбрасывается исключение, StatusBarMessage все равно выполнит работу. Компилятор гарантирует, что при выходе из области видимости стековой переменной для нее будет вызван ее деструктор. Без этого подхода автор thisTakesALongTime должен был бы принять во внимание все пути передачи управления, чтобы неверное сообщение не осталось в окне при неудачном завершении операции, ее отмене пользователем и т.п. И снова повторю, что этот подход приводит к уменьшению кода и снижению числа ошибок автора вызывающего кода.
RAII не является панацеей, но если вы его еще не использовали, то вы, скорее всего, найдете немало возможностей для его применения. Еще одним хорошим примером является блокировка. При использовании RAII для управления блокировками ресурсов, таких как потоки, объекты пулов, сетевые соединения и т.п., этот подход позволяет создавать более надежный код меньшего размера. На самом деле именно так многопоточная библиотека Boost реализует блокировки, делая программирование пользовательской части более простым. За обсуждением библиотеки Boost Threads обратитесь к главе 12.
8.4. Автоматическое добавление новых экземпляров класса в контейнер
Проблема
Требуется хранить все экземпляры класса в едином контейнере, не требуя от пользователей класса выполнения каких-либо специальных операций.
Решение
Включите в класс статический член, являющийся контейнером, таким как list, определенный в <list>. Добавьте в этот контейнер адрес объекта при его создании и удалите его при уничтожении. Пример 8.4 показывает, как это делается.
Пример 8.4. Отслеживание объектов
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;
class MyClass {
protected:
 int value_;
public:
 static list<MyClass*> instances_;
 MyClass(int val);
 ~MyClass();
 static void showList();
};
list<MyClass*> MyClass::instances_;
MyClass::MyClass(int val) {
 instances_.push_back(this);
 value_ = val;
}
MyClass::~MyClass() {
 list<MyClass*>::iterator p =
  find(instances_.begin(), instances_.end(), this);
 if (p != instances_.end()) instances_.erase(p);
}
void MyClass::showList() {
 for (list<MyClass*>::iterator p = instances_.begin();
  p != instances_.end(); ++p)
  cout << (*p)->value_ << endl;
}
int main() {
 MyClass a(1);
 MyClass b(10);
 MyClass с(100);
 MyClass::showList();
}
Пример 8.4 создаст следующий вывод.
1
10
100
Обсуждение
Подход в примере 8.4 очень прост: используйте для хранения указателей на объекты static list. При создании объекта его адрес добавляется в list; при его уничтожении он удаляется. Здесь имеется пара важных моментов.
При использовании любых членов-данных типа static их требуется объявлять в заголовочном файле класса и определять в файле реализации. Пример 8.4 весь находится в одном файле, так что здесь это не применимо, но помните, что переменную типа static требуется определять в файле реализации, а не в заголовочном файле. За объяснением причин обратитесь к рецепту 8.5.
Вы не обязаны использовать член static. Конечно, можно использовать глобальный объект, но тогда дизайн не будет таким «замкнутым». Более того, вам где-то еще придется выделять память для глобального объекта, передавать его в конструктор MyClass и в общем случае выполнять еще целый ряд действий.
Помните, что совместное использование глобального контейнера, как в примере 8.4, не будет работать, если объекты класса MyClass создаются в нескольких потоках. В этом случае требуется сериализация доступа к общему объекту через мьютексы. Рецепты, относящиеся к этой и другим методикам многопоточности, приведены в главе 12.
Если требуется отслеживать все экземпляры класса, можно также использовать шаблон фабрики. В целом это будет означать, что для создания нового объекта клиентский код вместо вызова оператора new должен будет вызывать функцию. За подробностями о том, как это делается, обратитесь к рецепту 8.2.
Смотри также
Рецепт 8.2.
8.5. Гарантия единственности копии переменной-члена
Проблема
Имеется переменная-член, у которой должен быть только один экземпляр независимо от числа создаваемых экземпляров класса. Этот тип переменных-членов обычно называется статическими членами или переменными класса — в противоположность переменным экземпляра, свои копии которых создаются для каждого объекта класса.
Решение
Объявите переменную-член с ключевым словом static, затем инициализируйте ее в отдельном исходном файле (но не в заголовочном файле, где она объявлена), как показано в примере 8.5.
Пример 8.5. Использование статических переменных-членов
// Static.h
class OneStatic {
public:
 int getCount() {return count;}
 OneStatic();
protected:
 static int count;
};
// Static.cpp
#include "Static.h"
int OneStatic::count = 0;
OneStatic::OneStatic() {
 count++;
}
// StaticMain.cpp
#include <iostream>
#include "static.h"
using namespace std;
int main() {
 OneStatic a;
 OneStatic b;
 OneStatic c;
 cout << a.getCount() << endl;
 cout << b.getCount() << endl;
 cout << c.getCount() << endl;
}
Обсуждение
static — это способ C++ разрешить создание только одной копии чего-либо. Если переменную-член объявить как static, то будет создана только одна такая переменная вне зависимости от количества созданных объектов этого класса. Аналогично, если объявить как static переменную функции, она будет создана только один раз и будет хранить свое значение от одного вызова функции к другому. Однако в случае с переменными-членами, чтобы убедиться, что переменная создана правильно, требуется проделать несколько больше работы. Именно по этой причине в примере 8.5 показано три файла.
Во-первых, при объявлении переменной требуется использовать ключевое слово static. Это достаточно просто: добавьте это ключевое слово в заголовок класса, находящийся в заголовочном файле Static.h.
protected:
static int count;
После этого требуется определить эту переменную в исходном файле. При этом для нее будет выделена память. Это делается с помощью указания полного имени переменной и присвоения ей значения, как здесь.
int OneStatic::count = 0;
В примере 8.5 я поместил это определение в файл Static.cpp. Именно так вы и должны делать — не помещайте определение в заголовочный файл. Если это сделать, память будет выделена в каждом файле реализации, включающем этот заголовочный файл, и либо возникнут ошибки компиляции, либо, что хуже, в памяти появятся несколько экземпляров этой переменной. Это не то, что требуется при использовании переменной-члена static.
В главном файле StaticMain.cpp вы можете видеть то, что происходит. Создается несколько экземпляров класса OneStatic, и каждый раз конструктор по умолчанию OneStatic инкрементирует статическую переменную. В результате вывод main из StaticMain.cpp имеет вид:
3
3
3
Каждый вызов getCount возвращает одно и то же целое значение, даже несмотря на то, что он делается для различных экземпляров класса.
8.6. Определение типа объекта во время выполнения
Проблема
Во время выполнения требуется динамически узнавать тип определенного класса.
Решение
Для запроса, на объект какого типа указывает адрес объекта, используйте идентификацию типов во время выполнения (обычно называемую просто RTTI — runtime type identification). Пример 8.6 показывает, как это делается.
Пример 8.6. Использование идентификации типов во время выполнения
#include <iostream>
#include <typeinfo>
using namespace std;
class Base {};
class Derived : public Base {};
int main() {
 Base b, bb;
 Derived d;
 // Используем typeid для проверки равенства типов
 if (typeid(b) == typeid(d)) { // No
  cout << "b и d имеют один и тот же тип.\n";
 }
 if (typeid(b) == typeid(bb)) { // Yes
  cout << "b и bb имеют один и тот же тип.\n";
 }
 it (typeid(a) == typeid(Derived)) { // Yes
  cout << "d имеет тип Derived.\n";
 }
}
Обсуждение
Пример 8.6 показывает, как использовать оператор typeid для определения и сравнения типов объектов, typeid принимает выражение или тип и возвращает ссылку на объект типа type_info или его подкласс (что зависит от реализации). Возвращенное значение можно использовать для проверки на равенство или получить строковое представление имени типа. Например, сравнить типы двух объектов можно так.
if (typeid(b) == typeid(d)) {
Это выражение возвращает истину, если возвращаемые объекты type_info равны. Это работает благодаря тому, что typeid возвращает ссылку на статический объект, так что при его вызове для двух объектов одного и того же типа будут получены две ссылки на один и тот же объект и сравнение вернет истину.
typeid также можно использовать непосредственно с типом, как здесь.
if (typeid(d) == typeid(Derived)) {
Это позволяет явно проверять определенный тип.
Вероятно, наиболее часто typeid используется для отладки. Для записи имени типа используйте type_info::name, как здесь.
std::cout << typeid(d).name() << std::endl;
При передаче объектов различных типов это может быть очень полезно. Строка, завершающаяся нулем, возвращаемая name, зависит от реализации, но вы можете ожидать (но не полагаться на это), что она будет равна имени типа. Это также работает и для встроенных типов.
Не злоупотребляйте этой методикой, основывая на информации о типе логику программы, если это не абсолютно необходимо. В общем случае наличие логики, которая выполняет что-то похожее на следующее, расценивается как плохой дизайн.
Если obj имеет тип X, сделать что-то одно, а если obj имеет тип Y, сделать что-то другое.
Это плохой дизайн, потому что клиентский код теперь содержит избыточные зависимости от типов используемых объектов. Это также приводит к большой каше из if/then кода, который то и дело повторяется, если для объектов типов X или Y требуется различное поведение. Объектно-ориентированное программирование и полиморфизм существуют в большой степени для того, чтобы избавить нас от написания подобного рода логики. Если для какого-либо семейства связанных классов требуется зависящее от типа поведение, то они все должны наследоваться от какого-то базового класса и использовать виртуальные функции, динамически вызывая различное поведение в зависимости от типа.
RTTI приводит к накладным расходам, так что компиляторы обычно по умолчанию его отключают. Скорее всего ваш компилятор имеет параметр командной строки для включения RTTI. Также это не единственный способ, которым можно получить информацию о типе. Другая методика приведена в рецепте 8.7.
Смотри также
Рецепт 8.7.
8.7. Определение, является ли класс объекта подклассом другого класса
Проблема
Имеется два объекта и требуется узнать, имеют ли их классы отношения на уровне базовый класс/производный класс, или они не связаны друг с другом.
Решение
Используйте оператор dynamic_cast, который пытается выполнить преобразование одного типа в другой. Результат скажет, имеется ли связь между классами. Пример 8.7 представляет код, который это делает.
Пример 8.7. Определение отношений классов
#include <iostream>
#include <typeinfo>
using namespace std;
class Base {
public:
 virtual ~Base() {} // Делаем класс полиморфным
};
class Derived : public Base {
public:
 virtual ~Derived() {}
};
int main() {
 Derived d;
 // Запрашиваем тип отношений
 if (dynamic_cast<Base*>(&d)) {
  cout << "Derived является классом, производным от Base" << endl;
 } else {
  cout << "Derived HE является классом, производным от Base" << endl;
 }
}
Обсуждение
Для запроса отношений между двумя типами используйте оператор dynamic_cast. dynamic_cast принимает указатель или ссылку на некий тип и пытается преобразовать его к указателю или ссылке на производный класс, т.е. выполняя преобразование типа вниз по иерархии классов. Если есть Base*, который указывает на объект Derived, то dynamic_cast<Base*>(&d) возвращает указатель типа Derived только в том случае, если d — это объект типа, производного от Base. Если преобразование невозможно (из-за того, что Derived не является подклассом — явным или косвенным — класса Base), то преобразование завершается неудачей и, если в dynamic_cast был передан указатель на производный класс, возвращается NULL. Если в него была передана ссылка, то выбрасывается стандартное исключение bad_cast. Также базовый класс должен наследоваться как public и это наследование не должно быть двусмысленным. Результат говорит о том, является ли один класс наследником другого класса. Вот что я сделал в примере 8.7.
if (dynamic_cast<Base*>(&d)) {
Здесь возвращается нe-NULL-указатель, так как d — это объект класса, производного от Base. Эту возможность можно использовать для определения отношения любых двух классов. Единственным требованием является то, что аргумент объекта должен быть полиморфным типом, что означает, что он должен иметь по крайней мере одну виртуальную функцию. Если это не будет соблюдено, то такой код не скомпилируется. Однако обычно это не вызывает особых проблем, так как иерархия классов без виртуальных функций встречается крайне редко.
Если этот синтаксис кажется вам слишком запутанным, используйте макрос, скрывающий некоторые подробности.
#define IS_DERIVED_FROM(BaseClass, x) (dynamic_cast<baseClass*>(&(x)))
//...
if (IS_DERIVED_FROM(Base, l)){//...
Но помните, что такая информация о типах не бесплатна, так как dynamic_cast должен во время выполнения пройти по иерархии классов и определить, является ли один класс наследником другого, так что не злоупотребляйте этим способом. Кроме того, компиляторы не включают эту информацию по умолчанию, так как RTTI приводит к накладным расходам, и не все используют эту функцию, так что вам может потребоваться включить ее с помощью опции компилятора.
Смотри также
Рецепт 8.6.
8.8. Присвоение каждому экземпляру класса уникального идентификатора
Проблема
Требуется, чтобы каждый объект класса имел уникальный идентификатор.
Решение
Для отслеживания следующего доступного для использования идентификатора используйте статическую переменную-член. В конструкторе присвойте текущему объекту очередное доступное значение, а затем инкрементируйте статическую переменную. Чтобы понять, как это работает, посмотрите на пример 8.8.
Пример 8.8. Присвоение уникальных идентификаторов
#include <iostream>
class UniqueID {
protected:
 static int nextID;
public:
 int id;
 UniqueID();
 UniqueID(const UniqueID& orig);
 UniqueID& operator=(const UniqueID& orig);
};
int UniqueID::nextID = 0;
UniqueID::UniqueID() {
 id = ++nextID;
}
UniqueID::UniqueID(const UniqueID& orig) {
 id = orig.id;
}
UniqueID& UniqueID::operator=(const UniqueID& orig) {
 id = orig.id;
 return(*this);
}
int main() {
 UniqueID a;
 std::cout << a.id << std::endl;
 UniqueID b;
 std::cout << b.id << std::endl;
 UniqueID c;
 std::cout << c.id << std::endl;
}
Обсуждение
Для отслеживания следующего доступного для использования идентификатора используйте статическую переменную. В примере 8.8 используется static int, но вместо нее можно использовать все, что угодно, при условии, что имеется функция, которая может генерировать уникальные значения.
В данном случае идентификаторы не используются повторно до тех пор, пока не будет достигнуто максимально возможное для целого числа значение. При удалении объекта его уникальное значение пропадает либо до перезапуска программы, либо до переполнения значения идентификатора. Эта уникальность в программе может иметь несколько интересных преимуществ. Например, при работе с библиотекой управления памятью, которая перемещает блоки памяти и обновляет значения указателей, можно быть уверенным, что для каждого объекта будет сохранено его первоначальное уникальное значение. При использовании уникальных значений в сочетании с рецептом 8.4, но применении map вместо list можно легко найти объект с заданным уникальным номером. Чтобы сделать это, просто отобразите уникальные ID на экземпляры объектов, как здесь.
static map<int, MyClass*> instmap;
Таким образом любой код, который отслеживает идентификаторы объектов, всегда сможет найти его без необходимости хранить ссылку на него.
Но это еще не все. Рассмотрим случай, когда один из этих объектов требуется добавить в стандартный контейнер (vector, list, set и т.п.). Стандартные контейнеры хранят копии объектов, добавляемых в них, а не ссылки или указатели на эти объекты (конечно, при условии, что это не контейнер указателей). Таким образом, стандартные контейнеры ожидают, что объекты, которые в них содержатся, ведут себя как объекты значений, что означает, что при присвоении с помощью оператора присвоения или копировании с помощью конструктора копирования создается новая версия, полностью эквивалентная оригинальной версии.
Это означает, что требуется решить, как должны себя вести уникальные объекты. При создании объекта с уникальным идентификатором и добавлении его в контейнер у вас появятся два объекта с одним и тем же идентификатором при условии, что вы не переопределили оператор присвоения. В операторе присвоения и конструкторе копирования требуется выполнить те действия с уникальным значением, которые имеют смысл для вашего случая. Имеет ли смысл то, что объект в контейнере будет равен оригинальному объекту? Если да, то вполне подойдет стандартный конструктор копирования и оператор присвоения, но вы должны указать это явно, чтобы пользователи вашего класса знали, что вы делаете это намеренно, а не просто забыли, как работают контейнеры. Например, чтобы использовать одно и то же значение идентификатора, конструктор копирования и оператор присвоения должны выглядеть вот так.
UniqueID::UniqueID(const UniqueID& orig) {
 id = orig.id;
}
UniqueID& UniqueID::operator=(const UniqueID& orig) {
 id = orig.id;
 return(*this);
}
Но может возникнуть ситуация, когда в контексте приложения будет иметь смысл создать для объекта в контейнере новое уникальное значение. В этом случае просто снова используйте статическую переменную, как это сделано в обычном конструкторе и показано здесь.
UniqueID::UniqueID(const UniqueID& orig) {
 id = ++nextID;
}
UniqueID& UniqueID::operator=(const UniqueID& orig) {
 id = ++nextID;
 return(*this);
}
Однако трудности еще не закончились. Если UniqueID будет использоваться несколькими потоками, у вас снова возникнут проблемы, так как доступ к статическим переменным не синхронизирован. За дополнительной информацией о работе с ресурсами при наличии нескольких потоков обратитесь к главе 12.
Смотри также
Рецепт 8.3.
8.9. Создание Singleton-класса
Проблема
Имеется класс, который должен иметь только один экземпляр, и требуется предоставить способ доступа к этому классу из клиентского кода таким образом, чтобы каждый раз возвращался именно этот единственный объект. Часто это называется шаблоном singleton или singleton-классом.
Решение
Создайте статический член, который указывает на текущий класс, ограничьте использование конструкторов для создания класса, сделав их private, и создайте открытую статическую функцию-член, которая будет использоваться для доступа к единственному статическому экземпляру. Пример 8.9 демонстрирует, как это делается.
Пример 8.9. Создание singleton-класса
#include <iostream>
using namespace std;
class Singleton {
public:
 // С помощью этого клиенты получат доступ к единственному экземпляру
 static Singleton* getInstance();
 void setValue(int val) {value_ = val;}
 int getValue() {return(value_);}
protected:
 int value_;
private:
 static Singleton* inst_;   // Единственный экземпляр
 Singleton() : value_(0) {} // частный конструктор
 Singleton(const Singleton&);
 Singleton& operator=(const Singleton&);
};
// Определяем указатель
static Singleton Singleton* Singleton::inst_ = NULL;
Singleton* Singleton::getInstance() {
 if (inst_ == NULL) {
  inst_ = new Singleton();
 }
 return(inst_);
}
int main() {
 Singleton* p1 = Singleton::getInstance();
 p1->setValue(10);
 Singleton* p2 = Singleton::getInstance();
 cout << "Value = " << p2->getValue() << '\n';
}
Обсуждение
Существует множество ситуаций, когда требуется, чтобы у класса существовал только один экземпляр. Для этой цели служит шаблон Singleton. Выполнив несколько простых действий, можно реализовать singleton-класс в С++.
Когда принимается решение, что требуется только один экземпляр чего-либо, то на ум сразу должно приходить ключевое слово static. Как было сказано в рецепте 8.5, переменная-член static — это такая, которая может иметь в памяти только один экземпляр. Для отслеживания единственного объекта singleton-класса используйте переменную-член static, как сделано в примере 8.9.
private:
 static Singleton* inst_;
Чтобы клиентский код ничего про нее не знал, сделайте ее private. Убедитесь, что в файле реализации она проинициализирована значением NULL.
Singleton* Singleton::inst_ = NULL;
Чтобы запретить клиентам создавать экземпляры этого класса, сделайте конструкторы private, особенно конструктор по умолчанию.
private:
Singleton() {}
Таким образом, если кто-то попробует создать в куче или стеке новый singleton-класс, то он получит дружественную ошибку компилятора.
Теперь, когда статическая переменная для хранения единственного объекта Singleton создана, создание объектов Singleton ограничено с помощью ограничения конструкторов; все, что осталось сделать, — это предоставить клиентам способ доступа к единственному экземпляру объекта Singleton. Это делается с помощью статической функции-члена.
Singleton* Singleton::getInstance() {
 if (inst_ == NULL) {
  inst_ = new Singleton();
 }
 return(inst_);
}
Посмотрите, как это работает. Если указатель static Singleton равен NULL, создается объект. Если он уже был создан, то возвращается его адрес. Клиенты могут получить доступ к экземпляру Singleton, вызвав его статический метод.
Singleton* p1 = Singleton::getInstance();
И если вы не хотите, чтобы клиенты работали с указателями, то можно возвращать ссылку.
Singleton& Singleton::getInstance() {
 if (inst_ == NULL) {
  inst_ = new Singleton();
 }
 return(*inst_);
}
Важно здесь то, что в обоих случаях клиентам запрещено создавать экземпляры объекта Singleton, и создается единый интерфейс, который предоставляет доступ к единственному экземпляру.
Смотри также
Рецепт 8.3.
8.10. Создание интерфейса с помощью абстрактного базового класса
Проблема
Требуется определить интерфейс, который будет реализовываться производными классами, но концепция этого интерфейса является абстракцией и не должна наследоваться сама по себе.
Решение
Создайте абстрактный класс, который определяет интерфейс, объявляя, по крайней мере, одну из своих функций как чисто виртуальную (virtual). Создайте классы, производные от этого абстрактного класса, которые будут использовать различные реализации, обеспечивая при этом один и тот же интерфейс. Пример 8.10 показывает, как можно определить абстрактный класс для чтения настроечного файла.
Пример 8.10. Использование абстрактного базового класса
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
class AbstractConfigFile {
public:
 virtual ~AbstractConfigFile() {}
 virtual void getKey(const string& header,
  const string& key, strings val) const = 0;
 virtual void exists(const string& header,
  const string& key, strings val) const = 0;
};
class TXTConfigFile : public AbstractConfigFile {
public:
 TXTConfigFile() : in_(NULL) {}
 TXTConfigFile(istream& in) : in_(&in) {}
 virtual ~TXTConfigFile() {}
 virtual void getKey(const string& header,
  const string& key, strings val) const {}
 virtual void exists(const string& header,
  const strings key, strings val) const {}
protected:
 istream* in_;
};
class MyAppClass {
public:
 MyAppClass() : config_(NULL) {}
 ~MyAppClass() {}
 void setConfigObj(const AbstractConfigFile* p) {config_ = p;}
 void myMethod();
private:
 const AbstractConfigFile* config_;
};
void MyAppClass::myMethod() {
 string val;
 config_->getKey("Foo", "Bar", val);
 // ...
}
int main() {
 ifstream in("foo.txt");
 TXTConfigFile cfg(in);
 MyAppClass m;
 m.setConfigObj(&cfg);
 m.myMethod();
}
Обсуждение
Абстрактный базовый класс (часто называемый ABC — abstract base class) — это класс, для которого невозможно создать экземпляры, и, таким образом, он выполняет роль исключительно интерфейса. Класс является абстрактным, если он объявляет, по крайней мере, одну чисто виртуальную функцию или наследует функцию без реализации. Таким образом, если требуется создать экземпляр подкласса ABC, то он должен реализовать все виртуальные функции, что означает, что он будет поддерживать интерфейс, объявленный в ABC.
Подкласс, который наследуется от ABC (и реализует все его чисто виртуальные методы), поддерживает контракт, определенный интерфейсом. Рассмотрим классы MyAppClass и TXTConfigFile из примера 8.10. MyAppClass содержит указатель, который указывает на объект типа AbstractConfigFile.
const AbstractConfigFile* config_;
(Я сделал его const, потому что МуАррСlass не должен изменять настроечный файл, а только читать из него.) Пользователи могут указать используемый в MyAppClass настроечный файл с помощью функции установки значения setConfigObj.
Когда приходит время использовать в MyAppClass настроечный файл, как это делает MyAppClass::myMethod, можно вызвать любую из функций, объявленных в AbstractConfigFile, независимо от реально используемого типа настроечного файла. Это может быть TXTConfigFile, XMLConfigFile или любой другой, который наследуется от AbstractConfigFile.
Это полиморфное поведение является следствием наследования: если код ссылается на объект базового класса, вызов виртуальных функций для него приведет к их динамической переадресации и вызову правильных версий подкласса этого класса при условии, что реальный объект, на который ссылается код, является объектом этого подкласса. Но это происходит независимо от того, является ли базовый класс ABC или нет. Так в чем же разница?
Здесь имеется два различия. Чисто виртуальный класс (ABC, который не предоставляет никаких реализаций) служит только как контракт, которому должны подчиняться все подклассы, если требуется создавать их объекты. Часто это означает, что проверка на принадлежность подкласса к чисто интерфейсному классу может не сработать (что означает, что нельзя сказать, что объект подкласса является также и объектом базового класса), но что сработает проверка «ведет себя как». Это позволяет различать то, чем объект является, оттого, что он может сделать. Спасибо Супермену. Он человек, но он также и супергерой. Супергерои могут летать как птицы, но сказать, что супергерой — это птица, будет неверно. Иерархия классов для Супермена может выглядеть так, как это показано в примере 8.11.
Пример 8.11. Использование чистого интерфейса
class Person {
public:
 virtual void eat() = 0;
 virtual void sleep() = 0;
 virtual void walk() = 0;
 virtual void jump() = 0;
};
class IAirborne {
public:
 virtual void fly() = 0;
 virtual void up() = 0;
 virtual void down() = 0;
};
class Superhero : public Person, // Супергерой «является» человеком
              public IAirborne { // и летает
public:
 virtual void eat();
 virtual void sleep();
 virtual void walk();
 virtual void jump();
 virtual void fly();
 virtual void up();
 virtual void down();
 virtual ~Superhero();
};
void Superhero::fly() {
 // ...
}
// Все виртуальные методы реализуем в родительских классах супергероя...
int main() {
 Superhero superman;
 superman.walk(); // Супермен может ходить как человек
 superman.fly();  // или летать как птица
}
Однако летать может огромное количество объектов, так что не стоит называть этот интерфейс, например, IBird. IAirborne указывает, что всё, что поддерживает этот интерфейс, может летать. Все, что он делает, — это позволяет клиентскому коду быть уверенным, что если он работает с объектом, наследуемым от IAirborne, клиентский код может вызвать методы fly, up и down.
Второе различие состоит в том, что ABC может определить абстрактную сущность, которая не имеет смысла как объект, так как она, по сути, является обобщением. В этом случае проверка на принадлежность при наследовании выполняется, но ABC — это абстракция, так как сам по себе он не содержит реализаций, которые могут наследоваться объектами. Рассмотрим класс AbstractConfigFile из примера 8.10. Имеет ли смысл создавать объект типа AbstractConfigFile? Нет, имеет смысл только создавать различные виды настроечных файлов, которые имеют конкретное представление.
Вот краткий перечень правил, касающихся абстрактных классов и чисто виртуальных функций. Класс является абстрактным, если:
• он объявляет, по крайней мере, одну чисто виртуальную функцию;
• он наследует, но не реализует, по крайней мере, одну чисто виртуальную функцию.
Создавать объекты абстрактного класса нельзя. Однако абстрактный класс может:
• содержать данные-члены;
• содержать не-виртуальные методы;
• предоставлять реализации для чисто виртуальных функций;
• делать большую часть из того, что может делать обычный класс.
Другими словами, с ними можно делать почти все, что можно делать с обычными классами, кроме создания объектов этих классов.
Когда дело доходит до реализации, использование ABC в C++ требует осторожности. Используется ли ABC как чистый интерфейс или нет, зависит от вас. Например, предположим на мгновение, что в примере с супергероем я решил, что класс Person должен быть абстрактным, но так как все виды людей имеют имя и фамилию, я добавил в класс эти два члена и связал с ними методы их задания и получения, так что авторам подклассов этого делать уже не требуется.
class Person {
public:
 virtual void eat() = 0;
 virtual void sleep() = 0;
 virtual void walk() = 0;
 virtual void jump() = 0;
 virtual void setFirstName(const string& s) {firstName_ = s;}
 virtual void setLastName(const string& s) {lastName_ = s;}
 virtual string getFirstName() {return(firstName_);}
 virtual string getLastName() {return(lastName_);}
protected:
 string firstName_;
 string lastName_;
};
Теперь, если подкласс Superhero хочет переопределить одну из этих функций, то он может это сделать. Все, что он должен сделать, чтобы указать, какая версия должна вызываться, — это использовать имя базового класса. Например:
string Superhero::getLastName() {
 return(Person::getLastName() + " (Superhero)");
}
Кстати, эти функции также можно сделать чисто виртуальными и предоставить реализацию по умолчанию. Для этого после объявления требуется использовать запись вида =0, а собственно определение поместить куда-либо еще, как здесь.
class Person {
 // ...
 virtual void setFirstName(const string& s) = 0;
 // ...
 Person::setFirstName(const string& s) {
  firstName_ = s;
 }
Сделав так, вы заставите подклассы переопределять этот метод, но они, если это требуется, по-прежнему могут вызвать версию по умолчанию, использовав для этого полное имя класса.
Наконец, если в базовом классе создать виртуальный деструктор (чистый или нет), то потребуется предоставить тело для него. Это требуется потому, что деструктор подкласса автоматически вызывается деструктором базового класса.
8.11. Написание шаблона класса
Проблема
Имеется класс, чьи члены в различных ситуациях должны иметь разные типы, а использование обычного полиморфного поведения очень сложно или сильно избыточно. Другими словами, как разработчик класса, вы хотите, чтобы пользователь класса при создании объектов этого класса мог выбрать типы различных его частей, вместо того чтобы указывать их при первоначальном определении класса.
Решение
Для параметризации типов, которые используются при объявлении членов класса (и в других случаях), используйте шаблон класса. Это значит, что требуется написать класс с заполнителями типов, оставив, таким образом, выбор используемых типов на усмотрение пользователя класса. В примере 8.12 показан пример класса узла дерева, который может указывать на любой тип.
Пример 8.12. Написание шаблона класса
#include <iostream>
#include <string>
using namespace std;
template<typename T>
class TreeNode {
public:
 TreeNode (const T& val) : val_(val), left_(NULL), right_(NULL) {}
 ~TreeNode() {
  delete left_;
  delete right_;
 }
 const T& getVal() const {return(val_);}
 void setVal(const T& val) {val_ = val;}
 void addChild(TreeNode<T>* p) {
  const T& other = p->getVal();
  if (other > val_)
   if (rights)
    right_->addChild(p);
   else
    right_ = p;
  else
   if (left_)
    left_->addChild(p);
   else
    left_ = p;
 }
 const TreeNode<T>* getLeft() {return(left_);}
 const TreeNode<T>* getRight() {return(right_);}
private:
 T val_;
 TreeNode<T>* left_;
 TreeNode<T>* right_;
};
int main() {
 TreeNode<string> node1("frank");
 TreeNode<string> node2("larry");
 TreeNode<string> node3("bill");
 node1.addChild(&node2);
 node1.addChild(&node3);
}
Обсуждение
Шаблоны классов предоставляют способ параметризации типов, используемых в классе, так что эти типы могут указываться пользователем класса при создании объектов. Однако шаблоны могут оказаться несколько запутанными, так что позвольте мне перед разбором их работы пояснить приведенный выше пример.
Рассмотрим объявление шаблона класса TreeNode из примера 8.12.
template<typename T> class TreeNode {
//...
Часть template<typename T> — это то, что делает этот класс шаблоном, а не обычным классом. Эта строка говорит, что T — это имя типа, который будет указан при использовании класса, а не при его объявлении. После этого параметр T может использоваться в объявлении и определении TreeNode так, как будто это обычный тип — встроенный или определенный пользователем. Например, имеется частный член с именем val_, который должен иметь тип T. Тогда его объявление будет иметь вид:
T val_;
Здесь просто объявляется член класса с именем val_ некоторого типа, который будет определен позднее. Это объявление выглядит так же, как и при использовании для val_ типов int, float, MyClass или string. В этом отношении его можно рассматривать как макрос (т.е. использование #define), хотя сходство с макросом на этом и заканчивается.
Параметр типа может применяться любым способом, которым можно использовать обычный параметр: возвращаемые значения, указатели, параметры методов и т.д. Рассмотрим методы установки и получения val_.
const T& getVal() const (return(val_);}
void setVal(const T& val) {val_ = val;}
getVal возвращает const-ссылку на val_, имеющий тип T, a setVal принимает ссылку на T и записывает ее значение в val_. Некоторые сложности появляются в отношении методов getLeft и getRight, так что далее я вернусь к этому вопросу. Подождите немного.
Теперь, когда TreeNode объявлен с помощью заполнителя типа, его должен использовать клиентский код. Вот как это делается.
TreeNode — это простая реализация двоичного дерева. Чтобы создать дерево, которое хранит строковые значения, создайте узлы следующим образом.
ТreeNode<string> node1("frank");
TreeNode<string> node2("larry");
TreeNode<string> node3("bill");
Тип между угловыми скобками — это то, что используется вместо T при создании экземпляра класса. Создание экземпляра шаблона — это процесс, выполняемый компилятором при создании версии TreeNode при условии, что T — это string. Двоичное физическое представление TreeNode<string> создается тогда, когда создается его экземпляр (и только в этом случае). В результате в памяти получается структура, эквивалентная той, которая была бы, если TreeNode был написан без ключевого слова template и параметра типа, а вместо T использовался бы string.
Создание экземпляра шаблона для данного параметра типа аналогично созданию экземпляра объекта любого класса. Ключевое различие состоит в том, что создание экземпляра шаблона происходит в процессе компиляции, в то время как создание объекта класса происходит во время выполнения программы. Это означает, что если вместо string двоичное дерево должно хранить данные типа int, его узлы должны быть объявлены вот так.
TreeNode<int> intNode1(7);
TreeNode<int> intNode2(11);
TreeNode<int> intNode3(13);
Как и в случае с версией для string, создается двоичное представление шаблона класса TreeNode с использованием внутреннего типа int.
Некоторое время назад я сказал, что рассмотрю методы getLeft и getRight. Теперь, когда вы знакомы с созданием экземпляра шаблона (если еще не были), объявление и определение getLeft и getRight должно стать более осмысленным.
const TreeNode<T>* getLeft() {return(left_);}
const TreeNode<T>* getRight() {return(right_);}
Здесь говорится, что каждый из этих методов возвращает указатель на экземпляр TreeNode для T. Следовательно, когда создается экземпляр TreeNode для, скажем, string, экземпляры getLeft и getRight создаются следующим образом.
const TreeNode<string>* getLeft() {return(left_);}
const TreeNode<string>* getRight() {return(right_);}
При этом не существует ограничения одним параметром шаблона. Если требуется, можно использовать несколько таких параметров. Представьте, что вам требуется отслеживать число дочерних узлов данного узла, но пользователи вашего класса могут быть ограничены в использовании памяти и не захотят использовать int, если смогут обойтись short. Аналогично они могут захотеть применять для подсчета использованных узлов что-то более сложное, чем простой встроенный тип (например, их собственный класс). В любом случае это можно разрешить сделать с помощью еще одного параметра шаблона.
template<typename T, typename N = short>
class TreeNode {
 // ...
 N getNumChildren();
private:
 TreeNode() {}
 T val_;
 N numChildren_;
 // ...
Таким образом, человек, использующий ваш класс, может указать для отслеживания размера поддеревьев каждого узла int, short или что-либо еще.
Для параметров шаблона также можно указать аргументы по умолчанию, как это сделано в моем примере, для чего используется такой же синтаксис, как и при объявлении параметров функций по умолчанию.
template<typename T, typename N = short>
Как и в случае с параметрами функций по умолчанию, их можно использовать только для отдельных параметров при условии, что этот последний параметр или все параметры справа от него имеют аргументы по умолчанию.
В примере 8.12 определение шаблона дается в том же месте, что и его объявление. Обычно это делается для экономии места, занимаемого примером, не в данном случае есть и еще одна причина. Шаблоны (классов или функций — см. рецепт 8.12) компилируются в двоичную форму только тогда, когда создается их экземпляр. Таким образом, невозможно создать объявление шаблона в заголовочном файле, а его реализацию — в исходном файле (т.е. .cpp) Причина заключается в том, что в нем нечего компилировать! Из этого правила имеются исключения, но обычно при написании шаблона класса его реализация должна помешаться в заголовочном файле или встраиваемом файле, который подключается заголовочным.
В этом случае требуется использовать несколько необычный синтаксис. Методы и другие части класса объявляются как в обычном классе, но при определении методов требуется включить дополнительные лексемы, которые говорят компилятору, что это части шаблона класса. Например, getVal можно определить вот так (сравните с примером 8.12)
template<typename T>
const T& TreeNode<T>::getVal() const {
 return(val_);
}
Тело функции выглядит точно так же.
Однако с шаблонами следует быть осторожными, так как если написать шаблон, который используется повсеместно, то можно получить раздувание кода, что случается, когда один и тот же шаблон с одними и теми же параметрами (например, TreeNode<int, short>) компилируется в нескольких объектных файлах. По существу в нескольких файлах окажется одно и то же двоичное представление экземпляра шаблона, и это сделает библиотеку или исполняемый файл значительно больше по размеру, чем требуется.
Одним из способов избежать этого является использование явного создания экземпляров, что позволяет указать компилятору создать версию шаблона класса для определенного набора аргументов шаблона. Если сделать это в таком месте, которое компонуется вместе с остальными клиентскими частями, то раздувания кода не произойдет. Например, если известно, что в приложении будет использоваться TreeNode<string>, то в общий исходный файл можно поместить такую строку.
// common.cpp
template class TreeNode<string>;
Соберите динамическую библиотеку с этим файлом, и после этого код, использующий TreeNode<string>, сможет применять эту библиотеку динамически, не содержа своей собственной скомпилированной версии шаблона. Другой код может включить заголовочный файл шаблона класса, затем скомпоноваться с этой библиотекой и. следовательно, избежать необходимости иметь свою копию. Однако этот подход требует проведения экспериментов, так как не все компиляторы имеют одинаковые проблемы с раздуванием кода, но это общий подход для его минимизации.
Шаблоны C++ (как классов, так и функций) — это очень обширная тема, и имеется огромное количество методик создания мощных, эффективных проектов на основе шаблонов. Великолепным примером шаблонов классов являются контейнеры из стандартной библиотеки, такие как vector, list, set и другие, которые описываются в главе 15. Большая часть интересных разработок, описанных в литературе по С++, связана с шаблонами. Если вы заинтересовались этим предметом, почитайте группы новостей comp.lang.std.c++ и comp.lang.c++. В них всегда можно найти интересные вопросы и ответы на них.
Смотри также
Рецепт 8.12.
8.12. Написание шаблона метода класса
Проблема
Имеется один метод, который должен принимать параметр любого типа, и невозможно ограничиться каким-либо одним типом или категорией типов (используя указатель на базовый класс).
Решение
Используйте шаблон метода и объявите параметр шаблона для типа объекта. Небольшая иллюстрация приведена в примере 8.13.
Пример 8.13. Использование шаблона метода
class ObjectManager {
public:
 template<typename T> T* gimmeAnObject();
 template<typename T>
 void gimmeAnObject(T*& p);
};
template<typename T>
T* ObjectManager::gimmeAnObject() {
 return(new T);
}
template<typename T>
void ObjectManager::gimmeAnObject(T*& p) {
 p = new T;
}
class X { /*...*/ };
class Y { /* ... */ };
int main() {
 ObjectManager om;
 X* p1 = om.gimmeAnObject<X>(); // Требуется указать параметр
 Y* p2 = om.gimmeAnObject<Y>(); // шаблона
 om.gimmeAnObject(p1); // Однако не здесь, так как компилятор может
 om.gimmeAnObject(p2); // догадаться о типе T по аргументам
}
Обсуждение
При обсуждении шаблонов функций или классов слова «параметр» и «аргумент» становятся несколько двусмысленными. Имеется по два вида каждого: шаблона и функции. Параметры шаблона — это параметры в угловых скобках, например T в примере 8.13, а параметры функции — это параметры в обычном смысле.
Рассмотрим класс ObjectManager из примера 8.13. Это упрощенная версия шаблона фабрики, описанного в рецепте 8.2, так что мне потребовалось объявить метод gimmeAnObject, который создает новые объекты и который клиентский код сможет использовать вместо непосредственного обращения к new. Это можно сделать, либо возвращая указатель на новый объект, либо изменяя указатель, переданный в метод клиентским кодом. Давайте посмотрим на каждый из этих подходов.
Объявление шаблона метода требует, чтобы было использовано ключевое слово template и были указаны параметры шаблона.
template<typename T> T* gimmeAnObject();
template<typename T> void gimmeAnObject(T*& p);
Оба этих метода используют в качестве параметра шаблона T, но они не обязаны это делать. Каждый из них представляет параметр шаблона только для данного метода, так что их имена не связаны друг с другом. То же самое требуется сделать для определения этих шаблонов методов, т.е. использовать это же ключевое слово и перечень параметров шаблона. Вот как выглядят мои определения.
template<typename T>
T* ObjectManager.:gimmeAnObject() {
 return(new T);
}
template<typename T>
void ObjectManager::gimmeAnObject(T*& p) {
 p = new T;
}
Теперь есть пара способов вызвать эти шаблоны методов. Во-первых, их можно вызвать явно, используя параметры шаблона, как здесь.
X* p1 = om.gimmeAnObject<X>();
X — это имя некоего класса. Либо можно позволить компилятору догадаться об аргументах параметров шаблона, передав в методы аргументы типа (типов) параметров шаблона. Например, можно вызвать вторую форму gimmeAnObject, не передавая ей ничего в угловых скобках.
om.gimmeAnObject(p1);
Это работает благодаря тому, что компилятор может догадаться о T, посмотрев на p1 и распознав, что он имеет тип X*. Такое поведение работает только для шаблонов функций (методов или отдельных) и только тогда, когда параметры шаблона понятны из аргументов функции.
Шаблоны методов не имеют большой популярности при разработке на C++, но время от времени они оказываются очень полезны, так что следует знать, как создавать их. Я часто сталкиваюсь с необходимостью сдерживать себя, когда мне хочется использовать метод, который бы работал с типами, которые не связаны друг с другом механизмом наследования. Например, если есть метод foo, который должен принимать один аргумент, который всегда будет классом, наследуемым от некоторого базового класса, то шаблон не требуется: здесь можно просто сделать параметр типа базового класса или ссылки. После этого этот метод будет прекрасно работать с параметром, имеющим тип любого подкласса; это обеспечивается самим C++.
Но может потребоваться функция, которая работает с параметрами, которые не наследуются от одного и того же базового класса (или классов). В этом случае можно либо написать несколько раз один и тот же метод — по одному разу для каждого из типов, либо сделать его шаблоном метода. Использование шаблонов также позволяет использовать специализацию, предоставляющую возможность создавать реализации шаблонов для определенных аргументов шаблона. Но это выходит за рамки одного рецепта, так что сейчас я прекращаю обсуждение, но это мощная методика, поэтому при использовании программирования шаблонов не забудьте про такую возможность.
Смотри также
Рецепт 8.11.
8.13. Перегрузка операторов инкремента и декремента
Проблема
Имеется класс, для которого имеют смысл операции инкремента и декремента, и требуется перегрузить operator++ и operator--, которые позволят легко и интуитивно выполнять инкремент и декремент объектов этого класса.
Решение
Чтобы это сделать, перегрузите префиксную и постфиксную формы ++ и --. Пример 8.14 показывает обычную методику перегрузки операторов инкремента и декремента.
Пример 8.14. Перегрузка инкремента и декремента
#include <iostream>
using namespace std;
class Score {
public:
 Score() : score_(0) {}
 Score(int i) : score_(i) {}
 Score& operator++() {
  // префикс
  ++score_;
  return(*this);
 }
 const Score operator++(int) {
  // постфикс
  Score tmp(*this);
  ++(*this); // Использование префиксного оператора
  return(tmp);
 }
 Score& operator--() {
  --score_;
  return(*this);
 }
 const Score operator--(int x) {
  Score tmp(*this);
  --(*this);
  return(tmp);
 }
 int getScore() const {return(score_);}
private:
 int score_;
};
int main() {
 Score player1(50);
 player1++;
 ++player1; // score = 52
 cout << "Счет = " << player1.getScore() << '\n';
 (--player1)--; // score_ = 50
 cout << "Счет = " << player1.getScore() << '\n';
}
Обсуждение
Операторы инкремента и декремента часто имеют смысл для классов, которые представляют некоторые разновидности целых значений. Если вы понимаете разницу между префиксной и постфиксной формами и следуете соглашениям о возвращаемых значениях, то их легко использовать.
Представьте себе инкремент целого числа. С помощью оператора ++ имеется два способа выполнить его для некоторого целого i.
i++; // постфиксный
++i; // префиксный
Оба инкрементируют i: первая версия создает временную копию i, инкрементирует i и затем возвращает временное значение, а вторая инкрементирует i и затем возвращает его. C++ позволяет выполнять перегрузку операторов, что означает, что вы можете заставить свой собственный тип (класс или enum) вести себя так же, как и int.
Чтобы добиться нужного эффекта, перегрузите operator++ и operator--. Пример 8.14 иллюстрирует, как перегружать префиксную и постфиксную версии.
Score& operator++() { // префиксный
 ++score_;
 return(*this);
}
const Score operator++(int) { // постфиксный
 Score tmp(*this);
 ++(*this);
 return(tmp);
}
Префикс выглядит так, как и следует ожидать, но компилятор различает эти две версии, и в объявление постфиксной версии включается параметр int. Он не имеет семантического применения — он всегда передается как ноль, так что его можно игнорировать.
После этого класс Score можно использовать как int.
Score player1(50);
player1++;
++player1; // score_ = 52
Вы, вероятно, заметили, что сигнатуры префиксной версии operator++ возвращают ссылку на текущий класс. Именно так и следует делать (а не возвращать, к примеру, void), чтобы инкрементируемый или декрементируемый объект мог использоваться в других выражениях. Рассмотрим такую строку из примера.
(--player1)--;
Да, это странно, но она иллюстрирует этот момент. Если бы префиксный operator-- не возвращал чего-то осмысленного, то это выражение не скомпилировалось бы. Еще один пример показывает вызов функции.
foo(--player1);
Функция foo ожидает аргумент типа Score, и для корректной компиляции именно это должно возвращаться из префиксного operator--.
Перегрузка операторов — это мощная возможность, которая позволяет для типов, определяемых пользователем, использовать те же операторы, что и для встроенных типов. Сторонники других языков, которые не поддерживают перегрузку операторов, утверждают, что эта возможность сбивает с толку и очень сложна, и, следует признать, может быть перегружено очень много операторов, соответствующих любому поведению. Но когда дело касается простого инкремента и декремента, хорошо иметь возможность изменить поведение класса так, как этого хочется.
Смотри также
Рецепт 8.14.
8.14. Перегрузка арифметических операторов и операторов присвоения для работы с классами
Проблема
Имеется класс, для которого имеют смысл некоторые из унарных или бинарных операторов С++, и требуется, чтобы пользователи класса могли использовать их при работе с объектами этого класса. Например, если есть класс с именем Balance, который содержит значение с плавающей точкой (например, баланс счета), будет удобно, если для объектов Balance можно было бы использовать некоторые стандартные операторы С++, как здесь.
Balance checking(50.0);
savings(100.0);
checking += 12.0;
Balance total = checking + savings;
Решение
Перегрузите операторы, которые требуется использовать как методы и отдельные функции, указав аргументы различных типов, для которых данный оператор имеет смысл, как в примере 8.15.
Пример 8.15. Перегрузка унарных и бинарных операторов
#include <iostream>
using namespace std;
class Balance {
 // These have to see private data
 friend const Balance operator+(const Balance& lhs, const Balance& rhs);
 friend const Balance operator+(double lhs, const Balance& rhs);
 friend const Balance operator+(const Balance& lhs, double rhs);
public:
 Balance() : val_(0.0) {}
 Balance(double val) : val_(val) {}
 ~Balance() {}
 // Унарные операторы
 Balance& operator+=(const Balance& other) {
  val_ += other.val_;
  return(*this);
 }
 Balance& operator+=(double other) {
  val_ += other;
  return(*this);
 }
 double getVal() const {return(val_);}
private:
 double val_;
};
// Бинарные операторы
const Balance operator+(const Balance& lhs, const Balance& rhs) {
 Balance tmp(lhs.val_ + rhs.val_);
 return(tmp);
}
const Balance operator+(double lhs, const Balance& rhs) {
 Balance tmp(lhs + rhs.val_);
 return(tmp);
}
const Balance operator+(const Balance& lhs, double rhs) {
 Balance tmp(lhs.val_ + rhs);
 return(tmp);
}
int main() {
 Balance checking(500.00);
 savings(23.91);
 checking += 50;
 Balance total = checking + savings;
 cout << "Платежный баланс: " << checking.getVal() << '\n';
 cout << "Общий баланс: " << total.getVal() << '\n';
}
Обсуждение
Наиболее часто используют перегрузку для арифметических операторов и операторов присвоения. Существует огромное количество различных классов, для которых имеют смысл арифметические операторы (сложение, умножение, остаток от деления, сдвиг битов вправо/влево) и операторы присвоения — вне зависимости от того, используются ли они для вычислений или для чего-то другого. Пример 8.15 показывает основные методики перегрузки этих операторов.
Давайте начнем с того, что, вероятно, является наиболее часто перегружаемым оператором, — оператора присвоения. Оператор присвоения используется при присвоении одного объекта другому, как в следующем выражении.
Balance x(0), у(32);
x = y;
Вторая строка — это краткая запись вызова Balance::operator=(y). Оператор присвоения отличается от большинства других операторов тем, что если вы не создаете собственной его версии, то компилятором создается версия по умолчанию. Версия по умолчанию просто копирует в текущий объект каждый член целевого объекта, что, конечно, не всегда приемлемо, так что его можно перегрузить и обеспечить другое поведение или перегрузить и предоставить возможность присвоения объектов типов, отличных от текущего
Для класса Balance из примера 8.15 оператор присвоения можно определить вот так.
Balance& operator=(const Balance& other) {
 val_ = other.val_;
 return(*this);
}
Первое, на что вы должны обратить внимание, если не знакомы с перегрузкой операторов, — это синтаксис operator=. Именно так объявляются все операторы. Все операторы можно рассматривать как функции с именами operator[symbol], где symbol — это перегружаемый оператор. Единственным различием между операторами и обычными функциями является синтаксис их вызова. На самом деле, если вы хотите ввести побольше кода и написать отвратительно выглядящий код, то операторы можно вызывать и с помощью такого синтаксиса.
x.operator=(y); // То же самое, что и x = y, но уродливее
Работа моей реализации оператора присвоения проста. Он обновляет член val_ текущего объекта, записывая в него значение аргумента other, а затем возвращает ссылку на текущий объект. Операторы присвоения возвращают текущий объект как ссылку, так что вызывающий код может использовать присвоение в выражениях:
Balance x, y, z;
// ...
x = (y = z);
Таким образом, возвращаемое из (y = z) значение — это измененный объект y, который затем передается в оператор присвоения объекта x. Такая запись для присвоения используется не так часто, как для арифметических операторов, но чтобы придерживаться общего соглашения, всегда следует возвращать ссылку на текущий объект (то, как это связано с арифметическими операторами, я рассказываю дальше).
Однако простое присвоение — это только начало. Скорее всего, вам потребуется использовать другие арифметические операторы, определяющие более интересное поведение. В табл. 8.1 показан перечень арифметических операторов и операторов присвоения.
Табл. 8.1. Арифметические операторы и присвоение
Оператор	Поведение
=	Присвоение (должен быть функцией-членом)
+	Сложение
- -=	Вычитание
* *=	Умножение и разыменование
/ /=	Деление
% %=	Остаток от деления
++	Инкремент
--	Декремент
^ ^=	Битовое исключающее ИЛИ
~	Битовое дополнение
& &=	Битовое И
| |=	Битовое ИЛИ
<< <<=	Сдвиг влево
>> >>=	Сдвиг вправо
Для большинства операторов из табл. 8.1 существует две лексемы: первая — это версия оператора, используемая обычным образом, т.е. 1+2, а вторая версия — это версия, которая также присваивает результат операции переменной, т. е. x+=5. Заметьте, что операторы инкремента и декремент ++ и -- описываются в рецепте 8.13.
Реализация всех арифметических операторов и оператора присвоения очень похожа, за исключением оператора присвоения, который не может быть отдельной функцией (т.е. он должен быть методом).
Наиболее популярным при перегрузке является оператор сложения — благодаря тому что он может использоваться в отличных от математических контекстах, таких как объединение двух строк, так что давайте вначале рассмотрим именно его. Он складывает правый аргумент с левым и присваивает результирующее значение левому аргументу, как в выражении.
int i = 0;
i += 5;
После выполнения второй строки int i изменяется и содержит значение 5. Аналогично, если посмотреть на пример 8.15, следует ожидать такого же поведения от этих строк.
Balance checking(500.00), savings(23.91);
checking += 50;
Это означает, что следует ожидать, что после использования оператора += значение checking будет увеличено на 50. Именно это происходит при использовании реализации из примера 8.15. Посмотрите на определение функции для оператора +=.
Balance& operator+=(double other) {
 val_ += other;
 return(*this);
}
Для оператора присвоения список параметров — это то, что будет указано в операторе в его правой части. В данном случае используется целое число. Тело этой функции тривиально: все, что здесь делается, — это добавление аргумента к частной переменной-члену. Когда эта работа сделана, возвращается *this. Возвращаемым значением из арифметических операторов и операторов присвоения должно быть *this, что позволяет использовать их в выражениях, когда их результаты будут входом для чего-то еще. Например, представьте, что operator+= объявлен вот так.
void operator+=(double other) { // Не делайте так
 val += other;
}
Затем кто-то захочет использовать этот оператор для экземпляра класса и передать результат в другую функцию.
Balance moneyMarket(1000.00);
// ...
updateGeneralLeager(moneyMarket += deposit); // He скомпилируется
Это приведет к проблеме, так как Balance::operator+= возвращает void, а функция типа updateGeneralLedger ожидает получить объект типа Balance. Если из арифметических операторов и оператора присвоения возвращать текущий объект, то этой проблемы не возникнет. Однако это верно не для всех операторов. Другие операторы, типа оператора элемента массива [] или оператора отношения возвращают объекты, отличные от *this, так что это правило верно только для арифметических операторов и операторов присвоения.
Здесь обеспечивается работа операторов присвоения, выполняющих какие-то вычисления, но как насчет вычислений без присвоения? Еще один способ использовать арифметические операторы выглядит так.
int i = 0, j = 2;
i = j + 5;
В этом случае к значению j прибавляется 5, а затем результат присваивается i (при этом, если бы i был объектом класса, а не встроенного типа, использовался бы оператор присвоения этого класса), а значение j остается без изменения. Если требуется, чтобы класс вел себя точно так же, то перегрузите оператор сложения как самостоятельную функцию. Например, имеется возможность сделать так, чтобы можно было записать следующее.
Balance checking(500.00), savings(100.00), total(0);
total = checking + savings;
Это делается в два этапа. Первый шаг — это создание функции, которая перегружает оператор +.
Balance operator+(const Balance& lhs, const Balance& rhs) {
 Balance tmp(lhs.val_ + rhs.val_);
 return(tmp);
}
Она принимает два объекта типа const Balance, складывает их частные члены, создает временный объект и возвращает его. Обратите внимание, что в отличие от оператора присвоения здесь возвращается объект, а не ссылка на него. Это сделано потому, что возвращаемый объект является временным, и возврат ссылки на него будет означать, что вызывающий код получит ссылку на удаленную из памяти переменную. Однако само по себе это работать не будет, так как здесь требуется доступ к закрытым (частным) членам аргументов оператора (если, конечно, вы не сделали данные класса открытыми). Чтобы обеспечить такой доступ, класс Balance должен объявить эту функцию как friend.
class Balance {
 // Здесь требуется видеть частные данные
 friend Balance operator+(const Balance& lhs, const Balance& rhs);
 // ...
Все что объявляется, как friend, получает доступ ко всем членам класса, так что этот фокус сработает. Только не забудьте объявить параметры как const, чтобы случайно не изменить их содержимое.Это почти все, что от вас требуется, но есть еще кое-что, что требуется сделать. Пользователи класса могут создать выражение, аналогичное такому.
total = savings + 500.00;
Для кода из примера 8.15 это выражение будет работать, так как компилятор увидит, что класс Balance содержит конструктор, который принимает число с плавающей точкой, и создаст временный объект Balance, используя в конструкторе число 500.00. Однако здесь есть две проблемы: накладные расходы на создание временного объекта и отсутствие в классе Balance конструктора для всех возможных аргументов, которые могут использоваться в операторе сложения. Скажем, имеется класс с именем Transaction, который представляет сумму кредита или дебета. Пользователь Balance может сделать что-то подобное этому.
Transaction tx(-20.00);
total = savings + tx;
Этот код не скомпилируется, так как не существует оператора, который бы складывал объекты Ваlance и Transaction. Так что создайте такой.
Balance operator+(const Balance& lhs, const Transaction& rhs) {
 Balance tmp(lhs.val_ + Transaction.amount_);
 return(tmp);
}
Однако необходимо сделать еще кое-что. Этот оператор также требуется объявить как friend в классе Transaction, а кроме того, нужно создать идентичную версию этого оператора, которая бы принимала аргументы в обратном порядке, что позволит использовать аргументы сложения в любом порядке и сделает эту операцию коммутативной, т.е. x+y == y+x.
Balance operator+(const Transaction& lhs, const Balance& rhs) {
 Balance tmp(lhs.amount_ + rhs.val_);
 return(tmp);
}
По той же причине и чтобы избежать создания дополнительного временного объекта при автоматическом вызове конструктора, создайте собственные версии операторов для работы с любыми другими типами переменных.
Balance operator+(double lhs, const Balance& rhs) {
 Balance tmp(lhs + rhs.val_);
 return(tmp);
}
Balance operator+(const Balance& lhs, double rhs) {
 Balance tmp(lhs.val_ + rhs);
 return(tmp);
}
И снова требуется создать по две версии каждого, чтобы позволить запись, как здесь.
total = 500.00 + checking;
В этом случае создание временного объекта относительно недорого. Но временный объект — это временный объект, и в простых выражениях он не создаст заметных накладных расходов, но такие незначительные оптимизации всегда следует рассматривать в более широком контексте — что, если в результате инкремента каждого элемента vector<Balance> будет создан миллион таких временных объектов? Лучше всего заранее узнать, как будет использоваться класс, и в случае сомнений провести измерительные тесты.
В этот момент уместно спросить, почему для этих операторов мы должны создавать отдельные функции и не можем использовать методы, как это делается для присвоения? На самом деле вы можете объявить эти операторы как методы класса, но это не позволит создавать коммутативные операторы. Чтобы сделать оператор коммутативным, его потребуется объявить как метод в обоих классах, которые будут участвовать в операции, и это сработает (хотя и только для классов, знающих о внутренних членах друг друга), но если нет доступных конструкторов, это не сработает для операторов, использующих встроенные типы, и даже если конструкторы есть, придется платить за создание временных объектов.
Перегрузка операторов — это мощная возможность С++, и аналогично множественному наследованию имеются как ее сторонники, так и противники. На самом деле большая часть популярных языков не поддерживает ее совсем. Однако при осторожном использовании она дает возможность писать качественный и компактный код, использующий классы.
Большая часть стандартных операторов имеет несколько значений, и в общем случае вы должны следовать общепринятым соглашениям. Например, оператор << означает битовый сдвиг влево или, при работе с потоками, помещение чего-либо в поток, как здесь.
cout << "Это записывается в поток стандартного вывода.\n.";
Если вы решите перегрузить << для одного из своих классов, он должен делать одно из этих действий или, по крайней мере, аналогичное им. Перегрузка оператора — это одно, а придание им другого семантического смысла — это совсем другое. Если вы не вводите новое соглашение, повсеместно используемое в вашем приложении или библиотеке (что все равно является плохой идеей), и оно не является интуитивно понятным кому-либо еще, кроме вас, следует строго придерживаться стандартных значений.
Чтобы эффективно перегрузить операторы, требуется проделать большое количество черновой работы. Но ее требуется проделать только один раз, и она будет окупаться каждый раз, когда ваш класс будет использоваться в простых выражениях. При умеренном и разумном использовании перегрузки операторов она может сделать код легким как для чтения, так и для написания.
Смотри также
Рецепт 8.13.
8.15. Вызов виртуальной функции родительского класса
Проблема
Требуется вызвать функцию родительского класса, но она переопределена в производном классе, так что обычный синтаксис p->method() не дает нужного результата.
Решение
Укажите полное имя вызываемого метода, включая имя родительского или базового класса (если есть только два класса, например). (См. пример 8.16.)
Пример 8.16. Вызов определенной версии виртуальной функции
#include <iostream>
using namespace std;
class Base {
public:
 virtual void foo() {cout << "Base::foo()" << endl;}
};
class Derived : public Base {
public:
 virtual void foo() {cout << "Derived::foo()" << endl;}
};
int main() {
 Derived* p = new Derived();
 p->foo();       // Вызов версии производного класса
 p->Base::foo(); // Вызов версии базового класса
}
Обсуждение
Регулярное использование переопределения полиморфных возможностей C++ является плохой идеей, но иногда это требуется сделать. Как и в случае с большинством других методик С++, это по большей части вопрос синтаксиса. Когда требуется вызвать определенную версию виртуальной функции базового класса, просто укажите ее имя после имени этого класса, как это сделано в примере 8.16.
p->Base::foo();
Здесь будет вызвана версия foo, определенная в Base, а не та, которая определена в каком-то из подклассов Base, на который указывает p.
Глава 9
Исключения и безопасность
9.0. Введение
Данная глава содержит рецепты по обработке исключений в С++. Язык C++ обеспечивает необходимую поддержку работы с исключениями, и, используя некоторые приемы, вы сможете создавать программный код, в котором исключительные ситуации эффективно обрабатываются и легко отлаживаются.
Первый рецепт описывает семантику C++ по выбрасыванию (throwing) и перехвату (catching) исключений и затем показывает, как создавать класс для представления исключений. Это является хорошей отправной точкой, если у вас мало или совсем нет опыта работы с исключениями. Здесь описываются также стандартные классы исключений, определенные в заголовочных файлах <stdexcept> и <exception>.
Остальные рецепты иллюстрируют методы оптимального использования исключений и попутно вводят несколько важных терминов. Программное обеспечение не станет хорошим, если вы будете просто выбрасывать исключение, когда происходит что-нибудь неожиданное, или перехватывать исключение только для того, чтобы напечатать сообщение об ошибке и завершить программу аварийно. Для эффективного использования средств C++ по обработке исключений вам придется создавать программный код, который предотвращает утечку ресурсов и обеспечивает четкий режим работы при выбрасывании исключения. Эти условия известны как базовые и строгие гарантии безопасности исключений. Я описываю методы, которые позволят вам обеспечить эти гарантии для конструкторов и различных функций-членов.
9.1. Создание класса исключения
Проблема
Требуется создать свой собственный класс исключения, предназначенный для выбрасывания и перехвата исключений.
Решение
Вы можете выбрасывать (throw) или перехватывать (catch) любые типы С++, которые удовлетворяют некоторым простым требованиям, а именно имеют конструктор копирования и деструктор. Однако исключения являются сложными объектами, поэтому при проектировании класса, который представляет исключительные ситуации, необходимо рассмотреть ряд вопросов. Пример 9.1 показывает, каким может быть простой класс исключения.
Пример 9.1. Простой класс исключения
#include <iostream>
#include <string>
using namespace std;
class Exception {
public:
 Exception(const string& msg) : msg_(msg) {}
 ~Exception() {}
 string getMessage() const {return(msg_);}
private:
 string msg_;
};
void f() {
 throw(Exception("Mr. Sulu"));
}
int main() {
 try {
  f();
 } catch(Exception& e) {
  cout << "You threw an exception: " << e.getMessage() << endl;
 }
}
Обсуждение
В языке C++ поддержка исключений обеспечивается при помощи трех ключевых слов: try, catch и throw. Они имеют следующий синтаксис.
try {
 // Что-нибудь, что может вызвать функцию "throw", например:
 throw(Exception("Uh-oh"));
} catch(Exception& e) {
 // Какие-нибудь полезные действия с объектом исключения е
}
Исключение в C++ (аналогично в Java и С#) - это способ, позволяющий поместить сообщение в бутылку, выбросить ее за борт и надеяться, что кто-нибудь пытается найти ваше сообщение где-нибудь ниже по стеку вызовов. Это является альтернативой другим, более простым методам, когда, например, возвращается код ошибки или выдается сообщение об ошибке. Семантика использования исключений (например, «попытка выполнения» каких-то действий, «выбрасывание» исключения с последующим его «перехватом») отличается от других операций С++, поэтому перед описанием способа создания класса исключения я кратко отвечу на вопрос, что представляет собой исключение и что значит выбросить и перехватить его.
Когда возникает исключительная ситуация и вы полагаете, что вызывающая программа должна быть осведомлена об этом, можете «поместить ваше сообщение в бутылку» в операторе throw, как показано ниже.
throw(Exception("Something went wrong"));
В результате среда времени выполнения сконструирует объект Exception (исключение), и затем начинается раскрутка стека вызовов до тех пор, пока не найдется блок try, в который был сделан вход, но из которого еще не сделан выход. Если среда времени выполнения не найдет такой блок, т.е. достигнет функции main (или верхний уровень текущего потока вычислений), и не может дальше раскручивать стек вызовов, вызывается специальная глобальная функция terminate. Но если блок try найден, то просматривается каждый оператор catch для данного блока try и находится тот, который перехватывает тип исключения, который был только что выброшен. Подойдет оператор примерно такого вида.
catch(Exception& е) { //...
В этом месте на основе выброшенного исключения создается новый объект Exception с помощью конструктора копирования класса Exception. (Объект исключения в области видимости throw является временным и может быть удален компилятором при оптимизации.) Первоначальное исключение уничтожается, поскольку осуществлен выход из диапазона его видимости и выполняется тело оператора catch.
Если, находясь в теле оператора catch, вы хотите только что перехваченное исключение передать дальше, вы можете вызвать функцию throw без аргументов.
throw;
Это приведет к тому, что процесс обработки исключения будет продолжен на следующие уровни стека вызовов, пока не будет найден другой подходящий обработчик. Это позволяет каждой области видимости перехватывать исключение, выполнять какие-то полезные действия и затем повторно выбрасывать исключение после завершения (или незавершения) таких действий.
Вышесказанное представляет собой ускоренный курс описания процессов выбрасывания и перехвата исключений. Теперь, когда вы обладаете этой информацией, давайте рассмотрим пример 9.1. Вы можете сконструировать исключение Exception, содержащее указатель символьной строки или строку string, и затем выбрасывать его. Но такой класс не очень полезен, так как он мало чем отличается от класса-оболочки текстового сообщения. Собственно говоря, вы могли бы получить почти такой же результат, используя в качестве объекта исключения просто строку string.
try {
 throw(string("Something went wrong!"));
} catch (string& s) {
 cout << "The exception was: " << s << endl;
}
Нельзя сказать, что этот подход обязательно даст хорошие результаты; моя цель продемонстрировать основное свойство исключения: им может быть любой тип C++. В качестве исключений вы можете выбрасывать тип int, char, class, struct или любой другой тип C++, если действительно это потребуется. Но вам лучше использовать иерархию классов исключений, находящихся либо в стандартной библиотеке, либо ваших собственных.
Одно из самых больших преимуществ применения иерархии классов исключений состоит в том, что это позволяет выразить сущность исключительной ситуации с помощью типа самого класса исключения, а не с помощью кода ошибки, текстовой строки, уровня серьезности ошибки или чего-то подобного. Именно так стандартная библиотека определяет стандартные исключения в заголовочном файле <stdexcept>. Базовым классом исключений в <stdexcept> является exception, который фактически определяется в <exception>. На рис. 9.1 показана иерархия стандартных классов исключений.
Рис. 9.1. Иерархия стандартных классов исключений
Название каждого стандартного класса исключений говорит, для каких исключительных ситуаций он предназначен. Например, класс logic_error (логическая ошибка) представляет ситуации, которые должны отыскиваться при написании или рецензировании программного кода, и его подклассы представляют следующие ситуации: нарушение предусловия, применение индекса, выходящего за допустимый диапазон, использование недопустимого аргумента и т.п. Дополнением логической ошибки является ошибка времени выполнения, которая представляется классом runtime_error. Она предназначена для ситуаций, которые не всегда могут быть выявлены на этапе кодирования программы, например выход за пределы диапазона, переполнение или потеря значимости (underflow).
Это покрывает ограниченный набор исключительных ситуаций, и, вероятно, стандартные классы исключений имеют не все, что вам нужно. По-видимому, вам потребуется иметь исключения, более ориентированные на конкретные приложения, например database_error, network_error, painting_error и т.п. Мы обсудим это позже. А до этого давайте рассмотрим, как работают стандартные исключения.
Поскольку стандартная библиотека использует стандартные классы исключений (допустим это), можно ожидать, что классы из стандартной библиотеки будут их выбрасывать при возникновении проблемной ситуации, например при попытке использовать индекс, выходящий за пределы диапазона вектора vector.
std::vector<int> v;
int i = -1;
// заполнить вектор v...
try {
 i = v.at(v.size()); // Выход на один элемент за конец вектора
} catch (std::out_of_range& е) {
 std::cerr << "Whoa, exception thrown: " << e.what() << '\n';
}
vector<>::at выбросит исключение out_of_range, если вы используете индекс, значение которого меньше или больше, чем size() - 1. Поскольку вам это известно, вы можете написать обработчик, специально предназначенный для этой исключительной ситуации. Если вам не требуется обрабатывать отдельно конкретный тип исключения, а вместо этого вы предпочли бы одинаково обрабатывать все исключения, вы можете перехватить базовый класс всех исключений.
catch(std::exception& е) {
 std::cerr << "Nonspecific exception: " << e.what() << '\n';
}
В результате будет перехватываться любой класс, производный от exception, what — это виртуальная функция-член, которая выдает строку сообщения, зависящую от реализации.
Я почти вернулся в исходную точку. Цель примера 9.1, который сопровождается продолжительным обсуждением, — иллюстрация достоинств класса исключения. Две вещи делают класс исключения полезным: иерархия, отражающая природу исключения, и сообщение, выдаваемое при перехвате исключения и предназначенное для пользователей программы. Иерархия классов исключений позволит разработчикам, использующим вашу библиотеку, создавать безопасный программный код и легко его отлаживать, а текст сообщения позволит тем же самым разработчикам предоставлять конечным пользователям приложения осмысленное сообщение об ошибке.
Исключения представляют собой сложную тему, и безопасная и эффективная обработка исключительных ситуаций является одной из самых трудных задач в проектировании программного обеспечения в целом и на языке C++ в частности. Каким должен быть конструктор, который не приведет к утечке памяти, если исключение выбрасывается в его теле или в списке инициализации? Что такое безопасное исключение? Я отвечу на эти и другие вопросы в последующих рецептах.
9.2. Создание безопасного при исключениях конструктора
Проблема
Ваш конструктор должен обеспечить базовые и строгие гарантии безопасности исключений. См. обсуждение, которое следует за определением «базовых» и «строгих» гарантий.
Решение
Используйте в конструкторе блоки try и catch, чтобы правильно завершить действия по очистке объекта, если в ходе конструирования выбрасывается исключение. В примере 9.2 приводятся простые классы Device и Broker. Broker создает два объекта Device в динамической памяти (heap), но он должен правильно очистить память от этих объектов, если при конструировании выбрасывается исключение.
Пример 9.2. Безопасный при исключениях конструктор
#include <iostream>
#include <stdexcept>
using namespace std;
class Device {
public:
 Device(int devno) {
  if (devno == 2)
   throw runtime_error("Big problem");
 }
 ~Device() {}
};
class Broker {
public:
 Broker (int devno1, int devno2) : dev1_(NULL), dev2_(NULL) {
  try {
   dev1_ = new Device(devno1); // Заключить операторы создания
   dev2_ = new Device(devno2); // объектов в динамической памяти в
                               // блок try ...
  } catch (...) {
   delete dev1_; // ...очистить память и повторно
   throw;        // выбросить исключение, если что-то не
                 // получилось.
  }
 }
 ~Broker() {
  delete dev1_;
  delete dev2_;
 }
private:
 Broker();
 Device* dev1_;
 Device* dev2_;
};
int main() {
 try {
  Broker b(1, 2);
 } catch(exception& e) {
  cerr << "Exception: " << e.what() << endl;
 }
}
Обсуждение
Сказать, что конструктор, функция-член, деструктор или что-нибудь другое «безопасно при исключениях», — значит гарантировать, что при их работе не будет утечки ресурсов и, вероятно, используемые ими объекты не будут находиться в противоречивом состоянии. В языке C++ такого рода гарантии названы базовыми и строгими.
Базовая гарантия безопасности при исключениях, которая интуитивно вполне понятна, означает, что при выбрасывании исключения текущая операция не приведет к утечке ресурсов и вовлеченный в операцию объект по-прежнему можно использовать (т.е. вы можете вызвать другие функции-члены и уничтожить объект, так как его состояние корректно). Это также означает, что программа находится в согласованном состоянии, хотя оно может быть непредсказуемым. Правила простые: если исключение выбрасывается где-нибудь в теле (например) функции-члена, созданные в динамической памяти объекты не лишаются поддержки, а вовлеченные в операцию объекты могут быть уничтожены или восстановлены в вызывающей программе. Другая гарантия, названная строгой гарантией безопасности исключений, обеспечивает неизменность состояния объекта, если операция завершается неудачно. Последнее относится к операциям, которые следуют после конструирования объекта, поскольку по определению объект, который выбрасывает исключение, всегда будет сконструирован не полностью и поэтому всегда будет иметь недостоверное состояние. Я вернусь к функциям-членам в рецепте 9.4. Теперь же давайте основное внимание уделим конструированию объектов.
В примере 9.2 определяется два класса, Device и Broker, которые делают не очень много, но с их помощью можно было бы легко представить любой сценарий работы пары устройство/брокер, когда вы имеете некоторый класс, который открывает соединение к каждому из двух устройств и управляет связью между ними. Брокер бесполезен, если доступно только одно устройство, поэтому семантика обработки транзакций при наличии брокера должна учитывать, что при выбрасывании исключения одним из двух этих устройств, когда делается попытка получения доступа к нему, должно освобождаться другое устройство. Это обеспечивает невозможность утечки памяти и других ресурсов.
Блоки try и catch сделают эту работу. В конструкторе заключите операторы по выделению динамической памяти для объекта в блок try и перехватывайте все исключения, которые выбрасываются в ходе конструирования этого объекта.
try {
 dev1_ = new Device(devno1);
 dev2_ = new Device(devno2);
} catch (...) {
 delete dev1_;
 throw;
}
Многоточие в обработчике catch означает, что любое выброшенное исключение будет перехвачено. В данном случае вам следует поступать именно так, поскольку вы лишь освобождаете память, если что-то не получилось, и затем повторно выбрасываете исключение независимо от его типа. Вам необходимо повторно выбросить исключение, чтобы клиентская программа, которая пытается инстанцировать объект Broker, могла сделать что-то полезное с исключением, например записать куда-нибудь соответствующее сообщение об ошибке.
В catch-обработчике я удаляю лишь dev1_, так как последнее выбрасывание исключения возможно только в операторе new для dev2_. Если он выбрасывает исключение, то переменной dev2_ не будет присвоено никакого значения и, следовательно, мне не нужно удалять объект dev2_. Однако, если вы что-то делаете после инициализации dev2_, вам потребуется выполнить зачистку этого объекта. Например:
try {
 dev1_ = new Device(devno1);
 dev2_ = new Device(devno2);
 foo_ = new MyClass(); // Может выбросить исключение
} catch (...) {
 delete dev1_;
 delete dev2_;
 throw;
}
В этом случае вам не следует беспокоиться об удалении указателей, которым никогда не присваивались реальные значения (если изначально вы не инициализировали их соответствующим образом), поскольку удаление указателя NULL не дает никакого эффекта. Другими словами, если присваивание значения переменной dev1_ приводит к выбрасыванию исключения, ваш catch-обработчик все же выполнит оператор delete dev2_, однако все будет нормально, если вы инициализировали его значением NULL в списке инициализации.
Как я говорил в рецепте 9.1, рассматривая основы обработки исключений, для обеспечения гибкой стратегии обработки исключений может потребоваться особая ловкость, и то же самое относится к обеспечению безопасности исключений. Подробное рассмотрение методов проектирования программного кода, безопасного при исключениях, приводится в книге «Exceptional С++», написанной Гербом Саттером (Herb Sutter) (издательство «Addison Wesley»).
Смотри также
Рецепт 9.3.
9.3. Создание безопасного при исключениях списка инициализации
Проблема
Необходимо инициализировать ваши данные-члены в списке инициализации конструктора, и поэтому вы не можете воспользоваться подходом, описанным в рецепте 9.2.
Решение
Используйте специальный формат блоков try и catch, предназначенный для перехвата исключений, выбрасываемых в списке инициализации. Пример 9.3 показывает, как это можно сделать.
Пример 9.3. Обработка исключений в списке инициализации
#include <iostream>
#include <stdexcept>
using namespace std;
// Некоторое устройство
class Device {
public:
 Device(int devno) {
  if (devno == 2)
   throw runtime error("Big problem");
 }
 ~Device() {}
private:
 Device();
};
class Broker {
public:
 Broker (int devno1, int devno2)
  try : dev1_(Device(devno1)), // Создать эти объекты в списке
   dev2_(Device(devno2)) {}    // инициализации
  catch (...) {
   throw; // Выдать сообщение в журнал событий или передать ошибку
          // вызывающей программе (см. ниже обсуждение)
 }
 ~Broker() {}
private:
 Broker();
 Device dev1_;
 Device dev2_;
};
int main() {
 try {
  Broker b(1, 2);
 } catch(exception& e) {
  cerr << "Exception: " << e.what() << endl;
 }
}
Обсуждение
Синтаксис обработки исключений в списках инициализации немного отличается от традиционного синтаксиса С++, потому что здесь блок try используется в качестве тела конструктора. Критической частью примера 9.3 является конструктор класса Broker.
Broker(int devno1, int devno2) // Заголовок конструктора такой же Constructor
 try :                         // Действует так же, как try {...}
  dev1_(Device(devno1)),       // Затем идут операторы списка
  dev2_(Device(devno2)) {      // инициализации
   // Здесь задаются операторы тела конструктора.
  } catch (...) { // catch обработчик задается *после*
   throw; // тела конструктора
  }
Режим работы блоков try и catch вполне ожидаем; единственное синтаксическое отличие от обычного блока try заключается в том, что при перехвате исключений, выброшенных из списка инициализации, за ключевым словом try идет двоеточие, затем список инициализации и после этого собственно блок try, который является одновременно и телом конструктора. Если какое-нибудь исключение выбрасывается из списка инициализации или из тела конструктора, оно будет перехвачено catch-обработчиком, который расположен после тела конструктора. Вы можете при необходимости добавить в тело конструктора дополнительную пару блоков try/catch, однако вложенные блоки try/catch обычно выглядят непривлекательно.
Кроме перемещения операторов инициализации членов в список инициализации пример 9.3 отличается от примера 9.2 еще одним свойством. Объекты-члены Device на этот раз не создаются в динамической памяти с помощью оператора new. Я сделал это для иллюстрации двух особенностей, связанных с безопасностью и применением объектов-членов.
Во-первых, использование стека вместо объектов динамической памяти позволяет компилятору автоматически обеспечить их безопасность. Если какой-нибудь объект в списке инициализации выбрасывает исключение в ходе конструирования, занимаемая им память автоматически освобождается по мере раскрутки стека в процессе обработки исключения. Во-вторых, что более важно, любые другие объекты, которые уже были успешно сконструированы, уничтожаются, и вам не требуется перехватывать исключения и явно их удалять оператором delete.
Но, возможно, вам требуется иметь члены, использующие динамическую память (или с ними вы предпочитаете иметь дело). Рассмотрим подход, используемый в первоначальном классе Broker в примере 9.2. Вы можете просто инициализировать ваши указатели в списке инициализации, не так ли?
class BrokerBad {
public:
 BrokerBad(int devno1, int devno2)
  try : dev1_(new Device(devno1)), // Создать объекты динамической
   dev2_(new Device(devno2)) {}    // памяти в списке инициализации
  catch (...) {
   if (dev1_) {
    delete dev1_; // He должно компилироваться и
    delete dev2_; // является плохим решением, если
   }              // все же будет откомпилировано
   throw; // Повторное выбрасывание того же самого исключения
  }
 ~BrokerBad() {
  delete dev1_;
  delete dev2_;
 }
private:
 BrokerBad();
 Device* dev1_;
 Device* dev2_;
};
Нет, так делать нельзя. Здесь две проблемы. Прежде всего, это не допустит ваш компилятор, потому что расположенный в конструкторе блок catch не должен позволить программному коду получить доступ к переменным-членам, так как их еще нет. Во-вторых, даже если ваш компилятор позволяет это делать, это будет плохим решением. Рассмотрим ситуацию, когда при конструировании объекта dev1_ выбрасывается исключение. Ниже дается программный код, который будет выполняться в catch-обработчике.
catch (...) {
 if (dev1_) { // Какое значение имеет эта переменная?
  delete dev1_; // в данном случае вы удаляете неопределенное значение
  delete dev2_;
 }
 throw; // Повторное выбрасывание того же самого исключения
}
Если исключение выбрасывается в ходе конструирования dev1_, то оператором new не может быть возвращен адрес нового выделенного участка памяти и значение dev1_ не меняется. Тогда что эта переменная содержит? Она будет иметь неопределённое значение, так как она никогда не инициализировалась. В результате, когда вы станете выполнять оператор delete dev1_, вы, вероятно, попытаетесь удалить объект, используя недостоверный адрес, что приведет к краху программы, вы будете уволены, и вам придется жить с этим позором всю оставшуюся жизнь.
Чтобы избежать такое фиаско, круто изменяющее вашу жизнь, инициализируйте в списке инициализации ваши указатели значением NULL и затем создавайте в конструкторе объекты, использующие динамическую память. В этом случае будет легче перехватывать любую исключительную ситуацию и выполнять подчистку, поскольку допускается использовать оператор delete для NULL-указателей.
BrokerBetter(int devno1, int devno2) :
 dev1_(NULL), dev2_(NULL) {
  try {
   dev1_ = new Device(devno1);
   dev2_ = new Device(devno2);
  } catch (...) {
   delete dev1_; // Это сработает в любом случае
   throw;
  }
 }
Итак, вышесказанное можно подытожить следующим образом: если вам необходимо использовать члены-указатели, инициализируйте их значением NULL в списке инициализации и затем выделяйте в конструкторе память для соответствующих объектов, используя блок try/catch. Вы можете освободить любую память в catch-обработчике. Однако, если допускается работа с автоматическими членами, сконструируйте их в списке инициализации и используйте специальный синтаксис блока try/catch для обработки любых исключений.
Смотри также
Рецепт 9.2.
9.4. Создание безопасных при исключениях функций-членов
Проблема
Создается функция-член и необходимо обеспечить базовые и строгие гарантии ее безопасности при исключениях, а именно отсутствие утечки ресурсов и то, что объект не будет иметь недопустимое состояние в том случае, если выбрасывается исключение.
Решение
Необходимо выяснить, какие операции могут выбрасывать исключения, и следует выполнить их первыми, обычно заключая в блок try/catch. После того как будет выполнен программный код, который может выбрасывать исключение, вы можете изменять состояние объектов. В примере 9.4 показан один из способов обеспечения безопасности функции-члена при исключениях.
Пример 9.4. Безопасная при исключениях функция-член
class Message {
public:
 Message(int bufSize = DEFAULT_BUF_SIZE) :
  bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), buf_(NULL) {
  buf_ = new char[bufSize];
 }
 ~Message() {
  delete[] buf_;
 }
 // Добавить в конец символьные данные
 void appendData(int len, const char* data) {
  if (msgSize_+len > MAX_SIZE) {
   throw out_of_range("Data size exceeds maximum size.");
  }
  if (msgSize_+len > bufSize_) {
   int newBufSize = bufSize_;
   while ((newBufSize *= 2) < msgSize_+len);
   char* p = new char[newBufSize]; // Выделить память
                                   // для нового буфера
   copy(buf_, buf_+msgSize_, p);     // Скопировать старые данные
   copy(data, data+len, p+msgSize_); // Скопировать новые данные
   msgSize_ += len;
   bufSize_ = newBufSize;
   delete[] buf_; // Освободись старый буфер и установить указатель на
   buf_ = p;      // новый буфер
  } else {
   copy(data, data+len, buf_+msgSize_);
   msgSize_ += len;
  }
 }
 // Скопировать данные в буфер вызывающей программы
 int getData(int maxLen, char* data) {
  if (maxLen < msgSize_) {
   throw out_of_range("This data is too big for your buffer.");
  }
  copy(buf_, buf_+msgSize_, data);
  return(msgSize_);
 }
private:
 Message(const Message& orig) {}           // Мы рассмотрим эти операторы
 Message& operator=(const Message& rhs) {} // в рецепте 9.5
 int bufSize_;
 int initBufSize_;
 int msgSize_;
 char* buf_;
};
Обсуждение
Представленный в примере 9.4 класс Message является классом, содержащим символьные данные; вы могли бы использовать его в качестве оболочки текстовых или бинарных данных, которые передаются из одной системы в другую. Здесь нас интересует функция-член appendData, которая добавляет данные, переданные вызывающей программой, в конец данных, уже находящихся в буфере, причем увеличивая при необходимости размер буфера. Здесь обеспечивается строгая гарантия безопасности этой функции-члена при исключениях, хотя на первый взгляд может быть не совсем понятно, чем это достигается.
Рассмотрим следующий фрагмент appendData.
if (msgSize_+len > bufSize_) {
 int newBufSize = bufSize_;
 while ((newBufSize *= 2) < msgSize_+len);
 char* p = new char[newBufSize];
Этот блок программного кода обеспечивает увеличение размера буфера. Я его увеличиваю путем удвоения его размера до тех пор, пока он не станет достаточно большим. Этот фрагмент программного кода безопасен, потому что исключение может быть выброшено здесь только при выполнении оператора new, и я не обновляю состояние объекта и не выделяю память ни под какие другие ресурсы до завершения его выполнения. Этот оператор выбросит исключение bad_alloc, если операционная система не сможет выделить участок памяти необходимого размера.
После успешного распределения памяти я могу начать обновление состояния объекта, копируя данные и обновляя значения переменных-членов.
copy(buf_, buf_+msgSize_, p);
copy(data, data+len, p+msgSize_);
msgSize_ += len;
bufSize_ = newBufSize;
delete[] buf_;
buf_ = p;
Ни одна из этих операций не может выбросить исключение, поэтому нам не о чем волноваться. (Это происходит только из-за того, что буфер представляет собой последовательность символов; дополнительные разъяснения вы найдете при обсуждении примера 9.5.)
Это простое решение и общая стратегия обеспечения строгой безопасности функций- членов при исключениях заключается в следующем: сначала выполняйте все то, что может выбрасывать исключения, затем, когда вся опасная работа окажется выполненной, глубоко вздохните и обновите состояние объекта. appendData просто использует временную переменную для хранения нового размера буфера. Это решает проблему, связанную с размером буфера, но обеспечит ли это на самом деле базовую гарантию отсутствия утечки ресурсов? Обеспечит, но с трудом
сору вызывает operator= для каждого элемента копируемой последовательности. В примере 9.4 каждый элемент имеет тип char, поэтому безопасность обеспечена, так как оператор присваивания одного символа другому не может выбросить никакого исключения. Но я сказал «обеспечит с трудом», потому что безопасность этого специального случая не должна создавать у вас впечатление о том, что причиной исключений никогда не может быть функция copy.
Предположим на секунду, что вместо «узкого» символьного буфера вам необходимо написать класс Message, который может содержать массив каких-то объектов. Вы могли бы представить его как шаблон класса, подобный представленному в примере 9.5.
Пример 9.5. Параметризованный класс сообщения
template<typename T>
class MessageGeneric {
public:
 MessageGeneric(int bufSize = DEFAULT_BUF_SIZE) :
  bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), buf_(new T[bufSize]) {}
 ~MessageGeneric() {
  delete[] buf_;
 }
 void appendData(int len, const data) {
  if (msgSize_+len > MAX_SIZE) {
   throw out of range("Data size exceeds maximum size.");
  }
  if (msgSize_+len > bufSize_) {
   int newBufSize = bufSize_;
   while ((newBufSize *= 2) < msgSize_+len);
   T* p = new T[newBufSize];
   copy(buf_, buf_+msgSize_, p);     // Могут ли эти операторы
   copy(data, data+len, p+msgSize_); // выбросить исключение?
   msgSize_ += len;
   bufSize_ = newBufSize;
   delete[] buf_; // Освободить старый буфер и установить указатель на
   buf_ = p;      // новый буфер
  } else {
   copy(data, data+len, buf_+msgSize_);
   msgSize_ += len;
  }
 }
 // Скопировать данные в буфер вызывающей программы
 int getData(int maxLen, T* data) {
  if (maxLen < msgSize_) {
   throw out of range("This data is too big for your buffer.");
  }
  copy(buf_, buf_+msgSize_, data);
  return(msgSize_);
 }
private:
 MessageGeneric(const MessageGeneric& orig) {}
 MessageGeneric& operator=(const MessageGeneric& rhs) {}
 int bufSize_;
 int initBufSize_;
 int msgSize_;
 T* buf_;
};
Теперь вам необходимо быть более осторожным, так как вы заранее не знаете тип целевого объекта. Например, разве можно быть уверенным, что оператор T::operator= не выбросит исключение? Нельзя, поэтому вам необходимо учесть такую возможность. Заключите вызовы функций копирования в блок try.
try {
 copy(buf_, buf_+msgSize_, p);
 copy(data, data+len, p+msgSize_);
} catch(...) {
 // He имеет значения, какое исключение выбрасывается; все, что
 delete[] p; // мне необходимо сделать - это подчистить за собой,
 throw;      // а затем повторно выбросить исключение.
}
Поскольку оператор catch с многоточием позволяет перехватывать любой тип исключения, пользователи вашего класса могут быть уверены, что при выбрасывании исключения оператором T::operator= вы его перехватите и сможете освободить динамическую память, которая была только что распределена.
Строго говоря, функция copy в действительности ничего не выбрасывает, но это делает оператор T::operator=. Это происходит из-за того, что функция copy и остальные алгоритмы стандартной библиотеки в целом являются нейтральными по отношению к исключениям; это значит, что при выбрасывании исключений во время выполнения каких-либо внутренних операторов это исключение будет передано вызывающей программе, а не будет обработано полностью (перехвачено в блоке catch без повторного выбрасывания этого исключения). Это сохраняет возможность перехвата исключений в блоке catch, выполнения некоторой подчистки с последующим их повторным выбрасываний, но в конце концов все исключения, выброшенные в классе или функции стандартной библиотеки, дойдут до вызывающей программы.
Создание безопасных при исключениях функций-членов — трудоемкая работа. Для этого вам необходимо выявить все места, где могут выбрасываться исключения, и убедиться, что вы правильно их обрабатываете. Когда исключение может выбрасываться? При любом вызове функции. Операторы для встроенных типов данных не могут выбрасывать исключения, а деструкторы никогда не должны выбрасывать исключения, не все остальное, будь это отдельная функция, функция-член, оператор, конструктор и т.д., является потенциальным источником исключения. В приводимых примерах 9.5 и 9.6 в классах и функциях используются исключения с ограниченной областью действия. Классы содержат очень мало переменных-членов, и поведение класса носит дискретный характер. По мере увеличения количества функций-членов и переменных-членов, использования наследования и виртуальных функций задача обеспечения их строгой безопасности при исключениях становится более сложной.
Наконец, как и для большинства других требований, предъявляемых к программному обеспечению, вам требуется обеспечить только тот уровень безопасности исключений, который вам необходим. Другими словами, если вы создаете диалоговый мастер по генерации веб-страниц, график вашей разработки, вероятно, не позволит провести необходимое исследование и тестирование обеспечения в нем строгой безопасности исключений. Так, для вашего заказчика может быть приемлемой ситуация, когда пользователи встречаются иногда с сообщением о неопределенной ошибке: «Неизвестная ошибка, аварийное завершение программы» («Unknown error, aborting»). С другой стороны, если вы создаете программное обеспечение для управления углом ротора вертолета, ваш заказчик, вероятно, будет настаивать на обеспечении более существенных гарантий безопасности, чем вывод сообщения «Неизвестная ошибка, аварийное завершение программы».
9.5. Безопасное копирование объекта
Проблема
Требуется иметь безопасные при исключениях конструктор копирования и оператор присваивания базового класса.
Решение
Примените тактику, предложенную в рецепте 9.4, а именно сначала выполните все действия, которые могут выбрасывать исключения, и изменяйте состояние объектов с помощью операций, которые не могут выбрасывать исключения только после того, как будет завершена вся опасная работа. В примере 9.6 вновь представлен класс Message, который на этот раз содержит определения оператора присваивания и конструктора копирования.
Пример 9.6. Безопасные при исключениях оператор присваивания и конструктор копирования
#include <iostream>
#include <string>
const static int DEFAULT_BUF_SIZE = 3;
const Static int MAX_SIZE = 4096;
class Message {
public:
 Message(int bufSize = DEFAULT_BUF_SIZE) :
  bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), key_("") {
   buf_ = new char[bufSize]; // Примечание: теперь это делается в теле
                            // конструктора
 }
 ~Message() {
  delete[] buf_;
 }
 // Безопасный при исключениях конструктор копирования
 Message(const Message& orig) :
  bufSize_(orig.bufSize_), initBufSize_(orig.initBufSize_),
  msgSize_(orig.msgSize_), key_(orig.key_) {
  // Эта функция может выбросить исключение
  buf_ = new char[orig.bufSize_]; // ...здесь может произойти то же
                                  // самое
  copy(orig.buf_, orig.buf_+msgSize_, buf_); // Здесь нет
 }
 // Безопасный при исключениях оператор присваивания использующий
 // конструктор копирования
 Message& operator=(const Message& rhs) {
  Message tmp(rhs); // Копировать сообщение во временную переменную,
                    // используя конструктор копирования
  swapInternals(tmp); // Обменять значения переменных-членов и членов
                      // временного объекта
  return(*this); // После выхода переменная tmp уничтожается вместе
                 // с первоначальными данными
 }
 const char* data() {
  return(buf_);
 }
private:
 void swapInternals(Messages msg) {
  // Поскольку key_ не является встроенным типом данных, он может
  // выбрасывать исключение, поэтому сначала выполняем действия с ним
  swap(key_, msg.key_);
  // Если предыдущий оператор не выбрасывает исключение, то выполняем
  // действия со всеми переменными-членами, которые являются встроенными
  // типами
  swap(bufSize_, msg.bufSize_);
  swap(initBufSize_, msg.initBufSize_);
  swap(msgSize_, msg.msgSize_);
  swap(buf_, msg.buf_);
 }
 int bufSize_;
 int initBufSize_;
 int msgSize_;
 char* buf;
 string key_;
}
Обсуждение
Вся работа здесь делается конструктором копирования и закрытой функцией-членом swapInternals. Конструктор копирования инициализирует в списке инициализации элементарные члены и один из неэлементарных членов. Затем он распределяет память для нового буфера и копирует туда данные. Довольно просто, но почему используется такая последовательность действий? Вы могли бы возразить, что всю инициализацию можно сделать в списке инициализации, но такой подход может сопровождаться тонкими ошибками.
Например, вы могли бы следующим образом выделить память под буфер в списке инициализации.
Message(const Message& orig) :
 bufSize_(orig bufSize_), initBufSize_(orig initBufSize_),
 msgSize_(orig.msgSize_), key_(orig.key_),
 buf_(new char[orig.bufSize_]) {
  copy(orig.buf_, orig.buf_+msgSize_, buf_);
}
Вы можете ожидать, что все будет нормально, так как если завершается неудачей выполнение оператора new, выделяющего память под буфер, все другие полностью сконструированные объекты будут уничтожены. Но это не гарантировано, потому что члены класса инициализируются в той последовательности, в которой они объявляются в заголовке класса, а не в порядке их перечисления в списке инициализации. Переменные-члены объявляются в следующем порядке.
int bufSize_;
int initBufSize_;
int msgSize_;
char* buf_;
string key_;
В результате buf_ будет инициализироваться перед key_. Если при инициализации key_ будет выброшено исключение, buf_ не будет уничтожен, и у вас образуется участок недоступной памяти. От этого можно защититься путем использования в конструкторе блока try/catch (см. рецепт 9.2), но проще разместить оператор инициализации buf_ в теле конструктора, что гарантирует его выполнение после операторов списка инициализации.
Выполнение функции copy не приведет к выбрасыванию исключения, так как она копирует элементарные значения. Но именно это место является тонким с точки зрения безопасности исключений: эта функция может выбросить исключение, если копируются объекты (например, если речь идет о контейнере, который параметризован типом своих элементов, T); в этом случае вам придется перехватывать исключение и освобождать связанную с ним память.
Вы можете поступить по-другому и копировать объект при помощи оператора присваивания, operator=. Поскольку этот оператор и конструктор копирования выполняют аналогичные действия (например, приравнивают члены моего класса к членам аргумента), воспользуйтесь тем, что вы уже сделали, и вы облегчите себе жизнь. Единственная особенность заключается в том, что вы можете сделать более привлекательным ваш программный код, используя закрытую функцию-член для обмена значений между данными-членами и временным объектом. Мне бы хотелось быть изобретателем этого приема, но я обязан отдать должное Гербу Саттеру (Herb Sutter) и Стефану Дьюхарсту (Stephen Dewhurst), в работе которых я впервые познакомился с этим подходом.
Возможно, вам все здесь ясно с первого взгляда, но я дам пояснения на тот случай, если это не так. Рассмотрим первую строку, в которой создается временный объект tmp с помощью конструктора копирования.
Message tmp(rhs);
В данном случае мы просто создали двойника объекта-аргумента. Естественно, теперь tmp эквивалентен rhs. После этого мы обмениваем значения его членов со значениями членов объекта *this.
swapInternals(tmp);
Вскоре я вернусь к функции swapInternals. В данный момент нам важно только то, что члены *this имеют значения, которые имели члены tmp секунду назад. Однако объект tmp представлял собой копию объекта rhs, поэтому теперь *this эквивалентен rhs. Но подождите: у нас по-прежнему имеется этот временный объект. Нет проблем, когда вы возвратите *this, tmp будет автоматически уничтожен вместе со старыми значениями переменных-членов при выходе за диапазон его видимости.
return(*this);
Все так. Но обеспечивает ли это безопасность при исключениях? Безопасно конструирование объекта tmp, поскольку наш конструктор является безопасным при исключениях. Большая часть работы выполняется функцией swapInternals, поэтому рассмотрим, что в ней делается, и безопасны ли эти действия при исключениях.
Функция swapInternals выполняет обмен значениями между каждым данным-членом текущего объекта и переданного ей объекта. Это делается с помощью функции swap, которая принимает два аргумента a и b, создает временную копию a, присваивает аргумент b аргументу а и затем присваивает временную копию аргументу b. В этом случае такие действия являются безопасными и нейтральными по отношению к исключениям, так как источником исключений здесь могут быть только объекты, над которыми выполняются операции. Здесь не используется динамическая память и поэтому обеспечивается базовая гарантия отсутствия утечки ресурсов.
Поскольку объект key_ не является элементарным и поэтому операции над ним могут приводить к выбрасыванию исключений, я сначала обмениваю его значения. В этом случае, если выбрасывается исключение, никакие другие переменные-члены не будут испорчены. Однако это не значит, что не будет испорчен объект key_. Когда вы работаете с членами объекта, все зависит от обеспечения ими гарантий безопасности при исключениях. Если такой член не выбрасывает исключение, то это значит, что я добился своего, так как обмен значений переменных встроенных типов не приведет к выбрасыванию исключений. Следовательно, функция swapInternals является в основном и строгом смысле безопасной при исключениях.
Однако возникает интересный вопрос. Что, если у вас имеется несколько объектов-членов? Если бы вы имели два строковых члена, начало функции swapInternals могло бы выглядеть следующим образом.
void swapInternals(Message& msg) {
 swap(key_, msg key_);
 swap(myObj_, msg.myObj_);
 // ...
Существует одна проблема: если вторая операция swap выбрасывает исключение, как можно безопасно отменить первую операцию swap? Другими словами, теперь key_ имеет новое значение, но операция swap для myObj_ завершилась неудачей, поэтому key_ теперь испорчен. Если вызывающая программа перехватывает исключение и попытается продолжить работу, как будто ничего не случилось, она теперь будет обрабатывать нечто отличное от того, что было в начале. Одно из решений — предварительно скопировать key_ во временную строку, но это не гарантирует безопасность, так как при копировании может быть выброшено исключение.
Одно из возможных решений состоит в использовании объектов, распределенных в динамической памяти.
void swapInternals(Message& msg) {
 // key имеет тип string*, a myObj_ - тип MyClass*
 swap(key_, msg.key_);
 swap(myObj_, msg.myObj_);
Конечно, это означает, что теперь вам придется больше работать с динамической памятью, но обеспечение гарантий безопасности исключений будет часто оказывать влияние на ваш проект, поэтому будет правильно, если вы начнете думать об этом на ранних этапах процесса проектирования.
Основной лейтмотив этого рецепта не отличается от лейтмотива предыдущих рецептов, связанных с обеспечением безопасности исключений. Сначала выполняйте действия, которые могут создать проблемы, предусмотрите блок try/catch на тот случай, если что-то пойдет не так, и в последнем случае выполните подчистку за собой. Если все проходит нормально, поздравьте себя и обновите состояние объекта.
Смотри также
Рецепт 9.2 и рецепт 9.3.
Глава 10
Потоки и файлы
10.0. Введение
Потоки (streams) являются одной из самых мощных (и сложных) компонент стандартной библиотеки С++. Их применение при простом, неформатированном вводе-выводе в целом не представляет трудностей, однако ситуация усложняется, если необходимо изменить формат с помощью стандартных манипуляторов или приходится писать свои собственные манипуляторы. Поэтому первые несколько рецептов описывают различные способы форматирования вывода потока данных. Следующие два рецепта показывают, как можно записывать объекты класса в поток и считывать их оттуда.
Затем рецепты переходят с темы чтения и записи содержимого файлов на работу с самими файлами (и каталогами). Если в вашей программе используются файлы особенно если такая программа является демоном или процессом на стороне сервера, вам, вероятно, потребуется создавать файлы и каталоги, удалять их, переименовывать и выполнять другие операции над ними. Существует ряд рецептов, которые показывают, как следует решать эти непривлекательные, но необходимые задачи в С++.
Последняя треть рецептов показывает, как можно манипулировать именами файлов и путями доступа к ним, используя многие стандартные строковые функции-члены. Стандартные строки содержат массу функций, предназначенных для анализа и манипулирования их содержимым, и если вам придется анализировать пути доступа к файлам и имена файлов, эти функции окажутся полезными. Если в этих рецептах нет того, что вам требуется, вернитесь к главе 7: возможно, там описано то, что вы ищете.
Манипулирование файлами требует прямого взаимодействия с операционной системой (ОС), но между различными ОС часто имеются тонкие отличия (а иногда вопиющие несовместимости). Многие типичные операции над файлами и каталогами выполняются с помощью вызовов системных функций стандартной библиотеки С. которые работают одинаково или аналогично в различных системах. В рецептах я отмечаю отличия версий библиотек различных ОС там, где они имеются.
Как я отмечал в предыдущих главах, Boost — это проект открытого исходного кода, результатом которого стал ряд высококачественных и переносимых библиотек. Однако поскольку данная книга посвящена C++, а не проекту Boost, во всех возможных случаях я предпочитаю пользоваться стандартными решениями С++. Однако во многих случаях (наиболее примечательный — рецепт 10.12) нельзя получить решения, используя стандартную библиотеку С++, поэтому я пользуюсь библиотекой Boost Filesystem, написанной Биманом Дейвисом (Beman Dawes); она обеспечивает переносимый интерфейс для файловой системы, позволяя получать переносимые решения. Используйте библиотеку Boost Filesystem, если требуется обеспечить переносимость взаимодействия с файловой системой, и это позволит вам сэкономить много времени и многих усилий. Дополнительную информацию по проекту Boost вы найдете на сайте www.boost.org.
10.1. Вывод выровненного текста
Проблема
Требуется вывести текст, выровненный по вертикали. Например, если ваши данные представлены в табличном виде, вам захочется, чтобы они выглядели следующим образом.
Jim    Willсох   Mesa         AZ
Bill   Johnson   San Mateo    CA
Robert Robertson Fort Collins CO
Кроме того, вам, вероятно, захочется иметь возможность выравнивать текст вправо или влево.
Решение
Используйте определенные в <ostream> типы ostream или wostream для узких или широких символов и стандартные манипуляторы потоков для установки размера полей и выравнивания текста. Пример 10.1 показывает, как это можно сделать.
Пример 10.1. Вывод выровненного текста
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
int main() {
 ios_base::fmtflags flags = cout.flags();
 string first, last, citystate;
 int width = 20;
 first = "Richard";
 last = "Stevens";
 citystate = "Tucson, AZ";
 cout << left             // Каждое поле выравнивается влево.
  << setw(width) << first // Затем для каждого поля
  << setw(width) << last  // устанавливается его ширина и
                          // записываются некоторые данные
  << setw(width) << citystate << endl;
 cout.flags(flags);
}
Вывод выглядит следующим образом.
Richard            Stevens            Tucson, AZ
Обсуждение
Манипулятор — это функция, которая выполняет некоторую операцию над потоком. Применяемые к потоку манипуляторы задаются в операторе operator<<. Формат потока (ввода и вывода) задается набором флагов и установочных параметров конечного базового класса потока, ios_base. Манипуляторы обеспечивают удобный способ настройки этих флагов и установочных параметров без явного использования для этой цели функций setf или flags, которые громоздки и воспринимаются с трудом. Для форматирования потока вывода лучше всего использовать манипуляторы.
В примере 10.1 используется два манипулятора для вывода текста в две колонки. Манипулятор setw задает размер поля, a left обеспечивает выравнивание влево находящегося в поле значения (дополнением манипулятора left, что неудивительно, является right). Когда вы используете слово «поле», вы просто говорите, что хотите дополнить заполнителем выдаваемое в поле значение с одной или с другой стороны, чтобы только ваше значение выводилось в этом поле. Если, как в примере 10.1, вы выравниваете значение влево и затем задаете размер поля, следующее записываемое в поток значение будет начинаться с первой позиции этого поля. Если переданные в поток данные имеют недостаточный размер и не могут заполнить все пространство поля, то правая часть поля будет дополнена символом заполнителя потока, которым по умолчанию является одиночный пробел. Вы можете изменить символ заполнителя с помощью манипулятора setfill.
myostr << setfill('.') << "foo";
Если помещаемое в поле значение превышает его размер, будет напечатано все значение и никаких дополнительных символов выводиться не будет.
Табл. 10.1 содержит краткое описание манипуляторов, работающих с любыми типами значений (текстом, числами с плавающей точкой, целыми числами и т.д.). Имеется ряд манипуляторов, которые применяются только при выводе чисел с плавающей точкой — они описываются в рецепте 10.2.
Табл. 10.1. Текстовые манипуляторы
Манипулятор	Описание	Пример вывода
left right	Выровнять значения в текущем поле вправо или влево, заполняя незанятое пространство символом-заполнителем	Выравнивание влево apple      banana     cherry     Выравнивание вправо (ширина поля 10)      apple     banana     cherry
setw(int n)	Установить размер поля на n символов	См. предыдущий пример
setfill(int с)	Использовать символ с для заполнения незанятого пространства поля	cout << setfill('.') << setw(10) << right << "foo" Выдает: .......foo
boolalpha noboolalpha	Отобразить булевы значения в текущем локализованном представлении слов true и false, а не 1 и 0	cout << boolalpha << true Выдает: true
endl	Записать в поток символ новой строки (newline) и очистить буфер вывода	Нет
ends	Записать в поток null-символ ('\0')	Нет
flush	Очистить буфер вывода	Нет
Некоторые представленные в табл. 10.1 (и в табл. 10.2 в следующем рецепте) манипуляторы переключают бинарные флаги потоков и в действительности реализуются как два манипулятора, которые включают и отключают флаг. Например, возьмем манипулятор boolalpha. Если вы хотите, чтобы булевы значения отображались в соответствии с текущей локализацией (например, «true» и «false»), используйте манипулятор boolalpha. Для отключения этого режима, чтобы вместо слов печатались 0 и 1, используйте манипулятор noboolalpha (он используется по умолчанию).
Действие всех манипуляторов сохраняется до тех пор, пока оно не будет явно изменено, исключая манипулятор setw. Из примера 10.1 видно, что он вызывается перед каждой записью, однако left используется только один раз. Это объясняется тем, что ширина поля устанавливается в нуль после записи каждого значения в поток при помощи оператора operator<<; чтобы обеспечить одинаковую ширину всех полей, мне пришлось каждый раз вызывать setw.
Стандартные манипуляторы позволяют делать многое, но не все. Если у вас возникает потребность в написании собственного манипулятора, см. рецепт 10.2.
Как и все другие классы стандартной библиотеки, работающие с символами, манипуляторы работают с потоками узких или широких символов. Поэтому вы можете использовать их в шаблонах для написания утилит форматирования, обрабатывающих потоки символов любого вида. В примере 10.2 приводится шаблон класса TableFormatter, который форматирует данные в колонки одинаковой ширины и выдает их в поток.
Пример 10.2. Параметрический класс для табличного представления данных
#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
using namespace std;
// TableFormatter выдает в поток вывода символы типа T в форматированном
// виде.
template<typename T>
class TableFormatter {
public:
 TableFormatter(basic_ostream<T>& os) : out_(os) {}
 ~TableFormatter() {out_ << flush;}
 template<typename valT>
 void writeTableRow(const vector<valT>& v, int width);
 //...
private:
 basic_ostream<T>& out_;
};
template<typename T, // ссылается на список параметров шаблона класса
 typename valT>      // ссылается на список параметров функции-члена
void TableFormatter<T>::writeTableRow(const std::vector<valT>& v,
 int width) {
 ios_base::fmtflags flags = out_.flags();
 out_.flush();
 out_ << setprecision(2) << fixed; // Задать точность в случае применения
                                   // чисел с плавающей точкой
 for (vector<valT>::const_iterator p = v.begin(); p != v.end(); ++p)
  out_ << setw(width) << left << *p; // Установить ширину поля, его
                                     // выравнивание и записать элемент
  out_ << endl; // Очистить буфер
 out setf(flags); // Восстановить стандартное состояние флагов
}
int main() {
 TableFormatter<char> fmt(cout);
 vector<string> vs;
 vs.push_back("Sunday");
 vs.push_back("Monday");
 vs.push_back("Tuesday");
 fmt.writeTableRow(vs, 12);
 fmt.writeTableRow(vs, 12);
 fmt.writeTableRow(vs, 12);
 vector<double> vd;
 vd.push_back(4.0);
 vd.push_back(3.0);
 vd.push_back(2.0);
 vd.push_back(1.0);
 fmt.writeTableRow(vd, 5);
}
Вывод представленной в примере 10.2 программы выглядит следующим образом.
Sunday     Monday      Tuesday
4.00 3.00 2.00 1.00
Смотри также
Таблица 10.1, рецепт 10.2.
10.2. Форматирование вывода чисел с плавающей точкой
Проблема
Требуется выдать числа с плавающей точкой в удобном формате либо ради обеспечения необходимой точности (применяя нотацию, которая используется в науке, а не в виде числа с фиксированной точкой), либо просто выравнивая значения по десятичной точке для лучшего восприятия.
Решение
Используйте стандартные манипуляторы, определенные в <iomanip> и <ios>, для управления форматом значений чисел с плавающей точкой при их записи в поток. Это можно делать очень многими способами, и в примере 10.3 предлагается несколько способов отображения значения числа «пи».
Пример 10.3. Форматирование числа «пи»
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
int main() {
 ios_base::fmtflags flags = // Сохранить старые флаги
 cout.flags();
 double pi = 3.14285714;
 cout << "pi = " << setprecision(5) // Обычный (стандартный) режим;
  << pi << '\n';                    // показать только 5 цифр в сумме
                                    // по обе стороны от точки.
 cout << "pi = " << fixed // Режим чисел с фиксированной точкой;
  << showpos              // выдать "+" для положительных чисел.
  << setprecision(3)      // показать 3 цифры *справа* от
  << pi << '\n';          // десятичной точки.
 cout << "pi = " << scientific // Режим научного представления;
  << noshowpos                 // знак плюс больше не выдается
  << pi * 1000 << '\n';
 cout.flags(flags); // Восстановить значения флагов
}
Это приведет к получению следующего результата.
pi = 3.1429
pi = +3.143
pi = 3.143е+003
Обсуждение
Манипуляторы, работающие с числами с плавающей точкой, делятся на две категории. Одни из них задают формат и в данном рецепте устанавливают общий вид целых значений и значений чисел с плавающей точкой, а другие используются для тонкой настройки каждого формата. Предусмотрены следующие форматы.
Обычный (стандартный)
В этом формате фиксировано количество отображаемых цифр (по умолчанию это количество равно шести), а десятичная точка отображается в соответствующем месте. Поэтому число «пи» по умолчанию будет иметь вид 3.14286, а умноженное на 100 будет отображаться как 314.286.
Фиксированный
В этом формате фиксировано количество цифр, отображаемое справа от десятичной точки, а количество цифр слева не фиксировано. В этом случае при стандартной точности, равной шести, число «пи» будет отображаться в виде 3.142857, а умноженное на 100 — 314.285714. В обоих случаях количество цифр, отображаемое справа от десятичной точки, равно шести, а общее количество цифр может быть любым.
Научный
Значение начинается с цифры, затем идет десятичная точка и несколько цифр, количество которых определяется заданной точностью; затем идет буква «е» и степень 10, в которую надо возвести предыдущее значение. В этом случае число «пи», умноженное на 1000, будет отображаться как 3.142857е+003.
В табл. 10.2 приводятся все манипуляторы, которые воздействуют на вывод чисел с плавающей точкой (а иногда и на вывод любых чисел). См. табл. 10.1, где приводятся манипуляторы общего типа, которые можно использовать совместно с манипуляторами чисел с плавающей точкой.
Табл. 10.2. Манипуляторы, работающие с любыми числами и числами с плавающей точкой
Манипулятор	Описание	Пример вывода
fixed	Показать значение чисел с плавающей точкой с фиксированным количеством цифр справа от десятичной точки	При стандартной точности, равной шести цифрам: pi = 3.142857
scientific	Показать значение чисел с плавающей точкой, применяя научную нотацию, в которой используется значение с десятичной точкой и экспонентный множитель	pi * 1000 при стандартной точности, равной шести цифрам: pi = 3.142857е+003
setprecision	Установить количество цифр, отображаемых в выводе (см. последующие объяснения)	Число «пи» в стандартном формате при точности, равной трем цифрам: pi = 3.14
В фиксированном формате: pi = 3.143
В научном формате: pi = 3.143е+000
showpos noshowpos	Показать знак «плюс» перед положительными числами. Это действует для чисел любого типа, с десятичной точкой или целых	+3.14
showpoint noshowpoint	Показать десятичную точку, даже если после нее идут одни нули. Это действует только для чисел с плавающей точкой и не распространяется на целые числа	Следующая строка при точности, равной двум цифрам: cout << showpoint << 2.0 выдаст такой результат: 2.00
showbase noshowbase	Показать основание числа, представленного в десятичном виде (основание отсутствует), в восьмеричном виде (ведущий нуль) или в шестнадцатеричном виде (префикс 0x). См. следующую строку таблицы	Десятичное представление: 32 Восьмеричное: 040 Шестнадцатеричное: 0x20
dec oct hex	Установить основание для отображения числа в десятичном, восьмеричном или шестнадцатеричном виде. Само основание по умолчанию не отображается; для его отображения используйте showbase	См предыдущую строку таблицы
uppercase nouppercase	Отображать значения, используя верхний регистр	Устанавливает регистр вывода чисел, например для префикса 0X шестнадцатеричных чисел или буквы E для чисел, представленных в научной нотации
Все манипуляторы, кроме setprecision, одинаково воздействуют на все три формата. В стандартном режиме «точность» определяет суммарное количество цифр по обе стороны от десятичной точки. Например, для отображения числа «пи» в стандартном формате с точностью, равной 2, выполните следующие действия.
cout << "pi = " << setprecision(2) << pi << '\n';
В результате вы получите
pi = 3.1
Для сравнения представим, что вам требуется отобразить число «пи» в формате чисел с плавающей точкой.
cout << "pi = " << fixed << setprecision(2) << pi << '\n';
Теперь результат будет таким.
pi = 3.14
Отличие объясняется тем, что здесь точность определяет количество цифр, расположенных справа от десятичной точки. Если мы умножим число «пи» на 1000 и отобразим в том же формате, количество цифр справа от десятичной точки не изменится.
cout << "pi = " << fixed << setprecision(2) << pi * 1000 << '\n';
выдает в результате:
pi = 3142.86
Это хорошо, потому что вы можете задать точность, установить ширину своего поля при помощи setw, выровнять вправо отображаемое значение при помощи right (см. рецепт 10.1), и ваши числа будут выровнены вертикально по десятичной точке.
Поскольку манипуляторы — это просто удобный способ установки флагов формата для потока, следует помнить, что заданные установки работают до тех пор, пока вы их не уберете или пока поток не будет уничтожен. Сохраните флаги формата (см. пример 10.3) до того, как вы начнете его изменять, и восстановите их в конце.
Смотри также
Рецепт 10.3.
10.3. Написание своих собственных манипуляторов потока
Проблема
Требуется иметь манипулятор потока, который делает что-нибудь такое, что не могут делать стандартные манипуляторы. Или вам нужен такой один манипулятор, который устанавливает несколько флагов потока, и вам не приходится вызывать несколько манипуляторов всякий раз, когда необходимо установить конкретный формат вывода.
Решение
Чтобы создать манипулятор, который не имеет аргументов (типа left), напишите функцию, которая принимает в качестве параметра ios_base и устанавливает для него флаги потока. Если вам нужен манипулятор с аргументом, см. приводимое ниже обсуждение. Пример 10.4 показывает возможный вид манипулятора без аргументов.
Пример 10.4. Простой манипулятор потока
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
// вывести числа с плавающей точкой в обычном виде
inline ios_base& floatnormal(ios_base& io) {
 io.setf(0, ios_base::floatfield);
 return(io);
}
int main() {
 ios_base::fmtflags flags = // Сохранить старые флаги
  cout.flags();
 double pi = 22.0/7.0;
 cout << pi = " << scientific // Научный режим
  << pi * 1000 << '\n';
 cout << "pi = " << floatnormal << pi << '\n';
 cout.flags(flags);
}
Обсуждение
Существует два вида манипуляторов: с аргументами и без аргументов. Манипуляторы без аргументов пишутся просто. Вам требуется только написать функцию, которая принимает в качестве параметра поток, выполнить с ним какие-то действия (установить флаги или изменить установочные параметры) и возвратить его. Сложнее написать манипулятор, который имеет один или несколько аргументов, потому что потребуется создавать дополнительные классы и функции, которые работают «за кулисами». Поскольку манипуляторы без аргументов более простые, начнем с них.
Прочитав рецепт 10.1, вероятно, вы поняли, что существует три формата вывода чисел с плавающей точкой и только два манипулятора для выбора формата. Для используемого по умолчанию формата не предусмотрен манипулятор; вам придется соответствующим образом установить флаг для потока, чтобы вернуться к стандартному формату:
myiostr.setf(0, ios_base::float field);
Но для удобства вы можете добавить свой собственный манипулятор, делающий то же самое. Именно это сделано в примере 10.4. Манипулятор floatnormal устанавливает соответствующий флаг потока для вывода чисел с плавающей точкой в стандартном формате.
Компилятор знает, что делать с вашей новой функцией, потому что в стандартной библиотеке определен следующий оператор для basic_ostream (basic_ostream — имя шаблона класса, инстанцируемого в классах ostream и wostream).
basic_ostream<charT, traits>& operator<<
 (basic_ostream<charT, traits>& (* pf)basic_ostream<charT, traits>&))
Здесь pf — это указатель функции, которая принимает в аргументе ссылку на basic_ostream и возвращает ссылку на basic_ostream. Этот оператор просто обеспечивает вызов вашей функции, которая принимает в качестве аргумента текущий поток.
Манипуляторы с аргументами более сложные. Чтобы понять причину этого, рассмотрим работу манипулятора без аргументов. Пусть используется, например, следующий манипулятор
myostream << myManip << "foo";
Вы задаете его без скобок, поэтому его имя в действительности заменяется адресом функции вашего манипулятора. В действительности operator<< вызывает функцию манипулятора и передает ей поток, чтобы манипулятор мог выполнить свою работу.
Для сравнения представим, что у вас имеется манипулятор, который принимает числовой аргумент, так что в идеале вы могли бы его использовать следующим образом.
myostream << myFancyManip(17) << "apple";
Как это будет работать? Если вы считаете, что myFancyManip является функцией, принимающей целочисленный аргумент, то возникает проблема: как передать поток в функцию без включения его в параметры и явного его использования? Вы могли бы написать так.
myostream << myFancyManip(17, myostream) << "apple";
Но это выглядит непривлекательно и избыточно. Одним из удобств манипуляторов является то, что их можно просто добавлять в строку с группой операторов operator<<, и они хорошо воспринимаются и используются.
Решение состоит в том, чтобы заставить компилятор пойти окольным путем. Вместо того чтобы operator<< вызывал функцию вашего манипулятора для потока, вам надо просто создать временный объект, который возвращает нечто такое, что может использовать operator<<.
Во-первых, вам необходимо определить временный класс, который делал бы всю работу. Для простоты предположим, что вам требуется написать манипулятор с именем setWidth, который делает то же самое, что и setw. Временная структура, которую вам необходимо построить, будет выглядеть примерно так.
class WidthSetter {
public:
 WidthSetter(int n) : width_(n) {}
 void operator()(ostream& os) const {os.width(width_);}
private:
 int width_;
};
Этот класс содержит простую функцию. Предусмотрите в ней целочисленный аргумент и, когда operator() вызывается с аргументом потока, установите ширину для потока в значение, в какое она была установлена при инициализации этого объекта. В результате мы получим WidthSetter, сконструированный одной функцией и используемый другой. Ваш манипулятор конструирует эту функцию, и это будет выглядеть следующим образом.
WidthSetter setWidth(int n) {
 return(WidthSetter(n)); // Возвращает инициализированный объект
}
Эта функция всего лишь возвращает объект WidthSetter, инициализированный целым значением. Этот манипулятор вы будете использовать в строке операторов operator<< следующим образом.
myostream << setWidth(20) << "banana";
Но этого недостаточно, потому что setWidth просто возвращает объект WidthSetter; operator<< не будет знать, что с ним делать. Вам придется перегрузить operator<<, чтобы он знал, как управлять объектом WidthSetter:
ostream& operator<<(ostream& os, const WidthSetter& ws) {
 ws(os);     // Передать поток объекту ws
 return(os); // для выполнения реальной работы
}
Это решает проблему, но не в общем виде. Вам не захочется писать класс типа WidthSetter для каждого вашего манипулятора, принимающего аргумент (возможно, вы это и делаете, но были бы не против поступить по-другому), поэтому лучше использовать шаблоны и указатели функций для получения привлекательной, обобщенной инфраструктуры, на базе которой вы можете создавать любое количество манипуляторов. Пример 10.5 содержит класс ManipInfra и версию operator<<, использующую аргументы шаблона для работы с различными типами символов, которые может содержать поток, и с различными типами аргументов, которые могут быть использованы манипулятором потока.
Пример 10.5. Инфраструктура манипуляторов
#include <iostream>
#include <string>
using namespace std;
// ManipInfra - это небольшой промежуточный класс, который помогает
// создавать специальные манипуляторы с аргументами. Вызывайте его
// конструктор с предоставлением указателя функции и значения из основной
// функции манипулятора
// Указатель функции должен ссылаться на вспомогательную функцию, которая
// делает реальную работу. См. примеры ниже
template<typename T, typename C>
class ManipInfra {
public:
 ManipInfra(basic_ostream<C>& (*pFun) (basic_ostream<C>&, T), T val) :
  manipFun_(pFun), val_(val) {}
 void operator()(basic_ostream<C>& os) const {
  manipFun_(os, val_);
 }       // Вызовите функцию, задавая ее указатель и
private: // передавая ей поток и значение
 T val_;
 basic_ostream<С>& (*manipFun_) (basic_ostream<C>&, T);
};
template<typename T, typename C>
basic_ostream<C>& operator<<(basic_ostream<C>& os,
 const ManipInfra<T, C>& manip) {
 manip(os);
 return(os);
}
// Вспомогательная функция, которая вызывается в итоге в классе ManipInfra
ostream& setTheWidth(ostream& os, int n) {
 os.width(n);
 return(os);
}
// Собственно функция манипулятора. Именно она используется в клиентском
// программном коде
ManipInfra<int, char> setWidth(int n) {
 return(ManipInfra<int, char>(setTheWidth, n));
}
// Ещё одна вспомогательная функция, которая принимает аргумент типа char
ostream& setTheFillChar(ostream& os, char с) {
 os.fill(c);
 return(os);
}
ManipInfra<char, char> setFill(char c) {
 return(ManipInfra<char, char>(setTheFillChar, c));
}
int main() {
 cout << setFill('-')
  << setWidth(10) << right << "Proust\n";
}
Если последовательность событий при работе этого класса все же остается неясной, я советую прогнать пример 10.5 через отладчик. Увидев его реальную работу, вы все поймете.
10.4. Создание класса, записываемого в поток
Проблема
Требуется записать класс в поток для последующего его чтения человеком или с целью его хранения в постоянной памяти, т.е. для его сериализации.
Решение
Перегрузите operator<< для записи в поток соответствующих данных-членов. В примере 10.6 показано, как это можно сделать.
Пример 10.6. Запись объектов в поток
#include <iostream>
#include <string>
using namespace std;
class Employer {
 friend ostream& operator<<             // Он должен быть другом для
  (ostream& out, const Employer& empr); // получения доступа к неоткрытым
public:                                 // членам
 Employer() {}
 ~Employer() {}
 void setName(const string& name) {name_ = name;}
private:
 string name_;
};
class Employee {
friend ostream& operator<< (ostream& out, const Employee& obj);
public:
 Employee() : empr_(NULL) {}
 ~Employee() {if (empr_) delete empr_;}
 void setFirstName(const string& name) {firstName_ = name;}
 void setLasttName(const string& name) {lastName_ = name;}
 void setEmployer(Employer& empr) {empr_ = &empr;}
 const Employer* getEmployer() const {return(empr_);}
private:
 string firstName_;
 string lastName_;
 Employer* empr_;
};
// Обеспечить передачу в поток объектов
Employer... ostream& operator<<(ostream& out, const Employer& empr) {
 out << empr.name_ << endl; return(out);
}
// Обеспечить передачу в поток объектов Employee...
ostream& operator<<(ostream& out, const Employee& emp) {
 out << emp.firstName_ << endl;
 out << emp.lastName_ << endl;
 if (emp.empr_) out << *emp.empr_ << endl;
  return(out);
}
int main() {
 Employee emp;
 string first = "William";
 string last = "Shatner";
 Employer empr;
 string name = "Enterprise";
 empr.setName(name);
 emp.setFirstName(first);
 emp.setLastName(last);
 emp.setEmployer(empr);
 cout << emp; // Запись в поток
}
Обсуждение
Прежде всего, необходимо объявить оператор operator<< другом (friend) класса, который вы хотите записывать в поток. Вы должны использовать operator<<, а не функцию-член типа writeToStream(ostream& os), потому что этот оператор принято использовать в стандартной библиотеке для записи любых объектов в поток. Вам придется объявить его другом, потому что в большинстве случаев потребуется записывать в поток закрытые члены, а не являющиеся друзьями функции не смогут получить доступ к ним.
После этого определите версию operator<<, которая работает с ostream или wostream (которые определены в <ostream>) и вашим классом, который вы уже объявили с ключевым словом friend. Здесь вы должны решить, какие данные-члены должны записываться в поток. Обычно потребуется записывать в поток все данные, как это я делал в примере 10.6.
out << emp.firstName_ << endl;
out << emp.lastName_ << endl;
В примере 10.6 я записал в поток объект, на который ссылается указатель empr_, вызывая для него оператор operator<<.
if (emp.empr_)
 out << *emp.empr << endl;
Я могу так делать, потому что empr_ указывает на объект класса Employer, а для него, как и для Employee, я определил оператор operator<<.
После записи в поток членов вашего класса ваш оператор operator<< должен возвратить переданный ему поток. Это необходимо делать в любой перегрузке operator<<, тогда она может успешно использоваться, как в следующем примере.
cout << "Here's my object. " << myObj << '\n';
Описанный мною подход достаточно прост, и если вы собираетесь записывать класс с целью его дальнейшего восприятия человеком, он будет хорошо работать, но это только частичное решение проблемы. Если вы записываете объект в поток, это обычно делается по одной из двух причин. Либо этот поток направляется куда-то, где он будет прочитан человеком (cout, окно терминала, файл журнала и т.п.), либо поток записывается на носитель временной или постоянной памяти (stringstream, сетевое соединение, файл и т.д.) и вы планируете восстановить в будущем объект из потока. Если вам требуется воссоздать объект из потока (тема рецепта 10.5), необходимо тщательно продумать взаимосвязи вашего класса.
Сериализация трудно реализуется для любых классов, не считая тривиальных. Если в вашем классе имеются ссылки или указатели на другие классы, что характерно для большинства нетривиальных классов, вам придется учесть потенциальную возможность наличия циклических ссылок, обработать их должным образом при записи в поток объектов и правильно реконструировать ссылки при считывании объектов. Если вам приходится строить что-то «с чистого листа», необходимо учесть эти особенности проектирования, однако если вы можете использовать внешнюю библиотеку, вам следует воспользоваться библиотекой Boost Serialization, которая обеспечивает переносимый фреймворк сериализации объектов.
Смотри также
Рецепт 10.5.
10.5. Создание класса, считываемого из потока
Проблема
В поток записан объект некоторого класса и теперь требуется считать эти данные из потока и использовать их для инициализации объекта того же самого класса.
Решение
Используйте operator>> для чтения данных из потока в ваш класс для заполнения значений данных-членов; это просто является обратной задачей по отношению к тому, что сделано в примере 10.6. Реализация приводится в примере 10.7.
Пример 10.7. Чтение данных из потока в объект
#include <iostream>
#include <istream>
#include <fstream>
#include <string>
using namespace std;
class Employee {
 friend ostream& operator<<            // Они должны быть друзьями,
  (ostream& out, const Employee& emp); // чтобы получить доступ к
 friend istream& operator>>            // неоткрытым членам
  (istream& in, Employee& emp);
public:
 Employee() {}
 ~Employee() {}
 void setFirstName(const string& name) {firstName_ = name;}
 void setLastName(const string& name) {lastName_ = name;}
private:
 string firstName_;
 string lastName_;
};
// Передать в поток объект Employee...
ostream& operator<<(ostream& out, const Employee& emp) {
 out << emp.firstName_ << endl;
 out << emp.lastName_ << endl;
 return(out);
}
// Считать из потока объект Employee
istream& operator>>(istream& in, Employee& emp) {
 in >> emp.firstName_;
 in >> emp.lastName_;
 return(in);
}
int main() {
 Employee emp;
 string first = "William";
 string last = "Shatner";
 emp.setFirstName(first);
 emp.setLastName(last);
 ofstream out("tmp\\emp.txt");
 if (!out) {
  cerr << "Unable to open output file.\n";
  exit(EXIT_FAILURE);
 }
 out << emp; // Записать Emp в файл
 out.close();
 ifstream in("tmp\\emp.txt");
 if (!in) {
  cerr << "Unable to open input file.\n";
  exit(EXIT_FAILURE);
 }
 Employee emp2;
 in >> emp2; // Считать файл в пустой объект
 in.close();
 cout << emp2;
}
Обсуждение
При создании класса, считываемого из потока, выполняемые этапы почта совпадают с этапами записи объекта в поток (только они имеют обратный характер) Если вы еще не прочитали рецепт 10.4, это необходимо сделать сейчас, чтобы был понятен пример 10.7.
Во-первых, вам необходимо объявить operator>> как дружественный для вашего целевого класса, однако в данном случае вам нужно, чтобы он использовал поток istream, а не ostream. Затем определите оператор operator>> (вместо operator<<) для прямого чтения значений из потока в каждую переменную-член вашего класса. Завершив чтение данных, возвратите входной поток.
Смотри также
Рецепт 10.4.
10.6. Получение информации о файле
Проблема
Требуется получить информацию о файле, например о его размере, номере устройства, времени последнего изменения и т.п.
Решение
Используйте вызов системной C-функции stat, определенной в <sys/stat.h>. См. Пример 10.8, где показано типичное применение stat для вывода на печать некоторых атрибутов файла.
Пример 10.8. Получение информации о файле
#include <iostream>
#include <ctime>
#include <sys/types.h>
#include <sys/stat.h>
#include <cerrno>
#include <cstring>
int main(int argc, char** argv) {
 struct stat fileInfo;
 if (argc < 2) {
  std::cout << "Usage: fileinfo <file name>\n";
  return(EXIT_FAILURE);
 }
 if (stat(argv[1], &fileInfo) != 0) { // Используйте stat() для получения
                                      // информации
  std::cerr << "Error: " << strerror(errno) << '\n';
  return(EXIT_FAILURE);
 }
 std::cout << "Type::";
 if ((fileInfo.st_mode & S_IFMT) == S_IFDIR) { // Из sys/types.h
  std::cout << "Directory\n";
 } else {
  std::cout << "File\n";
 }
 std::cout << "Size : " <<
 fileInfo.st_size << '\n';               // Размер в байтах
 std::cout << "Device : " <<
  (char)(fileInfo.st_dev + 'A') >> '\n'; // Номер устройства
 std::cout << "Created : " <<
  std::ctime(&fileInfo.st_ctime);        // Время создания
 std::cout << "Modified : " <<
  std.:ctime(&fileInfo.st_mtime);        // Время последней модификации
}
Обсуждение
Стандартная библиотека C++ обеспечивает операции с содержимым файловых потоков, но она не имеет встроенных средств по чтению и изменению поддерживаемых ОС метаданных файла, например размера файла, его владельца, прав доступа, различных времен и другой информации. Однако стандартный С содержит несколько стандартных библиотек системных вызовов, которые можно использовать для получения различной информации о файле, что сделано в примере 10.8.
Существует два средства, обеспечивающие получение информации о файле. Во-первых, это структура struct с именем stat, которая содержит члены с информацией о файле, и, во-вторых, системный вызов (функция) с тем же самым именем, который обеспечивает получение любой запрошенной информации о файле, помещая ее в структуру stat. Системный вызов — это функция, обеспечивающая некоторую системную службу ОС. Ряд системных вызовов является частью стандартного С, и многие из них стандартизованы и входят в состав различных версий Unix. Структура stat имеет следующий вид (из книги Кернигана (Kernigan) и Ричи (Richie) «The С Programming Language», [издательство «Prentice Hall»]).
struct stat {
 dev_t  st_dev;   /* устройство */
 ino_t  st_ino;   /* номер inode */
 short  st_mode;  /* вид */
 short  st_nlink  /* число ссылок на файл */
 short  st_uid;   /* пользовательский идентификатор владельца */
 short  st_gid;   /* групповой идентификатор владельца */
 dev_t  st_rdev;  /* для особых файлов */
 off_t  st_size;  /* размер файла в символах */
 time_t st_atime; /* время последнего доступа */
 time_t st_mtime; /* время последней модификации */
 time_t st_ctime; /* время последнего изменения inode */
};
Смысл каждого члена stat зависит от ОС. Например, st_uid и st_gid не используются в системах Windows, в то время как в системах Unix они фактически содержат идентификаторы пользователя и группы владельца файла. Воспользуйтесь документацией ОС, чтобы узнать, какие значения поддерживаются и как они интерпретируются.
В примере 10.8 показано, как можно отображать на экране некоторые переносимые члены stat. st_mode содержит битовую маску, описывающую тип файла. Она позволяет узнать, является ли файл каталогом или нет. st_ size задает размер файла в байтах. Три члена типа size_t  определяют время последнего доступа, модификации и создания файлов.
Остальные члены содержат информацию, зависящую от операционной системы. Рассмотрим st_dev: в системах Windows этот член содержит номер устройства (дисковода) в виде смещения от буквы А, представленной в коде ASCII (именно поэтому в примере я добавляю 'A', чтобы получить буквенное обозначение дисковода). Но в системе Unix это будет означать нечто другое; значение этого члена передайте в системный вызов ustat, и вы получите имя файловой системы.
Если вам требуется получить дополнительную информацию о файле, лучше всего обратиться к документации вашей ОС. Стандартные системные вызовы C-функций ориентированы на Unix, поэтому они обычно приносят больше пользы в системах Unix (и совместно с ними может использоваться ряд других системных вызовов). Если вы не используете Unix, вполне возможно, что в вашей ОС имеются поставляемые со средой разработки собственные библиотеки, которые позволяют получать более детальную информацию.
10.7. Копирование файла
Проблема
Требуется скопировать файл, причем так, чтобы эта операция была переносимой, т.е. без использования зависящего от ОС программного интерфейса.
Решение
Используйте файловые потоки С++, определенные в <fstream>, для копирования одного потока в другой. Пример 10.9 показывает, как можно скопировать поток с помощью буфера
Пример 10.9. Копирование файла
#include <iostream>
#include <fstream>
const static int BUF_SIZE = 4096;
using std::ios_base;
int main(int argc, char** argv) {
 std::ifstream in(argv[1],
  ios_base::in | ios_base::binary);  // Задается двоичный режим, чтобы
 std::ofstream out(argv[2],          // можно было обрабатывать файлы с
  ios_base::out | ios_base::binary), // любым содержимым
 // Убедитесь, что потоки открылись нормально...
 char buf[BUF_SIZE];
 do {
  in.read(&buf[0], BUF_SIZE);      // Считать максимум n байт в буфер,
  out.write(&buf[0], in.gcount()); // затем записать содержимое буфера
 } while (in.gcount() > 0);        // в поток вывода.
 // Проверить наличие проблем в потоках...
 in.close();
 out.close();
}
Обсуждение
Можно посчитать, что копирование файла — это простая операция чтения из одного потока и записи в другой поток. Однако библиотека потоков C++ достаточно большая, и существует несколько различных способов чтения и записи потоков, поэтому надо обладать некоторыми знаниями об этой библиотеке, чтобы избежать ошибок, снижающих производительность этой операции.
Пример 10.9 работает быстро, потому что используется буферизация ввода-вывода. Функции read и write оперируют сразу всем содержимым буфера вместо посимвольного копирования, когда в цикле считывается символ из потока ввода в буфер и затем записывается в поток вывода. При их выполнении не делается никакого форматирования, подобного тому, которое выполняется операторами сдвига влево и вправо, что ускоряет выполнение операции. Кроме того, поскольку потоки работают в двоичном режиме, не надо специально обрабатывать символы EOF. В зависимости от используемого вами оборудования, ОС и т.д. вы получите различный результат при различных размерах буфера. Экспериментально вы можете найти наилучшие параметры для вашей системы
Однако можно добиться большего. Все потоки C++ уже буферизуют данные при их чтении и записи, поэтому в примере 10.9 фактически выполняется двойная буферизация. Поток ввода имеет свой собственный внутренний буфер потока, который содержит символы, прочитанные из исходного файла, но еще не обработанные с помощью read, operator<<, getc или любых других функций-членов, а поток вывода имеет буфер, который содержит вывод, записанный в поток, но не в «пункт назначения» (в случае применения ofstream это файл, но могла бы быть строка, сетевое соединение и кто знает, что еще). Поэтому лучше всего обеспечить непосредственный обмен данных буферов. Вы это можете сделать с помощью оператора operator<<, который работает иначе с буферами потоков. Например, вместо цикла do/while приведенного в примере 10.9, используйте следующий оператор.
out << in.rdbuf();
Не следует размещать этот оператор в теле цикла, замените весь цикл одной строкой. Это выглядит немного странно, поскольку обычно оператор operator<< говорит, «возьмите правую часть и передайте ее в поток левой части», однако, поверьте мне, эта запись имеет смысл, rdbuf возвращает буфер потока ввода, а реализация operator<<, принимающая буфер потока справа, считывает каждый символ буфера ввода и записывает его в буфер вывода. Когда буфер ввода заканчивается, он «знает», что должен заново заполнить себя данными из реального источника, a operator<< ведет себя не лучше.
Пример 10.9 показывает, как можно скопировать содержимое файла, но ваша ОС отвечает за управление файловой системой, которая осуществляет копирование, так почему бы не предоставить право ОС сделать эту работу? В большинстве случаев на это можно ответить, что прямой вызов программного интерфейса ОС, конечно, не является переносимым решением. Библиотека Boost Filesystem скрывает от вас множество зависящих от ОС программных интерфейсов, предоставляя функцию copy_file, которая выполняет системные вызовы ОС для той платформы, для которой она компилируется. Пример 10.10 содержит короткую программу, которая копирует файл из одного места в другое.
Пример 10.10. Копирование файла при помощи Boost
#include <iostream>
#include <string>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверка параметров...
 try {
  // Преобразовать аргументы в абсолютные пути, используя «родное»
  // форматирование
  path src = complete(path(argv[1], native));
  path dst = complete(path(argv[2], native));
  copy_file(src, dst);
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
В этой небольшой программе все же имеется несколько ключевых вопросов, которые необходимо пояснить, поскольку другие рецепты данной главы используют библиотеку Boost Filesystem. Во первых, центральным компонентом библиотеки Boost Filesystem является класс path, описывающий независимым от ОС способом путь к файлу или каталогу. Вы можете создать path, используя как переносимый тип строки, так и специфичный для конкретной ОС. В примере 10.10 я создаю путь path из аргументов программы (этот путь я затем передаю функции complete, которую мы вскоре рассмотрим).
path src = complete(path(argv[1], native));
Первый аргумент — это текстовая строка, представляющая путь, например «tmp\\foo.txt», а второй аргумент — имя функции, которая принимает аргумент типа string и возвращает значение типа Boolean, которое показывает, удовлетворяет или нет путь определенным правилам. Функция native говорит о том, что проверяется родной формат ОС. Я его использовал в примере 10.10, потому что аргументы берутся из командной строки, где они, вероятно, вводятся человеком, который, по-видимому, использует родной формат ОС при задании имен файлов. Существует несколько функций, предназначенных для проверки имен файлов и каталогов и названия которых не требует пояснений: portable_posix_name, windows_name, portable_name, portable_directory_name, portable_file_name и no_check. Особенности работы этих функций вы найдете в документации.
Функция complete формирует абсолютный путь, используя текущий рабочий каталог и переданный ее относительный путь. Так, я могу следующим образом создать абсолютный путь к исходному файлу.
path src = complete(path("tmp\\foo.txt", native));
В том случае, если первый аргумент уже имеет абсолютное имя файла, функция complete выдает заданное значение и не будет пытаться его присоединить к текущему рабочему каталогу. Другими словами, в следующем операторе, выполняемом при текущем каталоге «c:\myprograms», последний будет проигнорирован, потому что уже задан полный путь.
path src = complete(path("c:\\windows\\garbage.txt", native));
Многие функции из библиотеки Boost Filesystem будут выбрасывать исключения, если не удовлетворяется некоторое предусловие. Это подробно описано в документации, но хорошим примером является сама функция copy_file. Файл должен существовать перед копированием, поэтому если исходного файла нет, операция не будет завершена успешно и copy_file выбросит исключение. Перехватите исключение, как я это сделал в примере 10.10, и вы получите сообщение об ошибке, объясняющее, что произошло.
10.8. Удаление или переименование файла
Проблема
Требуется удалить или переименовать файл и сделать эту операцию переносимой, те. без использования специфичного для конкретной ОС программного интерфейса.
Решение
Это сделают стандартные C-функции remove и rename, определенные в <cstdio>. Пример 10.11 кратко демонстрирует, как это делается.
Пример 10.11. Удаление файла
#include <iostream>
include <cstdio>
#include <cerrno>
using namespace std;
int main(int argc, char** argv) {
 if (argc != 2) {
  cerr << "You must supply a file name to remove." << endl;
  return(EXIT_FAILURE);
 }
 if (remove(argv[1]) == -1) { // remove() возвращает при ошибке -1
  cerr << "Error: " << strerror(errno) << endl;
  return(EXIT_FAILURE);
 } else {
  cout << "File '" << argv[1] << "' removed." << endl;
 }
}
Обсуждение
Эти системные вызовы легко использовать: просто вызовите любую из двух функций, передав ей имя файла, который требуется удалить или переименовать. Если что-то не получится, будет возвращено ненулевое значение, и errno будет иметь номер соответствующей ошибки. Вы можете использовать strerror или perror (обе функции определены в <cstdio>) для вывода на печать сообщения об ошибке, зависящего от реализации.
Для переименования файла следует поменять в примере 10.11 вызов функции remove следующим программным кодом.
if (rename(argv[1], argv[2])) {
 cerr << "Error: " << strerror(errno) << endl;
 return(EXIT_FAILURE);
}
Библиотека Boost Filesystem также предоставляет средства для удаления и переименования файла. В примере 10.12 показана короткая программа по удалению файла (или каталога, однако см. обсуждение, приводимое после этою примера).
Пример 10.12. Удаления файла средствами Boost
#include <iostream>
#include <string>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверить параметры...
 try {
  path p = complete(path(argv[1], native));
  remove(p);
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
Важную часть примера 10.12 составляет функция remove. При ее вызове следует задавать достоверный путь в аргументе path, который ссылается на файл или пустой каталог, и они будут удалены. Пояснения по классу path и функции complete (оба они входят в библиотеку Boost Filesystem) приводятся при обсуждении рецепта 10.7. См. рецепт 10.11, где показан пример удаления каталога и всех содержащихся в нем файлов.
Переименование файла и каталога выполняется аналогично. Замените программный код в блоке try примера 10.12 следующим кодом.
path src = complete(path(argv[1], native));
path dst = complete(path(argv[2], native));
rename(src, dst);
В результате src будет переименован в dst при условии, что оба они содержат достоверные пути, src и dst не обязаны иметь общий каталог, и в этом смысле функция переименования фактически перемещает файл или каталог в новый базовый каталог при условии, что путь dst существует.
Смотри также
Рецепт 10.7.
10.9. Создание временного имени файла и временного файла
Проблема
Требуется временно сохранить на диске некоторые данные, и вам не хочется писать самому программу, которая генерирует уникальные имена.
Решение
Используйте функцию tmpfile или tmpnam, которые объявлены в <cstdio>. tmpfile возвращает FILE*, который уже открыт на запись, a tmpnam генерирует уникальное имя файла, которое вы можете сами открыть. Пример 10.13 показывает, как можно использовать функцию tmpfile.
Пример 10.13. Создание временного файла
#include <iostream>
#include <cstdio>
int main() {
 FILE* pf = NULL;
 char buf[256];
 pf = tmpfile(); // Создать и открыть временный файл
 if (pf) {
  fputs("This is a temp file", pf); // Записать в него некоторые данные
 }
 fseek(pf, 5, SEEK_SET); // Восстановить позицию в файле
 fgets(buf, 255, pf);    // Считать оттуда строку
 fclose(pf);
 std:cout << buf << '\n';
}
Обсуждение
Создать временный файл можно двумя способами; в примере 10.13 показан один из них. Функция tmpfile объявляется в <cstdio>; она не имеет параметров и возвращает FILE* при успешном завершении и NULL в противном случае. FILE* — это тот же самый тип, который может использоваться функциями С, обеспечивающими ввод-вывод; fread, fwrite, fgets, puts и т.д. tmpfile открывает временный файл в режиме «wb+» — это означает, что вы можете записывать в него или считывать его в двоичном режиме (т.е. при чтении символы никак специально не интерпретируются) После нормального завершения работы программы временный файл, созданный функцией tmpfile, автоматически удаляется.
Такой подход может как подойти, так и не подойти для вас — все зависит от того, что вы хотите делать. Заметив, что tmpfile не предоставляет имени файла, вы спросите, как можно передать его другой программе? В этом случае никак; вам потребуется вместо этой функции использовать аналогичную с именем tmpnam.
tmpnam на самом деле не создает временный файл, она просто создает уникальное имя файла, которое вы можете использовать при открытии файла, tmpnam принимает единственный параметр типа char* и возвращает значение типа char*. Вы можете передать указатель на буфер символов char (он должен быть, по крайней мере, не меньше значения макропеременной L_tmpnam, также определенной в <cstdio>), куда tmpnam скопирует имя временного файла и возвратит указатель на тот же самый буфер. Если вы передадите NULL, tmpfile возвратит указатель на статический буфер, содержащий это имя файла, что означает его перезапись последующими вызовами tmpnam. (См. пример 10.14.)
Пример 10.14. Создание имени временного файла
#include <iostream>
#include <fstream>
#include <cstdio>
#include <string>
int main() {
 char* pFileName = NULL;
 pFileName = tmpnam(NULL);
 // Здесь другая программа может получить то же самое имя временного
 // файла.
 if (!pFileName) {
  std::cerr << "Couldn't create temp file name.\n";
  return(EXIT_FAILURE);
 }
 std::cout << "The temp file name is: " << pFileName << '\n';
 std::ofstream of(pFileName);
 if (of) {
  of << "Here is some temp data.";
  of.close();
 }
 std::ifstream ifs(pFileName);
 std::string s;
 if (ifs) {
  ifs >> s;
  std::cout << "Just read in \"" << s << "\"\n";
  ifs.close();
 }
}
Однако одну важную особенность необходимо знать о функции tmpnam. Может возникнуть условие состязания, когда несколько процессов могут генерировать одинаковое имя файла, если один процесс вызывает tmpname, а другой вызывает tmpname до того, как первый процесс откроет этот файл. Это плохо по двум причинам. Во-первых, написанная злоумышленником программа может делать это для перехвата данных временного файла, и, во-вторых, ни о чем не подозревающая программа может получить то же самое имя файла и просто испортить или удалить данные.
10.10. Создание каталога
Проблема
Требуется создать каталог, причем эта операция должна быть переносимой, т.е. в ней не должен использоваться специфичный для конкретной ОС программный интерфейс.
Решение
На большинстве платформ вы сможете использовать системный вызов mkdir, который входит в состав большинства компиляторов и содержится в заголовочных файлах C-функций. Он имеет разный вид в различных ОС, но тем не менее вы можете его использовать для создания нового каталога. Стандартными средствами C++ нельзя обеспечить переносимый способ создания каталога. В этом вы можете убедиться на примере 10.15.
Пример 10.15. Создание каталога
#include <iostream>
#include <direct.h>
int main(int argc, char** argv) {
 if (argc < 2) {
  std::cerr << "Usage: " << argv[0] << " [new dir name]\n";
  return(EXIT_FAILURE);
 }
 if (mkdir(argv[1]) == -1) { // Созвать каталог
  std::cerr << "Error: " << strerror(errno);
  return(EXIT_FAILURE);
 }
}
Обсуждение
Системные вызовы по созданию каталогов слегка отличаются в различных ОС, но пусть это вас не останавливает — их все же следует использовать. В большинстве систем поддерживаются различные варианты вызова mkdir, поэтому для создания каталога достаточно просто знать, какой включать заголовочный файл и как выглядит сигнатура функции.
Пример 10.15 работает в системах Windows, но не в Unix. В Windows mkdir объявляется в <direct.h>. Эта функция принимает один параметр (имя каталога) и возвращает -1, если возникла ошибка, устанавливая в errno соответствующий номер ошибки. Вы можете получить зависящую от реализации текстовую строку ошибки, вызывая strerror или perror.
В Unix mkdir объявляется в <sys/stat.h>, и сигнатура этой функции немного отличается. Семантика ошибки такая же, как в Windows, но существует второй параметр, определяющий права доступа нового каталога. Вы должны указать права доступа, используя традиционный формат chmod (см. дополнительную информацию на man-странице chmod); например, 0777 означает, что владелец, групповой пользователь и прочие пользователи имеют право на чтение, запись и выполнение. Таким образом, вы могли бы вызвать эту функцию следующим образом.
#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
int main(int argc, char** argv) {
 if (argc < 2) {
  std::cerr << "Usage: " << argv[0] << " [new dir name]\n";
  return(EXIT_FAILURE);
 }
 if (mkdir(argv[1], 0777) == -1) { // Создать каталог
  std::cerr << "Error: << strerror(errno);
  return(EXIT_FAILURE);
 }
}
Если вам требуется обеспечить переносимость, не следует самому писать операторы #ifdef, лучше воспользоваться библиотекой Boost Filesystem. Вы можете создать каталог, используя функцию сreate_directory, как показано в примере 10.16, который содержит короткую программу, создающую каталог.
Пример 10.16. Создание каталога средствами Boost
#include <iostream>
#include <string>
#include <cstdlib>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверка параметров...
 try {
  path p = complete(path(argv[1], native));
  create_directory(p);
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
Функция create_directory создает каталог, имя которого вы задаете в аргументе path. Если этот каталог уже существует, выбрасывается исключение filesystem_error (которое является производным от стандартного класса исключения). Пояснения по классу path и функции complete (оба они входят в библиотеку Boost Filesystem) приводятся в обсуждении рецепта 10.7. См. рецепт 10.11, где показан пример удаления каталога и всех содержащихся в нем файлов. С другой стороны, если переносимость вас не волнует, используйте программный интерфейс файловой системы вашей ОС, который, вероятно, обладает большей гибкостью.
Смотри также
Рецепт 10.12.
10.11. Удаление каталога
Проблема
Требуется удалить каталог, причем эта операция должна быть переносимой, т.е. в ней не должен использоваться специфичный для конкретной ОС программный интерфейс.
Решение
На большинстве платформ вы сможете воспользоваться системным вызовом rmdir, который входит в состав большинства компиляторов и содержится в заголовочных файлах C-функций. Стандартными средствами C++ нельзя обеспечить переносимый способ удаления каталога. Вызов rmdir имеет разный вид в различных ОС, но тем не менее вы можете его использовать для удаления каталога. См. Пример 10.17, в котором приводится короткая программа по удалению каталога.
Пример 10.17. Удаление каталога
#include <iostream>
#include <direct.h>
using namespace std;
int main(int argc, char** argv) {
 if (argc < 2) {
  cerr << "Usage: " << argv[0] << " [dir name]" << endl;
  return(EXIT_FAILURE);
 }
 if (rmdir(argv[1]) == -1) { // Удалить каталог
  cerr << "Error: " << strerror(errno) << endl;
  return(EXIT_FAILURE);
 }
}
Обсуждение
Сигнатура rmdir совпадает в большинстве ОС, однако объявляется эта функция в разных заголовочных файлах. В Windows она объявляется в <direct.h>, а в Unix — в <unistd.h>. Она принимает один параметр (имя каталога) и возвращает -1, если возникла ошибка, устанавливая в errno соответствующий номер ошибки. Вы можете получить зависящую от реализации текстовую строку ошибки, вызывая strerror или perror.
Если целевой каталог не пустой, rmdir завершится с ошибкой. Для просмотра списка содержимого каталога, перечисления его элементов для их удаления см. рецепт 10.12.
Если вам требуется обеспечить переносимость, не следует самому писать операторы #ifdef, заключая в них специфичные для конкретной ОС функции, — лучше воспользоваться библиотекой Boost Filesystem. В библиотеке Boost Filesystem используется концепция пути для ссылки на файл или каталог, а пути можно удалять с помощью одной функции — remove.
Функция removeRecurse из примера 10.18 рекурсивно удаляет каталог и все его содержимое. Наиболее важной ее частью является функция remove (которая на самом деле является функцией boost::filesystem::remove, а не стандартной библиотечной функцией). Она принимает путь path в качестве аргумента и удаляет его, если это файл или пустой каталог, но она не удаляет каталог, если он содержит файлы.
Пример 10.18. Удаление каталога средствами Boost
#include <iostream>
#include <string>
#include <cstdlib>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace std;
using namespace boost::filesystem;
void removeRecurse(const path& p) {
 // Сначала удалить содержимое каталога
 directory_iterator end;
 for (directory_iterator it(p); it != end; ++it) {
  if (is_directory(*it)) {
   removeRecurse(*it);
  } else {
   remove(*it);
  }
 }
 // Затем удалить сам каталог
 remove(p);
}
int main(int argc, char** argv) {
 if (argc != 2) {
  cerr << "Usage: " << argv[0] << " [dir name]\n";
  return(EXIT_FAILURE);
 }
 path thePath = system_complete(path(argv[1], native));
 if (!exists(thePath)) {
  cerr << "Error: the directory " << thePath.string()
   << " does not exist.\n";
  return(EXIT_FAILURE);
 }
 try {
  removeRecurse(thePath);
 } catch (exception& e) {
  cerr << e.what() << endl;
  return(EXIT_FAILURE);
 }
 return(EXIT_SUCCESS);
}
Программный код, обеспечивающий просмотр содержимого каталога, требует некоторых пояснений, и это является темой рецепта 10.12.
Библиотека Boost Filesystem достаточно удобна, однако следует помнить, что формально она не является стандартом, и поэтому нет гарантии, что она будет работать в любой среде. Если вы посмотрите на исходный код библиотеки Boost Filesystem, вы увидите, что фактически она компилирует системные вызовы, специфичные для целевой платформы. Если вас не волнует переносимость, используйте программный интерфейс файловой системы вашей ОС, который, вполне вероятно, обладает большей гибкостью.
Смотри также
Рецепт 10.12.
10.12. Чтение содержимого каталога
Проблема
Требуется прочитать содержимое каталога, вероятно, для того, чтобы сделать что-то с каждым его файлом или подкаталогом.
Решение
Для получения переносимого решения воспользуйтесь классами и функциями библиотеки Boost Filesystem. Она содержит ряд удобных функций по работе с файлами, обеспечивая переносимое представление путей, итераторы каталога и различные функции по переименованию, удалению и копированию файлов и т.п. Пример 10.19 показывает, как можно использовать некоторые из этих средств.
Пример 10.19. Чтение каталога
#include <iostream>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace boost::filesystem;
int main(int argc, char** argv) {
 if (argc < 2) {
  std::cerr << "Usage: " << argv[0] << " [dir name]\n";
  return(EXIT_FAILURE);
 }
 path fullPath = // Создать полный, абсолютный путь
  system_complete(path(argv[1], native));
 if (!exists(fullPath)) {
  std::cerr << "Error: the directory " << fullPath.string()
   << " does not exist.\n";
  return(EXIT_FAILURE);
 }
 if (!is_directory(fullPath)) {
  std::cout << fullPath.string() << " is not a directory!\n";
  return(EXIT_SUCCESS);
 }
 directory_iterator end;
 for (directory_iterator it(fullPath);
  it != end; ++it) {        // Просматривать в цикле каждый
                           // элемент каталога почти
  std::cout << it->leaf(); // так же, как это делалось бы для
  if (is_directory(*it))   // STL-контейнера
   std::cout << " (dir)";
  std::cout << '\n';
 }
 return(EXIT_SUCCESS);
}
Обсуждение
Как и при создании и удалении каталогов (см. рецепты 10.10 и 10.11), не существует стандартного, переносимого способа чтения содержимого каталога. Чтобы облегчить жизнь в C++, библиотека Filesystem проекта Boost содержит ряд переносимых функций по работе с файлами и каталогами. Она также содержит много других функций; дополнительную информацию вы найдете при описании других рецептов этой главы или на веб-странице библиотеки Boost Filesystem сайта www.boost.com.
В примере 10.19 приводится простая программа просмотра каталога (наподобие команды ls в Unix или dir в MS-DOS). Сначала она следующим образом формирует абсолютный путь на основе аргументов, переданных программе.
path fullPath = complete(path(argv[1], native));
Тип данных переменной, содержащей путь, называется, естественно, path (путь). С этим типом данных работает файловая система, и он легко преобразуется в строку путем вызова path::string. После формирования пути программа проверяет его существование (с помощью функции exists), затем с помощью другой функции, is_directory, проверяет, задает ли данный путь каталог. Если ответ положителен, то все хорошо и можно перейти к реальной работе по просмотру содержимого каталога.
Файловая система имеет класс с именем directory_iterator, который использует стандартную семантику итераторов, подобную применяемой для стандартных контейнеров, чтобы можно было использовать итераторы как указатели на элементы каталога. Однако в отличие от стандартных контейнеров здесь нет функции-члена end, представляющей элемент, следующий за последним элементом (т.е. vector<T>::end). Вместо этого, если вы создаете итератор каталога directory_iterator при помощи стандартного конструктора, он предоставляет конечный маркер, который вы можете использовать в операциях сравнения для определения момента завершения просмотра каталога. Поэтому используйте следующий оператор.
directory_iterator end;
Затем вы можете создать итератор для вашего пути и следующим образом сравнивать его с маркером конца.
for (directory_iterator it(fullPath); it != end; ++it) {
 // выполнить любые действия с *it
 std::cout << it->leaf();
}
Функция-член leaf возвращает строку, представляющую конечный элемент пути, а не весь путь, который вы можете получить, вызывая функцию-член string.
Если вам требуется обеспечить переносимость, но по каким-то причинам вы не можете использовать библиотеки Boost, обратите внимание на исходный код Boost. Он содержит операторы #ifdef, которые учитывают (по большей части) отличия среды Windows и ОС, использующих интерфейс Posix, и в частности отличия в представлении путей, например буквы дисководов и имена устройств.
Смотри также
Рецепты 10.10 и 10.11.
10.13. Извлечение расширения файла из строки
Проблема
Имеется имя файла или полный путь и требуется получить расширение файла, которое является частью имени файла, расположенной за последней точкой. Например, в именах файлов src.cpp, Window.class и Resume.doc расширениями файла являются соответственно .cpp, .class и .doc.
Решение
Преобразуйте имя файла или путь к нему в строку string, используйте функцию-член rfind для определения позиции последней точки и возвратите то, что находится за ней. Пример 10.20 показывает, как это можно сделать.
Пример 10.20. Получение расширения файла из его имени
#include <iostream>
#include <string>
using std::string;
string getFileExt(const string& s) {
 size_t i = s.rfind('.', s.length());
 if (i ! = string::npos) {
  return(s.substr(i+1, s.length() - i));
 }
 return("");
}
int main(int argc, char** argv) {
 string path = argv[1];
 std::cout << "The extension is \"" << getFileExt(path) << "\"\n";
}
Обсуждение
Для получения расширения из имени файла достаточно лишь найти позицию последней точки «.» и выделить все, что находится справа от нее. Стандартный класс string, определенный в <string>, содержит функции, которые могут выполнить обе эти операции: rfind и substr.
rfind выполнит поиск (в обратном направлении) того, что вы передаете ей в первом аргументе (символ типа char в данном случае), начиная с позиции, указанной вторым аргументом, и возвращает позицию, в которой найден указанный объект. Если поиск завершился неудачей, rfind возвратит string::npos. Функция substr также имеет два аргумента. Первый аргумент содержит позицию первого копируемого элемента, а второй аргумент — количество копируемых символов.
Стандартный класс строки содержит несколько функций-членов, выполняющих поиск. См. рецепт 4.9, в котором более детально обсуждается поиск строк.
Смотри также
Рецепты 4.9 и 10.12.
10.14. Извлечение имени файла из полного пути
Проблема
Имеется полный путь к файлу, например d:\apps\src\foo.с, и требуется получить имя файлa, foo.с.
Решение
Примените подход, который использовался в предыдущем рецепте, и используйте функции rfind и substr для поиска и получения из полного пути то, что вам нужно. Пример 10.21 показывает, как это можно сделать.
Пример 10.21. Извлечение имени файла из полного пути
#include <iostream>
#include <string>
using std::string;
string getFileName(const string& s) {
 char sep = '/';
#ifdef _WIN32
 sep = '\\';
#endif
 size_t i = s.rfind(sep.s.length());
 if (i ! = string::npos) {
  return(s.substr(i+1, s.length( ) - i));
 }
 return("");
}
int main(int argc, char** argv) {
 string path = argv[1];
 std::cout << "The file name is \"" << getFileName(path) << "\"\n";
}
Обсуждение
См. предыдущий рецепт, в котором приводится детальное описание функций rfind и substr. Стоит отметить только то, что вы уже, по-видимому, заметили в примере 10.21: в Windows в качестве разделителя используется обратный слеш вместо прямого, поэтому я добавил оператор #ifdef для установки требуемого разделителя элементов пути.
Класс path из библиотеки Boost Filesystem позволяет легко получить с помощью функции-члена path::leaf последний элемент полного пути, которым может быть имя файла или каталога. В примере 10.22 приводится простая программа, которая использует эту функцию, чтобы показать, к чему относится этот путь: к файлу или к каталогу.
Пример 10.22. Получение имени файла из пути
#include <iostream>
#include <cstdlib>
#include <boost/filesystem/operations.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверка параметров
 try {
  path p = complete(path(argv[1], native));
 cout << p.leaf() << " is a "
  << (is_directory(p) ? "directory" : "file") << endl;
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
См. обсуждение рецепта 10.7, где более детально рассматривается класс path.
Смотри также
Рецепт 10.15.
10.15. Извлечение пути из полного имени файла
Проблема
Имеется полное имя файла (имя файла и путь доступа к нему), например d:\apps\src\foo.с, и требуется получить путь к файлу, d:\apps\src.
Решение
Примените подход, который использовался в предыдущих двух рецептах, и используйте функции rfind и substr для поиска и получения из полного пути то, что вам нужно. В примере 10.23 приводится короткая программа, показывающая, как это можно сделать.
Пример 10.23. Получение пути из полного имени файла
#include <iostream>
#include <string>
using std::string;
string getPathName(const string& s) {
 char sep = '/';
#ifdef _WIN32
 sep = '\\';
#endif
 size_t i = s.rfind(sep, s.length());
 if (i != string::npos) {
  return(s.substr(0, !));
 }
 return("");
}
int main(int argc, char** argv) {
 string path = argv[1];
 std::cout << "The path name is \"" << getPathName(path) << "\"\n";
}
Обсуждение
Пример 10.23 тривиален, особенно если вы уже знакомы с двумя предыдущими рецептами, поэтому дополнительные пояснения не требуются. Однако, как и во многих других рецептах, библиотека Boost Filesystem позволяет извлекать с помощью функции branch_path все, что угодно, кроме последней части имени файла. Пример 10.24 показывает, как можно использовать эту функцию.
Пример 10.24. Получение базового пути
#include <iostream>
#include <cstdlib>
#include <boost/filesystem/operations.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверка параметров...
 try {
  path p = complete(path(argv[1], native));
  cout << p.branch_path().string() << endl;
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
Результат выполнения примера 10.24 может выглядеть следующим образом.
D:\src\ccb\c10>bin\GetPathBoost.exe с:\windows\system32\1033
с:/windows/system32
Смотри также
Рецепты 10.13 и 10.14.
10.16. Замена расширения файла
Проблема
Имеется имя файла (возможно, с путем доступа к нему) и требуется заменить расширение файла. Например, имя файла thesis.tex требуется преобразовать в thesis.txt.
Решение
Используйте функции-члены rfind и replace класса string для поиска расширения и его замены. Пример 10.25 показывает, как это можно сделать.
Пример 10.25. Замена расширения файла
#include <iostream>
#include <string>
using std::string;
void replaceExt(string& s, const string& newExt) {
 string::size_type i = s.rfind('.', s.length());
 if (i != string::npos) {
  s.replace(i+1, newExt.length(), newExt);
 }
}
int main(int argc, char** argv) {
 string path = argv[1];
 replaceExt(path, "foobar");
 std::cout << "The new name is \"" << path << "\"\n";
}
Обсуждение
Здесь используется подход, аналогичный тому, который применялся в предыдущих рецептах, однако в данном случае я использовал функцию replace для замены части строки новой подстрокой. Функция replace имеет три параметра. Первый параметр задает позицию, в которую вставляется новая подстрока, а второй параметр определяет количество символов, которые необходимо удалить в формируемой строке. Третий параметр — это значение, которое будет использовано для замены удаляемой части строки.
Смотри также
Рецепт 4.9.
10.17. Объединение двух путей в один
Проблема
Имеется два пути и требуется их объединить в один путь. Например, вы имеете в качестве первого пути /usr/home/ryan и в качестве второго — utils/compilers; требуется получить /usr/home/ryan/utils/compilers, причем первый путь может как иметь, так и не иметь в конце разделитель элементов пути.
Решение
Рассматривайте пути как строки и используйте оператор добавления в конец строки, operator+=, для составления полного пути из составных частей. См. пример 10.26.
Пример 10.26. Объединение путей
#include <iostream>
#include <string>
using std::string;
string pathAppend(const string& p1, const string& p2) {
 char sep = '/';
 string tmp = p1;
#ifdef _WIN32
 sep = '\\';
#endif
 if (p1[p1.length()] != sep) { // Необходимо добавить
  tmp += sep;                  // разделитель
  return(tmp + p2);
 } else
  return(p1 + p2);
}
int main(int argc, char** argv) {
 string path = argv[1];
 std::cout << "Appending somedir\\anotherdir is \""
  << pathAppend(path, "somedir\\anotherdir") << "\"\n";
}
Обсуждение
В программе примера 10.26 для представления путей используются строки, но здесь не делается дополнительной проверки достоверности путей и переносимость их полностью зависит от содержащихся в них значений. Например, если эти значения получены от пользователя, то вы не можете заранее знать, имеют ли они правильный формат конкретной ОС или содержат недопустимые символы.
Для многих других рецептов данной главы я включил примеры по использованию библиотеки Boost Filesystem, и при работе с путями такой подход имеет много преимуществ. Как я говорил при обсуждении рецепта 10.7, библиотека Boost Filesystem содержит класс path, обеспечивающий переносимое представление пути к файлу или каталогу. Операции в библиотеке Filesystem в основном оперируют объектами path, и поэтому с помощью класса path можно реализовать объединение относительного пути с абсолютной его базовой частью. (См. пример 10.27.)
Пример 10.27. Объединение путей средствами Boost
#include <iostream>
#include <string>
#include <cstdlib>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/fstream.hpp>
using namespace std;
using namespace boost::filesystem;
int main(int argc, char** argv) {
 // Проверка параметров...
 try {
  // Составить путь из значений двух аргументов path
  p1 = complete(path(argv[2], native),
  path(argv[1], native));
  cout << p1.string() << endl;
  // Создать путь с базовой частью пути текущего каталога path
  p2 = system_complete(path(argv[2], native));
  cout << p2.string() << endl;
 } catch (exception& e) {
  cerr << e.what() << endl;
 }
 return(EXIT_SUCCESS);
}
Результат выполнения программы примера 10.27 может иметь такой вид.
D:\src\ccb\c10>bin\MakePathBoost.exe d:\temp some\other\dir
d:/temp/some/other/dir
D:/src/ccb/c10/some/other/dir
Или такой.
D:\src\ccb\c10>bin\MakePathBoost.exe d:\temp с:\WINDOWS\system32
c:/WINDOWS/system32
c:/WINDOWS/system32
Из этого примера видно, что функции complete и system_complete объединяют пути, когда это возможно, и возвращают абсолютный путь, когда объединение путей не имеет смысла. Например, в первом случае первый переданный программе аргумент является абсолютным путем каталога, а второй — относительным путем. Функция complete объединяет их и формирует один, абсолютный путь. Первый аргумент complete является относительным путем, а второй — абсолютным путем, и если первый аргумент уже является абсолютным путем, второй аргумент игнорируется. Поэтому во втором случае аргумент «d:\temp» игнорируется, так как переданный мною второй аргумент уже является абсолютным путем.
system_complete принимает только один аргумент (в данном случае это относительный путь) и добавляет его в конец текущего рабочего каталога, получая другой абсолютный путь. И в этом случае, если переданный вами путь уже является абсолютным, текущий рабочий каталог игнорируется и просто возвращается переданный вами абсолютный путь.
Однако эти пути не согласуются с требованиями файловой системы. Вам придется самому проверить объекты path, чтобы убедиться, что они представляют правильный путь файловой системы. Например, для проверки существования этих путей вы можете использовать функцию exists.
path p1 = complete(path(argv[2], native),
path(argv[1], native));
if (exists(p1)) {
 // ...
Существует много других функций, позволяющих получать информацию о пути: is_directory, is_empty, file_size, last_write_time и т.д. Дополнительную информацию вы найдете в документации по библиотеке Boost Filesystem на сайте www.boost.org.
Смотри также
Рецепт 10.7.
Глава 11
Наука и математика
11.0. Введение
Язык программирования C++ хорошо подходит для решения научных и математических задач из-за своей гибкости, выразительности и эффективности. Одно из самых больших преимуществ применения C++ для выполнения численных расчетов связано с тем, что он помогает избегать избыточности.
Исторически сложилось так, что написанные на многих языках программы, реализующие численные расчеты, обычно снова и снова повторяют алгоритмы для различных числовых типов (например, для коротких чисел, для длинных чисел, для чисел с одинарной точностью, для чисел с двойной точностью, для специальных числовых типов и т.д.). В C++ проблема такой избыточности решается с помощью шаблонов. Шаблоны позволяют писать алгоритмы, которые не зависят от представления данных, — этот подход широко известен под названием «обобщенное программирование».
Нельзя сказать, что C++ не имеет недостатков, которые проявляются при реализации численных расчетов. Самым большим недостатком С++, отличающим его от специализированных математических и научных языков программирования, являются ограниченные возможности стандартной библиотеки в отношении поддержки алгоритмов и типов данных, характерных для программирования численных расчетов. Возможно, самым большим упущением стандартной библиотеки является отсутствие матричных типов и целых типов произвольной точности.
В данной главе я приведу решения распространенных задач численного программирования и продемонстрирую методы обобщенного программирования при написании эффективного программного кода, реализующего численные расчеты. В подходящих случаях я буду рекомендовать широко используемые библиотеки с открытым исходным кодом, имеющие дружественные коммерческие лицензии и подтвержденный послужной список. В этой главе рассматриваются основные методы обобщенного программирования, причем это делается постепенно, переходя от одного рецепта к другому.
Многие программисты, использующие С++, все же с недоверием относятся к шаблонам и обобщенному программированию из-за очевидной их сложности. Когда шаблоны впервые были введены в язык, они не были хорошо реализованы, а программисты и разработчики компиляторов не очень хорошо их понимали. В результате многие программисты, включая автора, избегали пользоваться обобщенным программированием на C++ в течение нескольких лет, пока эта технология не достигла зрелости.
В настоящее время обобщенное программирование рассматривается как мощная и полезная парадигма программирования, которая поддерживается в большинстве популярных языков программирования. Более того, технология разработки компиляторов C++ очень сильно усовершенствовалась, и работа современных компиляторов с шаблонами стала гораздо более эффективной и стандартизованной. В результате современный C++ стал очень мощным языком программирования научных и численных приложении.
11.1. Подсчет количества элементов в контейнере
Проблема
Требуется найти количество элементов в контейнере.
Решение
Подсчитать количество элементов в контейнере можно при помощи функции-члена size или функции distance, определенной в заголовочном файле <algorithm>, как это делается в примере 11.1.
Пример 11.1. Подсчет количества элементов в контейнере
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
int main() {
 vector<int> v;
 v.push_back(0);
 v.push_back(1);
 v.push_back(2);
 cout << v.size() << endl;
 cout << distance(v.begin(), v.end()) << endl;
}
Программа примера 11.1 выдает следующий результат.
3
3
Обсуждение
Функция-член size, которая возвращает количество элементов стандартного контейнера, является наилучшим решением в тех случаях, когда доступен объект контейнера. В примере 11.1 я также продемонстрировал применение функции distance, потому что при написании обобщенного программного кода обычно имеешь дело только с парой итераторов. Работая с итераторами, вы часто не знаете тип контейнера и не имеете доступа к его функциям-членам.
Функция distance, как и большинство алгоритмов STL, в действительности является шаблонной функцией. Поскольку тип аргумента шаблона может автоматически выводиться компилятором по аргументам функции, вам не надо его передавать как параметр шаблона. Конечно, при желании можно явно указать тип параметра шаблона, как это сделано ниже.
cout << distance<vector<int>::iterator>(v.begin(), v.end()) << endl;
Производительность функции distance зависит от типа используемого итератора. Время ее выполнения будет постоянным, если итератор ввода является итератором с произвольным доступом; в противном случае время ее работы будет линейным. (Концепция итератора рассматривается в рецепте 7.1.)
Смотри также
Рецепт 15.1.
11.2. Поиск наибольшего или наименьшего значения в контейнере
Проблема
Требуется найти максимальное или минимальное значение в контейнере.
Решение
Пример 11.2 показывает, как можно находить максимальные и минимальные элементы контейнера с помощью функций max_element и min_element, определенных в заголовочном файле <algorithm>. Эти функции возвращают итераторы,. которые ссылаются на первый элемент, имеющий самое большое или самое маленькое значение соответственно.
Пример 11.2. Поиск минимального или максимального элемента контейнера
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
int getMaxInt(vector<int>& v) {
 return *max_element(v.begin(), v.end());
}
int getMinInt(vector<int>& v) {
 return *min_element(v.begin(), v.end());
}
int main() {
 vector<int> v;
 for (int i=10; i < 20; ++i) v.push_back(i);
 cout << "min integer = " << getMinInt(v) << endl;
 cout << "max integer = " << getMaxInt(v) << endl;
}
Программа примера 11.2 выдает следующий результат.
min integer = 10
max integer =19
Обсуждение
Вероятно, вы заметили, что выполняется разыменование значения, возвращаемого функциями min_element и max_element. Это делается по той причине, что указанные функции возвращают итераторы, а не сами значения, поэтому результат должен быть разыменован. Возможно, вы посчитаете, что такая операция разыменования создает небольшое неудобство, однако это позволяет избежать лишнего копирования возвращаемого значения. Это может быть особенно важно, когда копирование возвращаемого значения обходится дорого (например, если это большая строка).
Обобщенные алгоритмы стандартной библиотеки, несомненно, достаточно полезны, однако более важно уметь самому писать свои собственные обобщенные функции получения минимального и максимального значения, находящегося в контейнере. Допустим, вам нужно иметь одну функцию, которая возвращает минимальные и максимальные значения, модифицируя переданные ей по ссылке параметры вместо возвращения пары значений или какой-нибудь другой структуры. В примере 11.3 продемонстрировано, как это можно сделать.
Пример 11.3. Обобщенная функция, возвращающая минимальное и максимальное значения
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
template<class Iter_T, class Value_T>
void computeMinAndMax(Iter_T first, Iter_T last, Value_T& min, Value_T& max) {
 min = *min_element(first, last);
 max = *max_element(first, last);
}
int main() {
 vector<int> v;
 for (int i=10; i < 20; ++i) v.push_back(i);
 int min = -1;
 int max = -1;
 computeMinAndMax(v.begin(), v.end(), min, max);
 cout << "min integer = " << min << endl;
 cout << "max integer = " << max << endl;
}
В примере 11.3 я написал шаблон функции computeMinAndMax, которая принимает два параметра шаблона: один — это тип итератора, другой — тип минимальных и максимальных значений. Поскольку оба параметра шаблона являются также параметрами функции, компилятор C++ может догадаться, какие два отдельных типа (Iter_T и Value_T) используются, как это я продемонстрировал в рецепте 11.1. Это позволяет мне не указывать явно тип параметров шаблона, как это сделано ниже.
compute_min_max<vector<int>::iterator, int>(...)
При выполнении функций min_element и max_element используется оператор operator< для сравнения значений, на которые ссылаются итераторы. Это значит, что, если итератор ссылается на тип, который не поддерживает этот тип сравнения, компилятор выдаст сообщение об ошибке. Однако функции min_element и max_element можно также использовать с функтором сравнения, определенным пользователем, т.е. с указателем на функцию или с объектом-функцией.
Для функций min_element и max_element необходим специальный функтор, принимающий два значения (они имеют тип объектов, на которые ссылается итератор) и возвращающий значение типа Boolean, показывающее, является ли первое значение меньше, чем второе. Функтор, который возвращает значение типа Boolean, называется предикатом. Рассмотрим, например, поиск самого большого элемента в наборе пользовательских типов (пример 11.4).
Пример 11.4. Поиск максимального элемента для пользовательских типов
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
struct Chessplayer {
 ChessPlayer(const char* name, int rating)
  : name_(name), rating_(rating) { }
 const char* name_;
 int rating_;
};
struct IsWeakerPlayer {
 bool operator()(const ChessPlayer& x, const ChessPlayer& y) {
 return x.rating_ < y.rating_;
};
int main() {
 ChessPlayer kasparov("Garry Kasparov", 2805);
 ChessPlayer anand("Viswanathan Anand", 2788);
 ChessPlayer topalov("Veselin Topalov", 2788);
 vector<ChessPlayer> v;
 v.push_back(kasparov);
 v.push_back(anand);
 v.push_hack(topalov);
 cout << "the best player is ";
 cout << max_element(v.begin(), v.end(), IsWeakerPlayer())->name_;
 cout << endl;
}
Программа примера 11.4 выдает следующий результат.
the best player is Garry Kasparov (лучший игрок - Гарри Каспаров)
Функторы
Многие STL-алгоритмы в качестве параметров используют определенные пользователем объекты-функции и указатели на функции. И те и другие называются функторами (functors). Иногда в литературе термин «объект-функция» используется как синоним термина «функтор», однако я использую термин «объект-функция» для обозначения только экземпляров класса или структур, которые перегружают operator(). Какой из двух типов функторов лучше использовать? В большинстве случаев объект-функция более эффективен, потому что большинство компиляторов могут легко его реализовать в виде встроенной функции.
Другая причина применения объекта-функции заключается в том, что он может иметь состояние. Вы можете передавать значения его конструктору, который их сохраняет в соответствующих полях для последующего использования. По выразительным возможностям эти объекты-функции становятся сопоставимы с концепцией замыканий, которая используется в других языках программирования.
Наконец, объекты-функции могут определяться внутри другой функции или класса. Указатели на функции приходится объявлять в области видимости пространства имен.
В примере 11.4 я показал, как в функции max_element можно использовать пользовательский предикат. Этот предикат является объектом-функцией IsWeakerPlayer.
Альтернативой пользовательскому предикату, показанному в примере 11.4, является перегрузка оператора operator< для структуры ChessPlayer. Это хорошо работает в определенных случаях, но предполагает, что самой важной является сортировка игроков по рейтингу. Может оказаться, что более распространенной является сортировка по именам. Поскольку в данном случае выбор метода сортировки может быть произвольным, я предпочитаю не определять оператор operator<.
11.3. Вычисление суммы и среднего значения элементов контейнера
Проблема
Требуется вычислить сумму и среднее значение чисел, содержащихся в контейнере.
Решение
Для расчета суммы можно использовать функцию accumulate из заголовочного файла <numeric> и затем разделить ее на количество элементов, получая среднее значение. Пример 11.5 демонстрирует, как это можно сделать, используя вектор.
Пример 11.5. Вычисление суммы и среднего значения элементов контейнера
#include <numeric>
#include <iostream>
#include <vector>
using namespace std;
int main() {
 vector<int> v;
 v.push_back(1);
 v.push_back(2);
 v.push_back(3);
 v.push_back(4);
 int sum = accumulate(v.begin(), v.end(), 0);
 double mean = double(sum) / v.size();
 cout << "sum = " << sum << endl;
 cout << "count = " << v.size() << endl;
 cout << "mean = " << mean << endl;
}
Программа примера 11.5 выдает следующий результат.
sum = 10
count = 4
mean = 2.5
Обсуждение
Как правило, функция accumulate обеспечивает самый эффективный и самый простой способ вычисления суммы всех элементов, содержащихся в контейнере.
Несмотря на то что данный рецепт имеет относительно простое решение, не так уж просто написать свою собственную обобщенную функцию по расчету среднего значения. В примере 11.6 показан один из способов написания такой обобщенной функции.
Пример 11.6. Обобщенная функция по расчету среднего значения
template<class Iter_T>
double computeMean(Iter_T first, Iter_T last) {
 return static_cast<double>(accumulate(first, last, 0.0))
  / distance(first, last);
}
Функция computeMean из примера 11.6 подойдет в большинстве случаев, но она имеет одно ограничение: не работает она с такими итераторами ввода, как istream_iterator.
Итераторы istream_iterator и ostream_iterator
Шаблоны классов istream_iterator и ostream_iterator представляют собой специализированные итераторы, определенные в заголовочном файле <iterator> которые позволяют рассматривать потоки как однопроходные контейнеры.
istream_iterator является итератором ввода, который выступает в роли оболочки такого потока ввода, как cin или ifstream, позволяя использовать его в качестве параметра во многих обобщенных функциях. ostream_iterator является итератором вывода, который позволяет использовать потоки вывода, как будто они являются контейнерами. Использование итераторов istream_iterator и ostream_iterator является хорошей привычкой, так как с их помощью легче создавать повторно используемый программный код
Итератор istream_iterator позволяет выполнить только один проход по данным, поэтому вы можете вызвать либо accumulate, либо distance, но если вы вызываете обе функции, данные становятся недействительными, и всякая последующая попытка их просмотра, вероятно, приведет к неудаче. Пример 11.7 показывает, как можно написать более обобщенную функцию по расчету среднего значения за один проход последовательности чисел.
Пример 11.7. Более обобщенная функция по расчету среднего значения
#include <stdexcept>
#include <iostream>
#include <iterator>
using namespace std;
template<class Value_T, class Iter_T>
Value_T computeMean(Iter_T first, Iter_T last) {
 if (first == last) throw domain_error("mean is undefined");
 Value_T sum;
 int cnt = 0;
 while (first != last) {
  sum += *first++;
  ++cnt;
 }
 return sum / cnt;
)
int main() {
 cout << "please type in several integers separated by newlines" << endl;
 cout << "and terminated by an EOF character (i.e , Ctrl-Z)" << endl;
 double mean = computeMean<double>(
  istream_iterator<int>(cin), istream_iterator<int>());
 cout << "the mean is " << mean << endl;
}
При написании обобщенного программного кода следует, по мере возможности, пытаться пользоваться наиболее общим типом итератора. Это подразумевает, что, когда возможно, вы должны стараться писать обобщенные алгоритмы с единственным проходом по потоку ввода. При таком подходе ваш обобщенный программный код не ограничивается только контейнерами, а может также использоваться с такими итераторами ввода, как istream_iterator. Кроме того, алгоритмы с единственным проходом часто более эффективны.
Возможно, вас удивляет то, что я решил тип, возвращаемый функцией computeMean из примера 11.7, передать в качестве параметра шаблона, а не выводить его из типа итератора. Это сделано по той причине, что обычно статистические расчеты выполняются с более высокой точностью, чем точность значений, содержащихся в контейнере. Так, в программном коде примера 11.7 возвращаемое среднее значение набора чисел целого типа имеет тип double.
11.4. Фильтрация значений, выпадающих из заданного диапазона
Проблема
Требуется проигнорировать содержащиеся в последовательности значения, которые располагаются ниже или выше заданного диапазона.
Решение
Используйте функцию remove_copy_if, определенную в <algorithm>, как показано в примере 11.8.
Пример 11.8 Удаление из последовательности элементов, значения которых меньше заданного
#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>
using namespace std;
struct OutOfRange {
 OutOfRange(int min, int max) :
  min_(min), max_(max) {}
 bool operator()(int x) {
  return (x < min_) || (x > max_);
 }
 int min_;
 int max_;
};
int main() {
 vector<int> v;
 v.push_back(6);
 v.push_back(12);
 v.push_back(10);
 v.push_back(24);
 v.push_back(30);
 remove_copy_if(v.begin(), v.end(),
 ostream_iterator<int>(cout, "\n"), OutOfRange(10, 25));
}
Программа примера 11.8 выдает следующий результат.
12
18
24
Обсуждение
Функция remove_copy_if копирует элементы из одного контейнера в другой контейнер (или итератор вывода), игнорируя те элементы, которые удовлетворяют предоставленному вами предикату (вероятно, было бы более правильно назвать функцию copy_ignore_if). Однако эта функция не изменяет размер целевого контейнера. Если (как часто бывает) количество скопированных функцией remove_copy_if элементов меньше, чем размер целевого контейнера, вам придется уменьшить целевой контейнер с помощью функции-члена erase.
Для функции remove_copy_if требуется унарный предикат (функтор, который принимает один аргумент и возвращает значение типа boolean), который возвращает значение «истина», когда элемент не должен копироваться. В примере 11.8 предикатом является объект-функция OutOfRange. Конструктор OutOfRange принимает нижнюю и верхнюю границу и перегружает оператор operator(). Функция operator() принимает параметр целого типа и возвращает значение «истина», если переданный аргумент меньше, чем нижняя граница, или больше, чем верхняя граница.
11.5. Вычисление дисперсии, стандартного отклонения и других статистических функций
Проблема
Требуется рассчитать значение одной или нескольких обычных статистических функций, например дисперсии (variance), стандартного отклонения (standard deviation), коэффициента асимметрии (skew) и эксцесса (kurtosis) для последовательности чисел.
Решение
Функцию accumulate из заголовочного файла <numeric> можно использовать для расчета многих статистических параметров, а не только для суммирования пользовательских объектов-функций. Пример 11.9 показывает, как можно вычислить значения некоторых важных статистические функций при помощи accumulate.
Пример 11.9. Статистические функции
#include <numeric>
#include <cmath>
#include <algorithm>
#include <functional>
#include <vector>
#include <iostream>
using namespace std;
template<int N, class T>
T nthPnwer(T x) {
 T ret = x;
 for (int i=1; i < N; ++i) {
  ret *= x;
 }
 return ret;
}
template<class T, int N>
struct SumDiffNthPower {
 SumDiffNthPower(T x) : mean_(x) {};
 T operator()(T sum, T current) {
  return sum + nthPower<N>(current - mean_);
 }
 T mean_;
};
template<class T, int N, class Iter_T>
T nthMoment(Iter_T first, Iter_T last, T mean) {
 size_t cnt = distance(first, last);
 return accumulate(first, last, T(), SumDiffNthPower<T, N>(mean)) / cnt;
}
template<class T, class Iter_T>
T computeVariance(Iter_T first, Iter_T last, T mean) {
 return nthMoment<T, 2>(first, last, mean);
}
template<class T, class Iter_T>
T computeStdDev(Iter_T first, Iter_T last, T mean) {
 return sqrt(computeVariance(first, last, mean));
}
template<class T, class Iter_T>
T computeSkew(Iter_T begin, Iter_T end, T mean) {
 T m3 = nthMoment<T, 3>(begin, end, mean);
 T m2 = nthMoment<T, 2>(begin, end, mean);
 return m3 / (m2 * sqrt(m2));
}
template<class T, class Iter_T>
T computeKurtosisExcess(Iter_T begin, Iter_T end, T mean) {
 T m4 = nthMoment<T, 4>(begin, end, mean);
 T m2 = nthMoment<T, 2>(begin, end, mean);
 return m4 / (m2 * m2) - 3;
}
template<class T, class Iter_T>
void computeStats(Iter_T first, Iter_T last, T& sum, T& mean,
 T& var, T& std_dev, T& skew, T& kurt) {
 size_t cnt = distance(first, last);
 sum = accumulate(first, last, T());
 mean = sum / cnt;
 var = computeVariance(first, last, mean);
 std_dev = sort(var);
 skew = computeSkew(first, last, mean);
 kurt = computeKurtosisExcess(first, last, mean);
}
int main() {
 vector<int> v;
 v.push_back(2);
 v.push_back(4);
 v.push_back(8);
 v.push_back(10);
 v.push_back(99);
 v.push_back(1);
 double sum, mean, var, dev, skew, kurt;
 computeStats(v.begin(), v.end(), sum, mean, var, dev, skew, kurt);
 cout << "count = " << v.size() << "\n";
 cout << "sum = " << sum << "\n";
 cout << "mean = " << mean << "\n";
 cout << "variance = " << var << "\n";
 cout << "standard deviation = " << dev << "\n";
 cout << "skew = " << skew << "\n";
 cout << "kurtosis excess = " << kurt << "\n";
 cout << endl;
}
Программа примера 11.9 выдает следующий результат
count = 6
sum = 124
mean = 20.6667
variance = 1237.22
standard deviation = 35.1742
skew = 1.75664
kurtosis excess = 1.14171
Обсуждение
Некоторые наиболее важные статистические функции (например, дисперсия, стандартное отклонение, коэффициент асимметрии и эксцесс) определяются исходя из нормализованных выборочных моментов. Статистические функции определяются немного по-разному в различных текстах. Здесь мы используем несмещенные определения статистических функций, которые сведены в табл. 11.1.
Табл. 11.1. Определения статистических функций
Статистическая функция	Формула
n-й центральный момент (μn)	∑(xi-mean)n
Дисперсия	μ2
Стандартное отклонение	√μ2
Коэффициент асимметрии	μ2/μ33/2
Эксцесс	(μ4/μ2²)-3
Момент характеризует последовательность чисел. Другими словами, он определяет некий способ математического описания последовательности чисел. Моменты являются основой для расчета нескольких важных статистических функций, например дисперсии, стандартного отклонения, коэффициента асимметрии и эксцесса. Центральный момент — это момент, рассчитанный относительно среднего значения, а не нуля. Выборочный момент — это момент, рассчитанный для дискретного набора числовых значений, а не для всех значений функции. Нормализованный момент — это момент, поделенный на некоторую степень стандартного отклонения (стандартное отклонение рассчитывается как квадратный корень второго момента).
Проще всего программировать статистические функции, определяя их через моменты. Поскольку используется несколько различных моментов, каждый из которых характеризуется целочисленной константой, я передаю эту константу как параметр шаблона. Это в целом позволяет компилятору генерировать более эффективный программный код, потому что это целочисленное значение известно на этапе компиляции.
Функция момента определяется при помощи математического оператора суммы. Во всех случаях, когда речь идет об этом операторе, следует иметь в виду функцию accumulate, определенную в заголовочном файле <numeric>. Существует две разновидности функции accumulate: одна подсчитывает сумму, используя operator+, а другая использует функтор суммирования, который вы должны предоставить. Ваш функтор суммирования будет принимать значение накопленной суммы и значение конкретного элемента последовательности.
Пример 11.10 иллюстрирует работу функции accumulate, показывая, как предоставленный пользователем функтор вызывается для каждого элемента последовательности.
Пример 11.10. Пример реализации функции accumulate
template<class Iter_T, class Value_T, class BinOp_T>
Iter_T accumulate(Iter_T begin, Iter_T end, Value_T value, BinOp_T op) {
 while (begin != end) {
  value = op(value, *begin++)
 }
 return value;
}
11.6. Генерация случайных чисел
Проблема
Требуется сгенерировать несколько случайных чисел в формате с плавающей точкой в интервале значений [0.0, 1.0) при равномерном их распределении.
Решение
Стандарт C++ предусматривает наличие C-функции библиотеки этапа исполнения rand, определенной в заголовочном файле <cstdlib>, которая возвращает случайное число в диапазоне от 0 до RAND_MAX включительно. Макропеременная RAND_MAX представляет собой максимальное значение, которое может быть возвращено функцией rand. Пример 11.11 демонстрирует применение функции rand для генерации случайных чисел с плавающей точкой.
Пример 11.11. Генерация случайных чисел функцией rand
#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;
double doubleRand() {
 return double(rand()) / (double(RAND_MAX) + 1.0);
}
int main() {
 srand(static_cast<unsigned int>(clock()));
 cout << "expect 5 numbers within the interval [0.0, 1.0)" << endl;
 for (int i=0; i < 5; i++) {
  cout << doubleRand() << "\n";
 }
 cout << endl;
}
Программа примера 11.11 должна выдать результат, подобный следующему.
expect 5 numbers within the interval [0.0, 1.0)
0.010437
0.740997
0.34906
0.369293
0.544373
Обсуждение
Необходимо уточнить, что функции, генерирующие случайные числа (в том числе rand), возвращают псевдослучайные числа, а не реальные случайные числа, поэтому там, где я говорю «случайное число», я на самом деле имею в виду псевдослучайное число.
Перед применением функции rand вы должны «посеять» (т.е. инициализировать) генератор случайных чисел с помощью вызова функции srand. Это обеспечивает генерацию последующими вызовами rand разных последовательностей чисел при каждом новом исполнении программы. Проще всего инициализировать генератор случайных чисел путем передачи ему результата вызова функции clock из заголовочного файла <ctime>, имеющего тип unsigned int. Повторная инициализация генератора случайных чисел приводит к тому, что генерируемые числа становятся менее случайными.
Функция rand имеет много ограничений. Прежде всего, она генерирует только целые числа, и эти числа могут иметь только равномерное распределение. Более того, конкретный алгоритм генерации случайных чисел зависит от реализации, и поэтому последовательности случайных чисел нельзя воспроизвести при переходе от одной системы к другой при одинаковой инициализации. Это создает трудности для определенного типа приложений, а также при тестировании и отладке.
Значительно более изощренную альтернативу rand представляет написанная Джензом Маурером (Jens Maurer) библиотека Boost Random; она была инспирирована предложениями по генерации случайных чисел, представленными в TR1.
TR1 означает «Technical Report One» и представляет собой официальный проект по расширению стандартной библиотеки C++98.
Библиотека Boost Random содержит несколько высококачественных функций по генерации случайных чисел как для целых типов, так и для типов с плавающей точкой, причем с поддержкой многочисленных распределений. Пример 11.12 показывает, как можно сгенерировать случайные числа с плавающей точкой в интервале значений [0,1).
Пример 11.12. Использование библиотеки Boost Random
#include <boost/random.hpp>
#include <iostream>
#include <cstdlib>
using namespace std;
using namespace boost;
typedef boost::mt19937 BaseGenerator;
typedef boost::uniform_real<double> Distribution;
typedef boost::variate_generator<BaseGenerator, Distribution> Generator;
double boostDoubleRand() {
 static BaseGenerator base;
 static Distribution dist;
 static Generator rng(base, dist);
 return rng();
}
int main() {
 cout << "expect 5 numbers within the interval [0.1)" << endl;
 for (int i=0; i < 5; i++) {
  cout << boostDoubleRand() << "\n";
 }
 cout << endl;
}
Основное преимущество библиотеки Boost Random в том, что алгоритм генерации псевдослучайных чисел обеспечивает гарантированные и воспроизводимые свойства случайных последовательностей, зависящих от выбранного алгоритма. В примере 11.12 я использую генератор Mersenne Twister (mt19937), потому что он дает хорошее сочетание производительности и качества последовательности случайных чисел.
11.7. Инициализация контейнера случайными числами
Проблема
Требуется заполнить произвольный контейнер случайными числами.
Решение
Можно использовать функции generate и generate_n из заголовочного файла <algorithm> совместно с функтором, возвращающим случайные числа. Пример 11.13 показывает, как это можно сделать.
Пример 11.13. Инициализация контейнеров случайными числами
#include <algorithm>
#include <vector>
#include <iterator>
#include <iostream>
#include <cstdlib>
using namespace std;
struct RndIntGen {
 RndIntGen(int l, int h) : low(l), high(h) {}
 int operator()() const {
  return low + (rand() % ((high - low) + 1));
 }
private:
 int low;
 int high;
};
int main() {
 srand(static_cast<unsigned int>(clock()));
 vector<mt> v(5);
 generate(v.begin(), v.end(), RndIntGen(1, 6));
 copy(v.begin(), v.end(), ostream_iterator<int>(cout, "\n"));
}
Программа примера 11.13 должна выдать результат, подобный следующему.
3
1
2
6
4
Обсуждение
Стандартная библиотека C++ содержит функции generate и generate_n, специально предназначенные для заполнения контейнеров значениями, полученными функцией генератора случайных чисел. Эти функции принимают нуль-арный функтор (указатель на функцию или объект-функцию без аргументов), результат которого присваивается соседним элементам контейнера. Пример реализации функции generate и generate_n показан в примере 11.14.
Пример 11.14. Пример реализации функций generate и generate_n
template<class Iter_T, class Fxn_T>
void generate(Iter_T first, Iter_T last, Fxn_T f) {
 while (first != last) *first++ = f();
}
template<class Iter_T, class Fxn_T>
void generate_n(Iter_T first, int n, Fxn_T f) {
 for (int i=0; i < n; ++i) *first++ = f();
}
11.8. Представление динамического числового вектора
Проблема
Требуется иметь тип для манипулирования динамическими числовыми векторами.
Решение
Вы можете использовать шаблон valarray из заголовочного файла <valarray>. Пример 11.15 показывает, как можно использовать шаблон valarray.
Пример 11.15. Применение шаблона valarray
#include <valarray>
#include <iostream>
using namespace std;
int main() {
 valarray<int> v(3);
 v[0] = 1;
 v[1] = 2;
 v[2] = 3;
 cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
 v = v + v;
 cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
 v /= 2;
 cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
}
Программа примера 11.15 выдаст следующий результат.
1, 2, 3
2, 4, 6
1, 2, 3
Обсуждение
Вопреки своему названию тип vector не предназначен для использования в качестве числового вектора, для этой цели используется шаблон valarray. Этот шаблон написан так, чтобы в конкретных реализациях С++, особенно на высокопроизводительных машинах, можно было применить к нему специальную векторную оптимизацию. Другое большое преимущество valarray состоит в наличии многочисленных перегруженных операторов, предназначенных для работы с числовыми векторами. Эти операторы обеспечивают выполнение таких операций, как сложение и скалярное умножение векторов.
Шаблон valarray может также использоваться в стандартных алгоритмах, работающих с массивами, представленными в C-стиле. Пример 11.16 показывает, как можно создавать итераторы, ссылающиеся на начальный элемент valarray и на элемент, следующий за последним.
Пример 11.16. Получение итераторов для valarray
template<class T>
T* valarray_begin(valarray<T>& x) {
 return &x[0];
}
template<class T> T* valarray_end(valarray<T>& x) {
 return valarray_begin(x) + x.size();
}
Несмотря на немного академичный вид этого примера, не следует пытаться создавать итератор конца valarray, используя выражение &x[х.size()]. Если это сработает, то только случайно, поскольку индексация valarray, выходящая за допустимый индексный диапазон, приводит к непредсказуемому результату.
Отсутствие в valarray функций-членов begin и end, несомненно, противоречит стилю STL. Отсутствие этих функций подчеркивает то, что в valarray реализуется модель, отличная от концепции контейнера STL. Несмотря на это, вы можете использовать valarray в любом обобщенном алгоритме, где требуется итератор с произвольным доступом.
11.9. Представление числового вектора фиксированного размера
Проблема
Требуется иметь эффективное представление числовых векторов фиксированного размера.
Решение
В программном обеспечении обычного типа часто более эффектный результат по сравнению с valarray дает применение специальной реализации вектора, когда его размер заранее известен на этапе компиляции. Пример 11.17 показывает, как можно реализовать шаблон вектора фиксированного размера, названный здесь kvector.
Пример 11.17. kvector.hpp
#include <algorithm>
#include <cassert>
template<class Value_T, unsigned int N>
class kvector {
public:
 // открытые поля
 Value_T m[N];
 // открытые имена, вводимые typedef
 typedef Value_T value_type;
 typedef Value_T* iterator;
 typedef const Value_T* const_iterator;
 typedef Value_T& reference;
 typedef const Value_T& const_reference;
 typedef size_t size_type;
 // определение более короткого синонима для kvector
 typedef kvector self;
 // функции-члены
 template<typename Iter_T>
 void copy(Iter_T first, Iter_T last) {
  copy(first, last, begin());
 }
 iterator begin() { return m; }
 iterator end() { return m + N; }
 const_iterator begin() const { return m; }
 const_iterator end() const { return m + N; }
 reference operator[](size_type n) { return m[n]; }
 const_reference operator[](size_type n) const { return m[n]; }
 static size_type size() { return N; }
 // векторные операции
 self& operator+=(const self& x) {
  for (int i=0; i<N; ++i) m[i] += x.m[i];
  return *this;
 }
 self& operator-=(const self& x) {
  for (int i=0; i<N; ++i) m[i] -= x.m[i];
  return *this;
 }
 // скалярные операции
 self& operator=(value_type x) {
  std::fill(begin(), end(), x);
  return *this;
 }
 self& operator+=(value_type x) {
  for (int i=0; i<N; ++i) m[i] += x;
  return *this;
 }
 self& operator-=(value_type x) {
  for (int i=0; i<N; ++i) m[i] -= x;
  return *this;
 }
 self& operator*=(value_type x) {
  for (int i=0; i<N; ++i) m[i] *= x;
  return *this;
 }
 self& operator/=(value_type x) {
  for (int i=0; i<N; ++i) m[i] /= x;
  return *this;
 }
 self& operator%=(value_type x) {
  for (int i=0; i<N; ++i) m[i] %= x;
  return *this;
 }
 self operator-() {
  self x;
  for (int i=n; i<N; ++i) x.m[i] = -m[i];
  return x;
 }
 // дружественные операторы
 friend self operator+(self x, const self& y) { return x += у; }
 friend self operator-(self x, const self& y) { return x -= y; }
 friend self operator+(self x, value_type y) { return x += y; }
 friend self operator-(self x, value_type y) { return x -= y; }
 friend self operator*(self x, value_type y) { return x *= y; }
 friend self operator/(self x, value_type y) { return x /= y; }
 friend self operator%(self x, value type y) { return x %= y; }
};
Пример 11.18 показывает, как можно применять шаблон класса kvector.
Пример 11.18. Применение вектора kvector
#include "kvector.hpp"
#include <algorithm>
#include <numeric>
#include <iostream>
using namespace std;
int main() {
 kvector<int, 4> v = { 1, 2, 3, 4 };
 cout << "sum = " << accumulate(v.begin(), v.end(), 0) << endl;
 v *= 3;
 cout << "sum = " << accumulated.begin(), v.end(), 0) << endl;
 v += 1;
 cout << "sum = " << accumulate(v.begin(), v.end(), 0) << endl;
}
Программа примера 11.18 выдаст следующий результат.
sum = 10
sum = 30
sum = 34
Обсуждение
Представленный в примере 11.17 шаблон kvector является гибридом valarray и шаблона массива, предложенного в TR1. Как и valarray, вектор kvector представляет собой последовательность значений заданного числового типа, однако подобно массиву TR1::array его размер известен на этапе компиляции.
Характерной особенностью шаблона kvector является то, что для его инициализации может использоваться синтаксис, применяемый для массивов, и то, что он имеет функции-члены begin и end. Фактически kvector можно рассматривать как псевдоконтейнер, т.е. он удовлетворяет некоторым, но не всем требованиям концепции стандартного контейнера. Следствие этого — более легкое применение kvector в стандартных алгоритмах по сравнению с valarray.
Другое преимущество шаблонного класса kvector состоит в том, что он поддерживает синтаксис, используемый при инициализации массивов.
int x;
kvector<int, 3> k = { x = 1, x+2, 5}
Этот синтаксис возможен только потому, что kvector является агрегатом. Агрегат (aggregate) — это массив или класс, который не имеет объявленных пользователем конструкторов, закрытых или защищенных данных-членов, базового класса и виртуальных функций. Следует отметить, что все же можно при объявлении kvector его заполнить значениями по умолчанию.
kvector<int, 3> k = {};
В результате этот вектор будет заполнен нулями.
Как вы видите, при его реализации мной был найден компромисс между полным удовлетворением требований, предъявляемых к стандартным контейнерам, и возможностью использования синтаксиса, применяемого при инициализации массивов. Аналогичный компромисс был найден при проектировании шаблона array, удовлетворяющего требованиям TR1.
Возможно, самое большое преимущество kvector над реализациями динамического вектора проявляется в его высокой производительности. По двум причинам шаблон kvector значительно эффективнее, чем большинство реализаций динамических векторов: компиляторы очень хорошо справляются с оптимизацией циклов фиксированною размера, и здесь нет динамического распределения памяти. Различия в производительности особенно проявляются при работе с небольшими матрицами (например, 2×2 или 3×3), которые часто встречаются во многих приложениях.
Что означает имя «self», введенное оператором typedef?
Введенное с помощью typedef имя self я использую в примере 11.17 и в последующих примерах; оно представляет собой удобное краткое имя, которое я использую для ссылки на тип текущего класса. Программу значительно легче писать и воспринимать при использовании self вместо имени класса.
11.10. Вычисление скалярного произведения
Проблема
Имеется два контейнера, содержащих числа, причем они имеют одинаковую длину, и требуется вычислить их скалярное произведение.
Решение
Пример 11.19 показывает, как можно вычислить скалярное произведение, используя функцию inner_product из заголовочного файла <numeric>.
Пример 11.19. Расчет скалярного произведения
#include <numeric>
#include <iostream>
#include <vector>
using namespace std;
int main() {
 int v1[] = { 1, 2, 3 };
 int v2[] = { 4, 6, 8 };
 cout << "the dot product of (1,2,3) and (4,6,8) is ";
 cout << inner_product(v1, v1 + 3, v2, 0) << endl;
}
Программа примера 11.19 выдает следующий результат.
the dot product of (1,2,3) and (4,6,8) is 40
Обсуждение
Скалярное произведение (dot product) является одной из форм обобщенного скалярного произведения (inner product), называемой евклидовым скалярным произведением (Euclidean Inner Product). Функция inner_product объявляется следующим образом.
template<class In, class In2, class T>
T inner_product(In first, In last, In2 first2, T init);
template<class In, class In2, class T, class BinOp, class BinOp2>
T inner_product(In first, In last, In2 first2, T init, BinOp op, BinOp2 op2);
Первый вариант функции inner_product суммирует произведения соответствующих элементов двух контейнеров. Второй вариант функции inner_product позволяет вам самому предоставить операцию над парой чисел и функцию суммирования. В примере 11.20 продемонстрирована простая реализация функции inner_product.
Пример 11.20. Пример реализации функции inner_product()
template<class In, class In2, class T, class BinOp, class BinOp2>
T inner_product(In first, In last, In2 first2, T init, BinOp op, Binop2 op2) {
 while (first != last) {
  BinOp(init, BinOp2(*first++, *first2++));
 }
 return init;
}
Благодаря гибкости реализации функции inner_product вы можете ее использовать для многих других целей, а не только для расчета скалярного произведения (например, ее можно использовать для вычисления расстояния между двумя векторами или для вычисления нормы вектора).
Смотри также
Рецепты 11.11 и 11.12.
11.11. Вычисление нормы вектора
Проблема
Требуется найти норму (т. е. длину) числового вектора.
Решение
Можно использовать функцию inner_product из заголовочного файла <numeric> для умножения вектора на самого себя, как показано в примере 11.21.
Пример 11.21. Вычисление нормы вектора
#include <numeric>
#include <vector>
#include <cmath>
#include <iostream>
using namespace std;
template<typename Iter_T>
long double vectorNorm(Iter_T first, Iter_T last) {
 return sqrt(inner_product(first, last, first, 0.0L));
}
int main() {
 int v[] = { 3, 4 };
 cout << "The length of the vector (3.4) is ";
 cout << vectorNorm(v, v + 2) << endl;
}
Программа примера 11.21 выдает следующий результат.
The length of the vector (3,4) is 5
Обсуждение
В примере 11.21 функция inner_product из заголовочного файла <numeric> используется для вычисления скалярного произведения числового вектора на самого себя. Квадратный корень полученного значения, как известно, является нормой вектора, или длиной вектора.
Вместо того чтобы в функции vectorNorm выводить тип результата по аргументам, я решил для него использовать тип long double, чтобы терять как можно меньше данных. Если вектор представляет собой набор значений целого типа, маловероятно, что в реальных условиях норма вектора может быть адекватно представлена целым типом.
11.12. Вычисление расстояния между векторами
Проблема
Требуется найти евклидово расстояние между векторами.
Решение
Евклидово расстояние между векторами определяется как квадратный корень суммы квадратов разностей соответствующих элементов. Рассчитать его можно так, как показано в примере 11.22.
Пример 11.22. Расчет расстояния между двумя векторами
#include <cmath>
#include <iostream>
using namespace std;
template<class Iter_T, class Iter2_T>
double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2) {
 double ret = 0.0;
 while (first != last) {
  double dist = (*first++) - (*first2++);
  ret += dist * dist;
 }
 return ret > 0.0 ? sqrt(ret) : 0.0;
}
int main() {
 int v1[] = { 1, 5 };
 int v2[] = { 4, 9 };
 cout << "distance between vectors (1,5) and (4,9) is ";
 cout << vectorDistance(v1, v1 + 2, v2) << endl;
}
Программа примера 11.22 выдает следующий результат.
distance between vectors (1,5) and (4,9) is 5
Обсуждение
Пример 11.22 реализует прямое решение, которое показывает, как следует писать простую обобщенную функцию в стиле STL. Для расчета расстояний между векторами я мог бы использовать функцию inner_product, однако я не стал использовать функтор, потому что это неоправданно усложнило бы решение. Пример 11.23 показывает, как можно рассчитывать расстояние между векторами, применяя функтор и функцию inner_product из заголовочного файла <numeric>.
Пример 11.23. Расчет расстояния между векторами с использованием функции inner_product
#include <numeric>
#include <cmath>
#include <iostream>
#include <functional>
using namespace std;
template<class Value_T>
struct DiffSquared {
 Value_T operator()(Value_T x, Value_T y) const {
  return (x - y) * (x - y);
 }
};
template<class Iter_T, class Iter2_T>
double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2) {
 double ret = inner_product(first, last, first2, 0.0L,
  plus<double>(), DiffSquared<double>());
 return ret > 0.0 ? sqrt(ret) : 0.0;
}
int main() {
 int v1[] = { 1, 5 };
 int v2[] = { 4, 9 };
 cout << "distance between vectors (1,5) and (4,9) is ";
 cout << vectorDistance(v1, v1 + 2, v2) << endl;
}
Поскольку реализация функции inner_product() может быть специально оптимизирована для вашей платформы и вашего компилятора, я предпочитаю ее использовать везде, где это возможно.
11.13. Реализация итератора с шагом
Проблема
Имеются смежные числовые ряды и требуется обеспечить доступ к каждому n-му элементу.
Решение
В примере 11.24 представлен заголовочный файл, реализующий класс итератора с шагом.
Пример 11.24. stride_iter.hpp
#ifndef STRIDE_ITER_HPP
#define STRIDE_ITER_HPP
#include <iterator>
#include <cassert>
template<class Iter_T>
class stride_iter {
public:
 // открытые имена, вводимые typedef
 typedef typename std::iterator_traits<Iter_T>::value_type value_type;
 typedef typename std::iterator_traits<Iter_T>::reference reference;
 typedef typename std::iterator_traits<Iter_T>::difference_type
  difference_type;
 typedef typename std::iterator_traits<Iter_T>::pointer pointer;
 typedef std::random_access_iterator_tag iterator_category;
 typedef stride_iter self;
 // конструкторы
 stride_iter() : m(NULL), step(0) {};
 stride_iter(const self& x) : m(x.m), step(x.step) {}
 stride_iter(Iter_T x, difference_type n) : m(x), step(n) {}
 // операторы
 self& operator++() { m += step; return *this; }
 self operator++(int) { self tmp = *this; m += step; return tmp; }
 self& operator+=(difference_type x) { m += x * step; return *this; }
 self& operator--() { m -= step; return *this; }
 self operator--(int) { self tmp = *this; m -= step; return trap; }
 self& operator--(difference type x) { m -= x + step; return *this; }
 reference operator[](difference_type n) { return m[n * step]; }
 reference operator*() { return *m; }
 // дружественные операторы
 friend bool operator==(const self& x, const self& y) {
  assert(x.step == y.step);
  return x.m == y.m;
 }
 friend bool operator!=(const self& x, const self& y) {
  assert(x.step == y.step);
  return x.m != y.m;
 }
 friend bool operator<(const self& x, const self& y) {
  assert(x.step == y.step);
  return x.m < y.m;
 }
 friend difference type operator-(const self& x, const self& y) {
  assert(x.step == y.step);
  return (x.m - y.m) / x.step;
 }
 friend self operator+(const self& x, difference_type y) {
  assert(x.step == y.step);
  return x += y * x.step;
 }
 friend self operator+(difference_type x, const self& y) {
  assert(x.step == y.step);
  return y += x * x.step;
 }
private:
 Iter_T m;
 difference_type step;
};
#endif
Пример 11.25 показывает, как можно использовать итератор stride_iter из примера 11.24 для получения доступа к каждому второму элементу последовательности.
Пример 11.25. Применение итератора stride_iter
#include "stride_iter.hpp"
#include <algorithm>
#include <iterator>
#include <iostream>
using namespace std;
int main() {
 int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 stride_iter<int*> first(a, 2);
 stride_iter<int*> last(a + 8, 2);
 copy(first, last, ostream_iterator<int>(cout, "\n"));
}
Программа примера 11.25 выдает следующий результат.
0
2
4
6
Обсуждение
Итераторы с шагом часто используются при работе с матрицами. Они обеспечивают простой и эффективный способ реализации матриц в виде набора числовых рядов. Представленная в примере 11.24 реализация итератора с шагом выполнена в виде оболочки другого итератора, который передается как параметр шаблона.
Я хотел сделать итератор с шагом совместимым с STL, поэтому пришлось выбрать подходящий тип стандартного итератора и удовлетворить его требования. Представленный в примере 11.24 итератор с шагом сделан по образцу итератора с произвольным доступом.
В примере 11.26 я отдельно привел реализацию итератора с шагом (названную kstride_iter), когда размер шага известен на этапе компиляции. Поскольку размер шага передается как параметр шаблона, компилятор может оптимизировать программный код итератора более эффективно, и размер итератора уменьшается.
Пример 11.26. kstride_iter.hpp
#ifndef KSTRIDE_ITER_HPP
#define KSTRIDE_ITER_HPP
#include <iterator>
template<class Iter_T, int Step_N>
class kstride_iter {
public:
 // открытые имена, вводимые typedef
 typedef typename std::iterator_traits<Iter_T>::value_type value_type;
 typedef typename std::iterator_traits<Iter_T>::reference reference;
 typedef typename std::iterator_traits<Iter_T>::difference_type
  difference_type;
 typedef typename std::iterator_traits<Iter_T>::pointer pointer;
 typedef std::random_access_iterator_tag iterator_category;
 typedef kstride_iter self;
 // конструкторы
 kstride_iter() : m(NULL) {} kstride_iter(const self& x) : m(x.m) {}
 explicit kstride_iter(Iter_T x) : m(x) {}
 // операторы
 self& operator++() { m += Step_N; return *this; }
 self operator++(int) { self tmp = *this; m += Step_N; return tmp; }
 self& operator+=(difference_type x) { m += x * Step_N; return *this; }
 self& operator--() { m -= Step_N; return *this; }
 self operator--(int) { self tmp = *this; m -= Step_N; return tmp; }
 self& operator--(difference_type x) { m -= x * Step_N; return *this; }
 reference operator[](difference_type n) { return m[n * Step_N]; }
 reference operator*() { return *m; }
 // дружественные операторы
 friend bool operator==(self x, self y) { return x.m == y.m; }
 friend bool operator!=(self x, self y) { return x.m != y.m; }
 friend bool operator<(self x, self y) { return x.m < y.m; }
 friend difference_type operator-(self x, self y) {
  return (x.m - y.m) / Step_N;
 }
 friend self operator+(self x, difference_type y) { return x += y * Step_N; }
 friend self operator+(difference_type x, self y) { return y += x * Step_N; }
private:
 Iter_T m;
};
#endif
Пример 11.27 показывает, как можно использовать итератор kstride_iter.
Пример 11.27. Применение итератора kstride_iter
#include "kstride_iter.hpp"
#include <algorithm>
#include <iterator>
#include <iostream>
using namespace std;
int main() {
 int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 kstride_iter<int*, 2> first(a);
 kstride_iter<int*, 2> last(a + 8);
 copy(first, last, ostream_iterator<int>(cout, "\n"));
}
11.14. Реализация динамической матрицы
Проблема
Требуется реализовать числовые матрицы, размерности которых (количество строк и столбцов) неизвестны на этапе компиляции.
Решение
В примере 11.28 показана универсальная и эффективная реализация класса динамической матрицы, использующая итератор с шагом из рецепта 11.12 и valarray.
Пример 11.28. matrix.hpp
#ifndef MATRIX_HPP
#define MATRIX_HPP
#include "stride_iter.hpp" // см. рецепт 11.12
#include <valarray>
#include <numeric>
#include <algorithm>
template<class Value_T>
class matrix {
public:
 // открытые имена, вводимые typedef
 typedef Value_T value_type;
 typedef matrix self;
 typedef value_type* iterator;
 typedef const value_type* const_iterator;
 typedef Value_T* row_type;
 typedef stride_iter<value_type*> col_type;
 typedef const value_type* const_row_type;
 typedef stride_iter<const value_type*> const_col_type;
 // конструкторы
 matrix() : nrows(0), ncols(0), m() {}
 matrix(int r, int c) : nrows(r), ncols(c), m(r * с) {}
 matrix(const self& x) : m(x.m), nrows(x.nrows), ncols(x.ncols) {}
 template<typename T>
 explicit matrix(const valarray<T>& x)
  : m(x.size() + 1), nrows(x.size()), ncols(1) {
  for (int i=0; i<x.size(); ++i) m[i] = x[i];
 }
 // позволить конструирование из матриц других типов
 template<typename T> explicit matrix(const matrix<T>& x)
  : m(x.size() + 1), nrows(x.nrows), ncols(x.ncols) {
  copy(x.begin(), x.end(), m.begin());
 }
// открытые функции
 int rows() const { return nrows; }
 int cols() const { return ncols; }
 int size() const { return nrows * ncols; }
 // доступ к элементам
 row_type row begin(int n) { return &m[n * cols()]; }
 row_type row_end(int n) { return row_begin() + cols(); }
 col_type col_begin(int n) { return col_type(&m[n], cols()); }
 col_type col_end(int n) { return col_begin(n) + cols(); }
 const_row_type row_begin(int n) const { return &m[n * cols()]; }
 const_row_type row_end(int n) const { return row_begin() + cols(); }
 const_col_type col_begin(int n) const { return col_type(&m[n], cols()); }
 const_col_type col_end(int n) const { return col_begin() + cols(); }
 iterator begin() { return &m[0]; }
 iterator end() { return begin() + size(); }
 const_iterator begin() const { return &m[0]; }
 const_iterator end() const { return begin() + size(); }
 // операторы
 self& operator=(const self& x) {
  m = x.m;
  nrows = x.nrows;
  ncols = x.ncols;
  return *this;
 }
 self& operator=(value_type x) { m = x; return *this; }
 row_type operator[](int n) { return row_begin(n); }
 const_row_type operator[](int n) const { return row_begin(n); }
 self& operator+=(const self& x) { m += x.m; return *this; }
 self& operator-=(const self& x) { m -= x.m; return *this; }
 self& operator+=(value_type x) { m += x; return *this; }
 self& operator-=(value_type x) { m -= x; return *this; }
 self& operator*=(value_type x) { m *= x; return *this; }
 self& operator/=(value_type x) { m /= x; return *this; }
 self& operator%=(value_type x) { m %= x; return *this; }
 self operator-() { return -m; }
 self operator+() { return +m; }
 self operator!() { return !m; }
 self operator~() { return ~m; }
 // дружественные операторы
 friend self operator+(const self& x, const self& y) { return self(x) += y; }
 friend self operator-(const self& x, const self& y) { return self(x) -= y; }
 friend self operator+(const self& x, value_type y) { return self(x) += y; }
 friend self operator-(const self& x, value_type y) { return self(x) -= y; }
 friend self operator*(const self& x, value type y) { return self(x) *= y; }
 friend self operator/(const self& x, value_type y) { return self(x) /= y; }
 friend self operator%(const self& x, value_type y) { return self(x) %= y; }
private:
 mutable valarray<Value_T> m;
 int nrows;
 int ncols;
};
#endif
Пример 11.29 показывает, как можно использовать шаблонный класс matrix.
Пример 11.29. Применение шаблона matrix
#include "matrix.hpp"
#include <iostream>
using namespace std;
int main() {
 matrix<int> m(2,2);
 m = 0;
 m[0][0] = 1;
 m[1][1] = 1;
 m *= 2;
 cout << "(" << m[0][0] << "," << m[0][1] << ")" << endl;
 cout << "(" << m[1][0] << "," << m[1][1] << ")" << endl;
}
Программа примера 11.29 выдает следующий результат.
(2,0)
(0,2)
Обсуждение
Проект шаблона матрицы, представленный в примере 11.28, в значительной степени инспирирован шаблоном матрицы Бьерна Страуструпа (Bjarne Stroustrup) из его книги «The C++ Programming Language», 3-е издание (издательство «Addison Wesley»). Реализация Страуструпа отличается тем, что его итератор использует класс slice и указатель на valarray для индексации. Реализованная в примере 11.27 матрица использует вместо них итератор с шагом из рецепта 11.12, что делает итераторы более компактными и при некоторых реализациях более эффективными.
Шаблонный класс matrix позволяет индексировать элемент i-й строки и j-го столбца, используя операцию двойной индексации. Например:
matrix<int> m(100,100);
cout << "the element at row 24 and column 42 is " << m[24][42] << endl;
Шаблонный класс matrix также имеет функции-члены begin и end, т.е. его легко можно использовать в различных алгоритмах STL.
Пример 11.28 содержит строку, которая, возможно, вызывает у вас некоторое удивление. Имеется в виду следующее объявление.
mutable valarray<Value_T> m;
Объявление поля-члена m со спецификатором mutable вынужденно. В противном случае я не мог бы обеспечить итераторы со спецификатором const, потому что нельзя создать итератор для const valarray.
Смотри также
Рецепты 11.15 и 11.16.
11.15. Реализация статической матрицы
Проблема
Требуется эффективно реализовать матрицу, когда ее размерность (т.е. количество строк и столбцов) постоянна и известна на этапе компиляции.
Решение
Когда размерность матрицы известна на этапе компиляции, компилятор может легко оптимизировать реализацию, в которой количество строк и столбцов задается в виде параметров шаблона, как показано в примере 11.30.
Пример 11.30. kmatrix.hpp
#ifndef KMATRIX_HPP
#define KMATRIX_HPP
#include "kvector.hpp"
#include "kstride_iter.hpp"
template<class Value_T, int Rows_N, int Cols_N>
class kmatrix {
public:
 // открытые имена, вводимые typedef
 typedef Value_T value_type;
 typedef kmatrix self;
 typedef Value_T* iterator;
 typedef const Value_T* const_iterator;
 typedef kstride_iter<Value_T*, 1> row_type;
 typedef kstride_iter<Value_T*, Cols_N> col_type;
 typedef kstride_iter<const Value_T*, 1> const_row_type;
 typedef kstride_iter<const Value T*, Cols_N> const_col_type;
 // открытые константы
 static const int nRows = Rows_N;
 static const int nCols = Cols_N;
 // конструкторы
 kmatrix() { m = Value_T(); }
 kmatrix(const self& x) { m = x.m; }
 explicit kmatrix(Value_T& x) { m = x.m; }
 // открытые функции
 static int rows() { return Rows_N; }
 static int cols() { return Cols_N; }
 row_type row(int n) { return row_type(begin() * (n * Cols_N)); }
 col_type col(int n) { return col_type(begin() + n); }
 const_row_type row(int n) const {
  return const_row_type(begin() + (n * Cols_N));
 }
 const_col_type col(int n) const {
  return const_col_type(begin() + n);
 }
 iterator begin() { return m.begin(); }
 iterator end() { return m.begin() + size(); }
 const_iterator begin() const { return m; }
 const_iterator end() const { return m + size(); }
 static int size() { return Rows_N * Cols_N; }
 // операторы
 row_type operator[](int n) { return row(n); }
 const_row_type operator[](int n) const { return row(n); }
 // операции присваивания
 self& operator=(const self& x) { m = x.m; return *this; }
 self& operator=(value_type x) { m = x; return *this; }
 self& operator+=(const self& x) { m += x.m; return *this; }
 self& operator-=(const self& x) { m -= x.m; return *this; }
 self& operator+={value_type x) { m += x; return *this; }
 self& operator-=(value_type x) { m -= x; return *this; }
 self& operator*=(value_type x) { m *= x; return *this; }
 self& operator/=(value_type x) { m /= x; return *this; }
 self operator-() { return self(-m); }
 // друзья
 friend self operator+(self x, const self& у) { return x += y; }
 friend self operator-(self x, const self& y) { return x -= y; }
 friend self operator+(self x, value_type y) { return x += y; }
 friend self operator-(self x, value type y) { return x -= y; }
 friend self operator*(self x, value_type y) { return x *= y; }
 friend self operator/(self x, value_type y) { return x /= y; }
 friend bool operator==(const self& x, const self& y) { return x == y; }
 friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
private:
 kvector<Value_T, (Rows_N + 1) * Cols_N> m;
};
#endif
В примере 11.31 приведена программа, демонстрирующая применение шаблонного класса kmatrix.
Пример 11.31. Применение kmatrix
#include "kmatrix.hpp"
#include <iostream>
using namespace std;
template<class Iter_T>
void outputRowOrColumn(Iter_T iter, int n) {
 for (int i=0; i < n; ++i) {
  cout << iter[i] << " ";
 }
 cout << endl;
}
template<class Matrix_T>
void initializeMatrix(Matrix_T& m) {
 int k = 0;
 for (int i=0; i < m.rows(); ++i) {
  for (int j=0; j < m.cols(); ++j) {
   m[i][j] = k++;
  }
 }
}
template<class Matrix_T>
void outputMatrix(Matrix_T& m) {
 for (int i=0; i < m.rows(); ++i) {
  cout << "Row " << i << " = ";
   outputRowOrColumn(m.row(i), m.cols());
 }
 for (int i=0; i < m.cols(); ++i) {
  cout << "Column " << i << " = ";
   outputRowOrColumn(m.col(i), m.rows());
 }
}
int main() {
 kmatrix<int, 2, 4> m;
 initializeMatrix(m); m *= 2;
 outputMatrix(m);
}
Программа примера 11.31 выдает следующий результат.
Row 0 = 0 2 4 6
Row 1 = 8 10 12 14
Column 0 = 0 8
Column 1 = 2 10
Column 2 = 4 12
Column 3 = 6 14
Обсуждение
Представленные в примерах 11.30 и 11.31 определение шаблона класса kmatrix и пример его использования очень напоминают шаблон класса matrix из рецепта 11.14. Единственным существенным отличием является то, что при объявлении экземпляра kmatrix приходится передавать размерности матрицы через параметры шаблона, например;
kmatrix<int 5, 6> m; // объявляет матрицу с пятью строками и шестью
                     // столбцами
В приложениях многих типов часто требуется, чтобы матрицы имели размерности, известные на этапе компиляции. Передача размера строк и столбцов через параметры шаблона позволяет компилятору легче применять такую оптимизацию, как развертка цикла, встраивание функций и ускорение индексации.
Как и рассмотренный ранее шаблон статического вектора (kvector), шаблон kmatrix особенно эффективен при небольших размерах матрицы.
Смотри также
Рецепты 11.14 и 11.16.
11.16. Умножение матриц
Проблема
Требуется эффективно выполнить умножение двух матриц.
Решение
Пример 11.32 показывает, как можно выполнить умножение матриц, причем эта реализация подходит как для динамических, так и для статических матриц. Формально этот алгоритм реализует соотношение A=A+B*C, которое (возможно, неожиданно) вычисляется более эффективно, чем A=B*C.
Пример 11.32. Умножение матриц
#include "matrix.hpp" // рецепт 11.13
#include "kmatrix.hpp" // рецепт 11.14
#include <iostream>
#include <cassert>
using namespace std;
template<class M1, class M2, class M3>
void matrixMultiply(const M1& m1, const M2& m2, M3& m3) {
 assert(m1.cols() == m2.rows());
 assert(m1.rows() == m3.rows());
 assert(m2.cols() == m3.cols());
 for (int i=m1.rows()-1; i >= 0; --i) {
  for (int j=m2.cols()-1; j >= 0; --j) {
   for (int k = m1.cols()-1; k >= 0; --k) {
    m3[i][j] += m1[i][k] * m2[k][j];
   }
  }
 }
}
int main() {
 matrix<int> m1(2, 1);
 matrix<int> m2(1, 2);
 kmatrix<int, 2, 2> m3;
 m3 = 0;
 m1[0][0] = 1;
 m1[1][0] = 2;
 m2[0][0] = 3;
 m2[0][1] = 4;
 matrixMultlply(m1, m2, m3);
 cout << "(" << m3[0][0] << ", " << m3[0][1] << ")" << endl;
 cout << "(" << m3[1][0] << ", " << m3[1][1 ] << ")" << endl;
}
Программа примера 11.32 выдает следующий результат.
(3, 4)
(6, 8)
Обсуждение
При умножении двух матриц число столбцов первой матрицы должно равняться числу строк второй матрицы. Число строк полученной матрицы равно числу строк первой матрицы, а число столбцов равно числу столбцов второй матрицы. Я обеспечиваю эти условия в отладочной версии с помощью макроса assert, определенного в заголовочном файле <cassert>.
Решающее значение для эффективной реализации умножения имеет отсутствие избыточных операций по созданию и копированию временных объектов. Так, представленная в примере 11.32 функция умножения матриц передает результат по ссылке. Если бы алгоритм умножения я реализовал впрямую путем перегрузки оператора operator*, это привело бы к лишним операциям распределения, копирования и освобождения памяти, занимаемой временной матрицей. Потенциально такой подход может оказаться очень затратным при работе с большими матрицами.
В примере 11.32 реализуется равенство A=A+B*C, а не A=B*C, для того чтобы избежать лишней инициализации значений матрицы A.
Смотри также
Рецепт 11.17.
11.17. Вычисление быстрого преобразования Фурье
Проблема
Требуется выполнить эффективный расчет дискретного преобразования Фурье (ДПФ), используя алгоритм быстрого преобразования Фурье (БПФ).
Решение
Программный код примера 11.33 обеспечивает базовую реализацию БПФ.
Пример 11.33. Реализация БПФ
#include <iostream>
#include <complex>
#include <cmath>
#include <iterator>
using namespace std;
unsigned int bitReverse(unsigned int x, int log2n) {
 int n = 0;
 int mask = 0x1;
 for (int i=0; i < log2n; i++) {
  n <<= 1;
  n |= (x & 1);
  x >>= 1;
 }
 return n;
}
const double PI = 3.1415926536;
template<class Iter_T>
void fft(Iter_r a, Iter_r b, int log2n) {
 typedef typename iterator_traits<Iter T>::value_type complex;
 const complex J(0, 1);
 int n = 1 << log2n;
 for (unsigned int i=0; i < n; ++i) {
  b[bitReverse(i, log2n)] = a[i];
 }
 for (int s = 1; s <= log2n; ++s) {
  int m = 1 << s;
  int m2 = m >> 1;
  complex w(1, 0);
  complex wm = exp(-J * (PI / m2));
  for (int j=0; j < m2; ++j) {
   for (int k=j; k < n; k += m) {
    complex t = w * b[k + m2];
    complex u = b[k];
    b[k] = u + t;
    b[k + m2] = u - t;
   }
   w *= wm;
  }
 }
}
int main() {
 typedef complex<double> cx;
 cx a[] = { cx(0, 0), cx(1, 1), cx(3, 3), cx(4, 4),
  cx(4, 4), cx(3, 3), cx(1, 1), cx(0, 0) };
 cx b[8];
 fft(a, b, 3);
 for (int i=0; i<8; ++i) cout << b[i] << "\n";
}
Программа примера 11.33 выдает следующий результат.
(16,16)
(-4.82843,-11.6569)
(0,0)
(-0.343146,0.828427)
(0.0)
(0.828427,-0.343146)
(0,0)
(-11.6569,-4.82843)
Обсуждение
Преобразование Фурье играет важную роль в спектральном анализе и часто используется в технических и научных приложениях. БПФ — это алгоритм вычисления ДПФ, который имеет сложность порядка N log2(N) в отличие от ожидаемой сложности N² для простой реализации ДПФ. Такое впечатляющее ускорение достигается в БПФ благодаря устранению избыточных вычислений.
Очень не просто найти хорошую реализацию БПФ, написанную на «правильном» C++ (т. е. когда программа на C++ не является механическим переложением алгоритмов, написанных на Фортране или С) и которая не была бы защищена сильно ограничивающей лицензией. Представленный в примере 11.33 программный код основан на открытом коде, который можно найти в сетевой конференции Usenet, посвященной цифровой обработке сигналов (comp.dsp). Большим преимуществом реализации БПФ на правильном C++ по сравнению с более распространенным решением в стиле С является то, что стандартная библиотека содержит шаблон complex, который позволяет существенно снизить объем необходимого программного кода. В представленной в примере 11.33 функции fft() основное внимание уделялось простоте, а не эффективности.
11.18. Работа с полярными координатами
Проблема
Требуется обеспечить представление полярных координат и манипулирование ими.
Решение
Шаблон complex из заголовочного файла <complex> содержит функции преобразования в полярные координаты и обратно. Пример 11.34 показывает, как можно использовать класс шаблона complex для представления и манипулирования полярными координатами.
Пример 11.34. Применение шаблонного класса complex для представления полярных координат
#include <complex>
#include <iostream>
using namespace std;
int main() {
 double rho = 3.0; // длина
 double theta = 3.141592 / 2; // угол
 complex<double> coord = polar(rho, theta);
 cout << "rho = " << abs(coord) << ", theta = " << arg(coord) << endl;
 coord += polar(4.0, 0.0);
 cout << "rho = " << abs(coord) << ", theta = " << arg(coord) << endl;
}
Программа примера 11.34 выдает следующий результат.
rho = 3, theta = 1.5708
rho = 5, theta = 0.643501
Обсуждение
Существует естественная связь между полярными координатами и комплексными числами. Хотя эти понятия в какой-то мере взаимозаменяемы, использование одного и того же типа для представления разных концепций в целом нельзя считать хорошей идеей. Поскольку применение шаблона complex для представления полярных координат не является элегантным решением, я предусмотрел приведенный в примере 11.25 класс полярных координат, допускающий более естественное применение.
Пример 11.35. Класс полярных координат
#include <complex>
#include <iostream>
using namespace std;
template<class T>
struct BasicPolar {
 public typedef BasicPolar self;
 // конструкторы
 BasicPolar() : m() {} BasicPolar(const self& x) : m(x.m) {}
 BasicPolar(const T& rho, const T& theta) : m(polar(rho, theta)) {}
 // операторы присваивания
 self operator-() { return Polar(-m); }
 self& operator+=(const self& x) { m += x.m; return *this; }
 self& operator-=(const self& x) { m -= x.m; return *this; }
 self& operator*=(const self& x) { m *= x.m; return *this; }
 self& operator/=(const self& x) { m /= x.m; return *this; }
 operator complex<T>() const { return m; }
 // открытые функции-члены
 T rho() const { return abs(m); }
 T theta() const { return arg(m); }
 // бинарные операции
 friend self operator+(self x, const self& y) { return x += y; }
 friend self operator-(self x, const self& y) { return x -= y; }
 friend self operator*(self x, const self& y) { return x *= y; }
 friend self operator/(self x, const self& y) { return x /= y; }
 // операторы сравнения
 friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
 friend bool operator!=(const self& x, const self& y) { return x.m ! = y.m; }
private:
 complex<T> m;
};
typedef BasicPolar<double> Polar;
int main() {
 double rho = 3.0; // длина
 double theta = 3.141592 / 2; // угол
 Polar coord(rho, theta);
 cout << "rho = " << coord.rho() << ", theta = " << coord.theta() << endl;
 coord += Polar(4.0, 0.0);
 cout << "rho = " << coord.rho() << ", theta = " << coord.theta() << endl;
 system("pause");
}
В примере 11.35 с помощью typedef я определил тип Polar как специализацию шаблона BasicPolar. Так удобно определять используемый по умолчанию тип, однако вы можете при необходимости специализировать шаблон BasicPolar другим числовым типом. Такой подход используется в стандартной библиотеке в отношении классе string, который является специализацией шаблона basic_string.
11.19. Выполнение операций с битовыми наборами
Проблема
Требуется реализовать основные арифметические операции и операции сравнения для набора бит, рассматривая его как двоичное представление целого числа без знака.
Решение
Программный код примера 11.36 содержит функции, которые позволяют выполнять арифметические операции и операции сравнения с шаблоном класса bitset из заголовочного файла <bitset>, рассматривая его как целый тип без знака.
Пример 11.36. bitset_arithmetic.hpp
#include <stdexcept>
#include <bitset>
bool fullAdder(bool b1, bool b2, bool& carry) {
 bool sum = (b1 ^ b2) ^ carry;
 carry = (b1 && b2) || (b1 && carry) || (b2 && carry);
 return sum;
}
bool fullSubtractor(bool b1, bool b2, bool& borrow) {
 bool diff;
 if (borrow) {
  diff = !(b1 ^ b2);
  borrow = !b1 || (b1 && b2);
 } else {
  diff = b1 ^ b2;
  borrow = !b1 && b2;
 }
 return diff;
}
template<unsigned int N>
bool bitsetLtEq(const std::bitset<N>& x, const std::bitset<N>& y) {
 for (int i=N-1; i >= 0; i--) {
  if (x[i] && !y[i]) return false;
  if (!x[i] && y[i]) return true;
 }
 return true;
}
template<unsigned int N>
bool bitsetLt(const std::bitset<N>& x, const std::bitset<N>& y) {
 for (int i=N-1; i >= 0, i--) {
  if (x[i] && !y[i]) return false;
  if (!x[i] && y[i]) return true;
 }
 return false;
}
template<unsigned int N>
bool bitsetGtEq(const std::bitset<N>& x, const std::bitset<N>& y) {
 for (int i=N-1; i >= 0; i--) {
  if (x[i] && !y[i]) return true;
  if (!x[i] && y[i]) return false;
 }
 return true;
}
template<unsigned int N>
bool bitsetGt(const std::bitset<N>& x, const std::bitset<N>& y) {
 for (int i=N-1; i >= 0; i--) {
  if (x[i] && !y[i]) return true;
  if (!x[i] && y[i]) return false;
 }
 return false;
}
template<unsigned int N>
void bitsetAdd(std::bitset<N>& x, const std::bitset<N>& y) {
 bool carry = false;
 for (int i = 0; i < N; i++) {
  x[i] = fullAdder(x[i], y[x], carry);
 }
}
template<unsigned int N>
void bitsetSubtract(std::bitset<N>& x, const std::bitset<N>& y) {
 bool borrow = false;
 for (int i = 0; i < N; i++) {
  if (borrow) {
   if (x[i]) {
    x[i] = y[i];
    borrow = y[i];
   } else {
    x[i] = !y[i];
    borrow = true;
   }
  } else {
   if (x[i]) {
    x[i] = !y[i];
    borrow = false;
   } else {
    x[i] = y[i];
    borrow = y[i];
   }
  }
 }
}
template<unsigned int N>
void bitsetMultiply(std::bitset<N>& x, const std::bitset<N>& y) {
 std::bitset<N> tmp = x;
 x.reset();
 // мы хотим минимизировать количество операций сдвига и сложения
 if (tmp.count() < y.count()) {
  for (int i=0; i < N; i++) if (tmp[i]) bitsetAdd(x, у << i);
 } else {
  for (int i=0; i < N; i++) if (y[i]) bitsetAdd(x, tmp << i);
 }
}
template<unsigned int N>
void bitsetDivide(std::bitset<N> x, std::bitset<N> y,
 std::bitset<N>& q, std::bitset<N>& r) {
 if (y.none()) {
  throw std::domain_error("division by zero undefined");
 }
 q.reset();
 r.reset();
 if (x.none()) {
  return;
 }
 if (x == y) {
  q[0] = 1;
  return;
 }
 r = x;
 if (bitsetLt(x, y)) {
  return;
 }
 // подсчитать количество значащих цифр в делителе и делимом
 unsigned int sig_x;
 for (int i=N-1; i>=0; i--) {
  sig_x = i;
  if (x[i]) break;
 }
 unsigned int sig_y;
 for (int i=N-1; i>=0; i--) {
  sig_y = i;
  if (y[i]) break;
 }
 // выровнять делитель по отношению к делимому
 unsigned int n = (sig_x — sig_y);
 y <<= n;
 // обеспечить правильное число шагов цикла
 n += 1;
 // удлиненный алгоритм деления со сдвигом и вычитанием
 while (n--) {
  // сдвинуть частное влево
  if (bitsetLtEq(y, r)) {
   // добавить новую цифру к частному
   q[n] = true;
   bitset.Subtract(r, y);
  }
  // сдвинуть делитель вправо
  y >>= 1;
 }
}
Пример 11.37 показывает, как можно использовать заголовочный файл bitset_arithmetic.hpp.
Пример 11.37. Применение функций bitset_arithmetic.hpp
#include "bitset_arithmetic.hpp"
#include <bitset>
#include <iostream>
#include <string>
using namespace std;
int main() {
 bitset<10> bits1(string("100010001"));
 bitset<10> bits2(string("000000011"));
 bitsetAdd(bits1, bits2);
 cout << bits1.to_string<char, char_traits<char>, allocator<char> >() << endl;
}
Программа примера 11.37 выдает следующий результат.
0100010100
Обсуждение
Шаблон класса bitset содержит основные операции по манипулированию битовыми наборами, но не обеспечивает арифметические операции и операции сравнения. Это объясняется тем, что в библиотеке нельзя заранее точно предвидеть, какой числовой тип будет использоваться для представления произвольного битового набора согласно ожиданиям программиста.
В функциях примера 11.36 считается, что bitset представляет собой целый тип без знака, и здесь обеспечиваются операции сложения, вычитания, умножения, деления и сравнения. Эти функции могут составить основу для представления специализированных целочисленных типов, и именно для этого они используются в рецепте 11.20.
В примере 11.36 я использовал не самые эффективные алгоритмы. Я применил самые простые алгоритмы, потому что их легче понять. В существенно более эффективной реализации использовались бы аналогичные алгоритмы, которые работали бы со словами, а не с отдельными битами.
Смотри также
Рецепт 11.20.
11.20. Представление больших чисел фиксированного размера
Проблема
Требуется выполнить операции с числами, размер которых превышает размер типа long int.
Решение
Шаблон BigInt в примере 11.38 использует bitset из заголовочного файла <bitset> для того, чтобы можно было представить целые числа без знака в виде набора бит фиксированного размера, причем количество бит определяется параметром шаблона.
Пример 11.38. big_int.hpp
#ifndef BIG_INT_HPP
#define BIG_INT_HPP
#include <bitset>
#include "bitset_arithmetic.hpp" // Рецепт 11.20
template<unsigned int N>
class BigInt {
 typedef BigInt self;
public:
 BigInt() : bits() {}
 BigInt(const self& x) : bits(x.bits) {}
 BigInt(unsigned long x) {
  int n = 0;
  while (x) {
   bits[n++] = x & 0x1;
   x >>= 1;
  }
 }
 explicit BigInt(const std::bitset<N>& x) bits(x) {}
 // открытые функции
 bool operator[](int n) const { return bits[n]; }
 unsigned long toUlong() const { return bits.to_ulong(); }
 // операторы
 self& operator<<=(unsigned int n) {
  bits <<= n;
  return *this;
 }
 self& operator>>=(unsigned int n) {
  bits >>= n;
  return *this;
 }
 self operator++(int) {
  self i = *this;
  operator++();
  return i;
 }
 self operator--(int) {
  self i = *this;
  operator--();
  return i;
 }
 self& operator++() {
  bool carry = false;
  bits[0] = fullAdder(bits[0], 1, carry);
  for (int i = 1; i < N; i++) {
   bits[i] = fullAdder(bits[i], 0, carry);
  }
  return *this;
 }
 self& operator--() {
  bool borrow = false;
  bits[0] = fullSubtractor(bits[0], 1, borrow);
  for (int i = 1; i < N; i++) {
   bits[i] = fullSubtractor(bits[i], 0, borrow);
  }
  return *this;
 }
 self& operator+=(const self& x) {
  bitsetAdd(bits, x.bits);
  return *this;
 }
 self& operator-=(const self& x) {
  bitsetSubtract(bits, x.bits);
  return *this;
 }
 self& operator*=(const self& x) {
  bitsetMultiply(bits, x.bits);
  return *this;
 }
 self& operator/=(const self& x) {
  std::bitset<N> tmp;
  bitsetDivide(bits, x.bits, bits, tmp);
  return *this;
 }
 self& operator%=(const self& x) {
  std::bitset<N> tmp;
  bitsetDivide(bits, x.bits, tmp, bits);
  return *this;
 }
 self operator~() const { return ~bits; }
 self& operator&=(self x) { bits x.bits; return *this; }
 self& operator|=(self x) { bits x.bits; return *this; }
 self& operator~=(self x) { bits ~= x.bits; return *this; }
 // дружественные функции
 friend self operator<<(self x, unsigned int n) { return x <<= n; }
 friend self operator>>(self x, unsigned int n) { return x >>= n; }
 friend self operator+(self x, const self& y) { return x += y; }
 friend self operator-(self x, const self& y) { return x -= y; }
 friend self operator*(self x, const self& y) { return x *= y; }
 friend self operator/(self x, const self& y) { return x /= y; }
 friend self operator%(self x, const self& y) { return x %= y; }
 friend self operator^(self x, const self& y) { return x ^= y; }
 friend self operator&(self x, const self& y) { return x &= y; }
 friend self operator|(self x, const self& y) { return x |= y; }
 // операторы сравнения
 friend bool operator==(const self& x, const self& y) {
  return x.bits == y.bits;
 }
 friend bool operator!=(const self& x, const self& y) {
  return x.bits ! = y.bits;
 }
 friend bool operator>(const self& x, const self& y) {
  return bitsetGt(x.bits, y.bits);
 }
 friend bool operator<(const self& x, const self& y) {
  return bitsetLt(x.bits, y.bits);
 }
 friend bool operator>=(const self& x, const self& y) {
  return bitsetGtEq(x.bits, y.bits);
 }
 friend bool operator<=(const self& x, const self& y) {
  return bitsetLtEq(x bits, y.bits);
 }
private:
 std::bitset<N> bits;
};
#endif
Шаблонный класс BigInt можно использовать для вычисления факториалов, как показано в примере 11.39.
Пример 11.39. Применение класса big_int
#include "big_int.hpp"
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
using namespace std;
void outputBigInt(BigInt<1024> x) {
 vector<int> v;
 if (x == 0) {
  cout << 0;
  return;
 }
 while (x > 0) {
  v.push_back((x % 10).to_ulong());
  x /= 10;
 }
 copy(v.rbegin(), v.rend(), ostream_iterator<int>(cout, ""));
 cout << endl;
}
int main() {
 BigInt<1024> n(1); // вычислить факториал числа 32
 for (int 1=1; i <= 32; ++i) {
  n *= i;
 }
 outputBigInt(n);
}
Программа примера 11.39 выдает следующий результат.
263130836933693530167218012160000000
Обсуждение
Большие целые числа часто встречаются во многих приложениях. Например, в криптографии нередки числа, которые представляются 1000 и более битами. Однако современный стандарт C++ позволяет работать как максимум с типом long int.
Число бит типа long int зависит от реализации, но оно не может быть меньше 32. И едва ли это число будет больше 1000. Следует помнить, что один из этих битов используется в качестве знака.
Ожидается, что новая версия стандарта (C++0x) последует за стандартом C99 и предусмотрит тип long long, размер которого будет, по крайней мере, не меньше размера long int, а возможно, и больше. Несмотря на это, всегда будут случаи, когда требуется наличие целочисленного типа, размер которого превышает размер самого большого встроенного типа.
Представленная здесь реализация основана на двоичном представлении чисел при помощи класса bitset, причем это делается за счет некоторого снижения производительности. Однако я потерял в производительности значительно меньше, чем выиграл в простоте. Более эффективная реализация чисел произвольной точности настолько обширна, что могла бы легко заполнить всю книгу.
Смотри также
Рецепт 11.19.
11.21. Реализация чисел с фиксированной точкой
Проблема
Требуется обеспечить выполнение вычислений с вещественными числами, используя тип с фиксированной, а не с плавающей точкой.
Решение
В примере 11.40 представлена реализация вещественного числа с фиксированной точкой, когда количество двоичных позиций справа от точки задается параметром шаблона. Например, тип basic_fixed_real<10> имеет 10 двоичных цифр справа от двоичной точки, что позволяет представлять числа с точностью до 1/1024.
Пример 11.40. Представление вещественных чисел, используя формат с фиксированной точкой
#include <iostream>
using namespace std;
template<int E>
struct BasicFixedReal {
 typedef BasicFixedReal self;
 static const int factor = 1 << (E - 1);
 BasicFixedReal() : m(0) {}
 BasicFixedReal(double d) : m(static_cast<int>(d * factor)) {}
 self& operator+=(const self& x) { m += x.m; return *this; }
 self& operator-=(const self& x) { m -= x.m; return *this; }
 self& operator*=(const self& x) { m *= x.m; m >>=E; return *this; }
 self& operator/=(const self& x) { m /= x.m; m *= factor; return *this; }
 self& operator*=(int x) { m *= x; return *this; }
 self& operator/=(int x) { m /= x; return *this; }
 self operator-() { return self(-m); }
 double toDouble() const { return double(m) / factor; }
 // дружественные функции
 friend self operator+(self x, const self& v) { return x += y; }
 friend self operator-(self x, const self& y) { return x -= y; }
 friend self operator-(self x, const self& y) { return x *= y; }
 friend self operator/(self x, const self& y) { return x /= y; }
 // операторы сравнения
 friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
 friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
 friend bool operator>(const self& x, const self& y) { return x.m > y.m; }
 friend bool operator<(const self& x, const self& y) { return x.m < y.m; }
 friend bool operator>=(const self& x, const self& y) { return x.m >= y.m; }
 friend bool operator<=(const self& x, const self& y) { return x.m <= y.m; }
private:
 int m;
};
typedef BasicFixedReal<10> FixedReal;
int main() {
 FixedReal x(0);
 for (int i=0; i < 100; ++i) {
  x += FixedReal(0.0625);
 }
 cout << x.toDouble() << endl;
}
Программа примера 11.40 выдает следующий результат.
6.25
Обсуждение
Число с фиксированной точкой, как и число с плавающей точкой, является приблизительным представлением вещественного числа. Число с плавающей точкой имеет мантиссу (m) и экспоненту (е), обеспечивая значение, вычисляемое по формуле m*bе, где b — некоторая константа.
Число с фиксированной точкой имеет почти такой же формат, но здесь экспонента также фиксирована. Эта константа в примере 11.40 передается шаблону basic_fixed_real в качестве его параметра.
Представление экспоненты е в виде константы позволяет реализовать числа с фиксированной точкой с помощью целых типов и выполнять арифметические операции с ними, используя целочисленную арифметику. Во многих случаях это может повысить скорость выполнения основных арифметических операций, особенно сложения и вычитания.
Представление с фиксированной точкой менее гибко, чем представление чисел с плавающей точкой, так как оно обеспечивает только узкий диапазон значений. Приведенный в примере 11.40 тип fixed_real позволяет представлять значения только в диапазоне от -2 097 151 до +2 097 151 с точностью 1/1024.
Сложение и вычитание чисел с фиксированной точкой реализуется достаточно естественно: я просто складываю или вычитаю их целочисленные представления. Для выполнения деления и умножения требуется дополнительная операция сдвига мантиссы влево или вправо, чтобы двоичная точка заняла правильную позицию.
Глава 12
Многопоточная обработка
12.0. Введение
В данной главе даются рецепты написания многопоточных программ на C++ с использованием библиотеки Boost Threads, автором которой является Вильям Кемпф (William Kempf). Boost — это набор переносимых, высокопроизводительных библиотек с открытым исходным кодом, неоднократно проверенным программистами, и с широким спектром сложности: от простых структур данных до сложного фреймворка синтаксического анализа. Библиотека Boost Threads обеспечивает фреймворк для многопоточной обработки. Дополнительную информацию по проекту Boost можно найти на сайте www.boost.org.
Стандартом C++ не предусматривается встроенная поддержка многопоточной обработки, поэтому нельзя написать переносимый программный код с многопоточной обработкой, подобно тому как создается переносимый код, использующий такие классы стандартной библиотеки, как string, vector, list и т.д. Однако в библиотеке Boost Threads пройден значительный путь к созданию стандартной, переносимой библиотеки многопоточной обработки, и использование этой библиотеки позволяет свести к минимуму головную боль, вызываемую многими обычными проблемами, связанными с многопоточной обработкой.
Все же в отличие от стандартной библиотеки и библиотек независимых разработчиков применение библиотеки многопоточной обработки нельзя свести к распаковке ее архива, включению операторов #include и написанию программного кода, не требующего особых усилий. Во всех приложениях многопоточной обработки (кроме самых простых) необходимо тщательно подойти к разработке проекта, используя проверенные шаблоны и известные тактические приемы, позволяющие избегать ошибок, неизбежно возникающих в противном случае. В типичном однопоточном приложении обычные ошибки программирования находятся легко: циклы с пропуском одного шага, разыменование нулевого или удаленного указателя, потеря точности при преобразованиях чисел с плавающей точкой и т.д. В программах с многопоточной обработкой ситуация другая. Мало того, что задача отслеживания с помощью отладчика действий нескольких потоков становится очень трудоемкой, многопоточные программы работают недетерминировано, т.е. ошибки могут проявляться только в редких или сложных ситуациях.
Именно по этой причине нельзя рассматривать данную главу как введение в многопоточное программирование. Если вы уже имели опыт многопоточного программирования, но не на C++ или без использования библиотеки Boost Threads, эта глава будет полезна для вас. Однако описание основных принципов многопоточного программирования выходит за рамки этой книги. Если до сих пор вы никогда не занимались многопоточным программированием, по-видимому, вам следует прочитать вводный материал по этой тематике, но такой материал трудно найти, потому что большинство программистов не используют потоки выполнения (хотя, возможно, их и следовало бы применить).
Большая часть документации Boost и некоторые приводимые ниже рецепты при обсуждении классов используют понятия концепции и модели. Концепция — это абстрактное описание чего-то, обычно класса и его поведения, причем не делается никаких предположений относительно реализации. Как правило, сюда входит описание действий при конструировании и уничтожении, а также описание каждого метода с указанием предусловий, параметров и постусловий. Например, концепция мьютекса (Mutex) описывается как нечто допускающее блокирование и разблокирование только одним потоком в данный момент времени. Модель — это конкретная реализация концепции, например класс mutex в библиотеке Boost Threads. Уточнение (refinement) концепции — это некая ее специализация, например ReadWriteMutex, т.е. мьютекс с некоторыми дополнительными возможностями.
Наконец, потоки делают что-то одно из трех: работают, находятся в ожидании чего-то или готовы начать работу, но ничего не ожидают и не выполняют никаких действий. Эти состояния носят названия состояний выполнения (run), ожидания (wait) и готовности (ready). Эти термины я использую в последующих рецептах.
12.1. Создание потока
Проблема
Требуется создать поток (thread) для выполнения некоторой задачи, в то время как главный поток продолжает свою работу.
Решение
Создайте объект класса thread и передайте ему функтор, который выполняет данную работу. Создание объекта потока приведет к инстанцированию потока операционной системы, который начинает выполнять оператор operator() с вашим функтором (или начинает выполнять функцию, переданную с помощью указателя). Пример 12.1 показывает, как это делается.
Пример 12.1. Создание потока
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/thread/xtime.hpp>
struct MyThreadFunc {
 void operator()() {
  // Что-нибудь работающее долго...
 }
} threadFun;
int main() {
 boost::thread myThread(threadFun); // Создать поток, запускающий
                                    // функцию threadFun
 boost.:thread::yield(); // Уступить порожденному потоку квант времени.
                         // чтобы он мог выполнить какую-то работу.
// Выполнить какую-нибудь другую работу
myThread join(); // Текущий поток (т.е поток функции main) прежде.
                 // чем завершиться, будет ждать окончания myThread
}
Обсуждение
Создается поток обманчиво просто. Вам необходимо лишь создать объект thread в стеке или в динамической памяти и передать ему функтор, который укажет, с чего начать работу. В данном случае термин «поток» (thread) используется в двух смыслах. Во-первых, это объект класса thread, который является обычным объектом C++. При ссылке на этот объект я буду говорить «объект потока». Кроме того, существует поток выполнения, который является потоком операционной системы, представленным объектом thread. Когда я говорю «поток» (в отличие от названия класса потока, напечатанного моноширинным шрифтом), я имею в виду поток операционной системы.
Теперь перейдем непосредственно к рассмотрению программного кода в примере. Конструктор thread принимает функтор (или указатель функции), имеющий два аргумента и возвращающий void. Рассмотрим следующую строку из примера 12.1.
boost::thread myThread(threadFun);
Она создает в стеке объект myThread, являющийся новым потоком операционной системы, который начинает выполнять функцию threadFun. В этот момент программный код функции threadFun и код функции main (по крайней мере, теоретически) выполняются параллельно. Конечно, на самом деле они могут выполняться не параллельно, поскольку ваша машина может иметь только один процессор, и в этом случае параллельная работа невозможна (благодаря недавно разработанным архитектурам процессоров это утверждение не совсем точное, но в настоящий момент я не буду принимать в расчет двухъядерные процессоры и т.п.). Если у вас только один процессор, то операционная система предоставит каждому созданному вами потоку квант времени в состоянии выполнения, перед тем как приостановить его работу. Так как эти кванты времени могут иметь различную величину, никогда нельзя с уверенностью сказать, какой из потоков раньше достигнет определенной точки. Именно в этой особенности многопоточного программирования заключается его сложность: состояние многопоточной программы недетерминировано. При выполнении несколько раз одной и той же многопоточной программы можно получить различные результаты. Темой рецепта 12.2 является координация ресурсов, используемых несколькими потоками.
После создания потока myThread поток main продолжает свою работу, по крайней мере на мгновение, пока не достигнет следующей строки.
boost::thread::yield();
Это переводит текущий поток (в данном случае поток main) в неактивное состояние, что означает переключение операционной системы на другой поток или процесс, используя некоторую политику, которая зависит от операционной системы. С помощью функции yield операционная система уведомляется о том, что текущий поток хочет уступить оставшуюся часть кванта времени. В это время новый поток выполняет threadFun. После завершения threadFun дочерний поток исчезает. Следует отметить, что объект thread не уничтожается, потому что он является объектом С++, который по-прежнему находится в области видимости. Эта особенность играет важную роль.
Объект потока — это некий объект, существующий в динамической памяти или в стеке и работающий подобно любому другому объекту С++. Когда программный код выходит из области видимости потока, все находящиеся в стеке объекты потока уничтожаются, или, с другой стороны, когда вызывающая программа выполняет оператор delete для thread*, исчезает соответствующий объект thread, который находится в динамической памяти. Но объекты thread выступают просто как прокси относительно реальных потоков операционной системы, и когда они уничтожаются, потоки операционной системы не обязательно исчезают. Они просто отсоединяются, что означает невозможность их подключения в будущем. Это не так уж плохо.
Потоки используют ресурсы, и в любом (хорошо спроектированном) многопоточном приложении управление доступом к таким ресурсам (к объектам, сокетам, файлам, «сырой» памяти и т.д.) осуществляется при помощи мьютексов, которые являются объектами, обеспечивающими последовательный доступ к каким-либо объектам со стороны нескольких потоков (см. рецепт 12.2). Если поток операционной системы оказывается «убитым», он не будет освобождать свои блокировки и свои ресурсы, подобно тому как «убитый» процесс не оставляет шансов на очистку буферов или правильное освобождение ресурсов операционной системы. Простое завершение потока в тот момент, когда вам кажется, что он должен быть завершен, — это все равно что убрать лестницу из-под маляра, когда время его работы закончилось.
Поэтому предусмотрена функция-член join. Как показано в примере 12.1, вы можете вызвать join, чтобы дождаться завершения работы дочернего потока, join — это вежливый способ уведомления потока, что вы собираетесь ждать завершения его работы.
myThread.join();
Поток, вызвавший функцию join, переходит в состояние ожидания, пока не закончит свою работу другой поток, представленный объектом myThread. Если он никогда не завершится, то никогда не завершится и join. Применение join — наилучший способ ожидания завершения работы дочернего потока.
Возможно, вы заметили, что, если передать что-либо осмысленное функции threadFun, но закомментировать join, поток не завершит свою работу. Вы можете убедиться в этом, выполняя в threadFun цикл или какую-нибудь продолжительную операцию. Это объясняется тем, что операционная система уничтожает процесс вместе со всеми его дочерними процессами независимо от того, закончили или нет они свою работу. Без вызова join функция main не будет ждать окончания работы своих дочерних потоков: она завершается, и поток операционной системы уничтожается.
Если требуется создать несколько потоков, рассмотрите возможность их группирования в объект thread_group. Объект thread_group может управлять объектами двумя способами. Во-первых, вы можете вызвать add_thread с указателем на объект thread, и этот объект будет добавлен в группу. Ниже приводится пример.
boost::thread_group grp;
boost::thread* p = new boost::thread(threadFun);
grp.add_thread(p);
// выполнить какие-нибудь действия...
grp.remove_thread(p);
При вызове деструктора grp он удалит оператором delete каждый указатель потока, который был добавлен в add_thread. По этой причине вы можете добавлять в thread_group только указатели объектов потоков, размещённых в динамической памяти. Удаляйте поток путем вызова remove_thread с передачей адреса объекта потока (remove_thread находит в группе соответствующий объект потока, сравнивая значения указателей, а не сами объекты). remove_thread удалит указатель, ссылающийся на этот поток группы, но вам придется все же удалить сам поток с помощью оператора delete.
Кроме того, вы можете добавить поток в группу, не создавая его непосредственно, а используя для этого вызов функции create_thread, которая (подобно объекту потока) принимает функтор в качестве аргумента и начинает его выполнение в новом потоке операционной системы. Например, для порождения двух потоков и добавления их в группу сделайте следующее.
boost::thread_group grp;
grp.create_thread(threadFun);
grp.create_thread(threadFun); // Теперь группа grp содержит два потока
grp.join_all(); // Подождать завершения всех потоков
При добавлении потоков в группу при помощи create_thread или add_thread вы можете вызвать join_all для ожидания завершения работы всех потоков группы. Вызов join_all равносилен вызову join для каждого потока группы: join_all возвращает управление после завершения работы всех потоков группы.
Создание объекта потока позволяет начать выполнение отдельного потока. Однако с помощью средств библиотеки Boost Threads это делается обманчиво легко, поэтому необходимо тщательно обдумывать проект. Прочтите остальные рецепты настоящей главы, где даются дополнительные предостережения относительно применения потоков.
Смотри также
Рецепт 12.2.
12.2. Обеспечение потокозащищенности ресурсов
Проблема
В программе используется несколько потоков и требуется гарантировать невозможность модификации ресурса несколькими потоками одновременно. В целом это называется обеспечением потокозащищенности (thread-safe) ресурсов или сериализацией доступа к ним.
Решение
Используйте класс mutex, определенный в boost/thread/mutex.hpp, для синхронизации доступа к потокам. Пример 12.2 показывает, как можно использовать в простых случаях объект mutex для управления параллельным доступом к очереди.
Пример 12.2. Создание потокозащищенного класса
#include <iostream>
#include <boost/thread/thread.hpp>
#include <string>
// Простой класс очереди; в реальной программе вместо него следует
// использовать std::queue
template<typename T>
class Queue {
public:
 Queue() {}
 ~Queue() {}
 void enqueue(const T& x) {
  // Блокировать мьютекс для этой очереди
  boost::mutex::scoped_lock lock(mutex_);
  list_.push_back(x);
  // scoped_lock автоматически уничтожается (и, следовательно, мьютекс
  // разблокируется) при выходе из области видимости
 }
 T dequeue() {
  boost::mutex::scoped_lock lock(mutex_);
  if (list_.empty())
    throw "empty!";      // Это приводит к выходу из текущей области
  T tmp = list_.front(); // видимости, поэтому блокировка освобождается
  list_.pop_front();
  return(tmp);
 } // Снова при выходе из области видимости мьютекс разблокируется
private:
 std::list<T> list_;
 boost::mutex mutex_;
};
Queue<std::string> queueOfStrings;
void sendSomething() {
 std::string s;
 for (int i = 0; i < 10; ++i) {
  queueOfStrings.enqueue("Cyrus");
 }
}
void recvSomething() {
 std::string s;
 for(int i = 0; i < 10; ++i) {
  try {
   s = queueOfStrings.dequeue();
  } catch(...) {}
 }
}
int main() {
 boost::thread thr1(sendSomething);
 boost::thread thr2(recvSomething);
 thr1.join();
 thr2.join();
}
Обсуждение
Обеспечение потокозащищенности классов, функций, блоков программного кода и других объектов является сущностью многопоточного программирования. Если вы проектируете какой-нибудь компонент программного обеспечения с возможностями многопоточной обработки, то можете постараться обеспечить каждый поток своим набором ресурсов, например объектами в стеке и динамической памяти, ресурсами операционной системы и т.д. Однако рано или поздно вам придется обеспечить совместное использование различными потоками каких-либо ресурсов. Это может быть совместная очередь поступающих запросов (как это происходит на многопоточном веб-сервере) или нечто достаточно простое, как поток вывода (например, в файл журнала или даже в cout). Стандартный способ координации безопасного совместного использования ресурсов подразумевает применение мьютекса (mutex), который обеспечивает монопольный доступ к чему-либо.
Остальная часть обсуждения в целом посвящена мьютексам, и в частности методам использования boost::mutex для сериализации доступа к ресурсам. Я использую терминологию подхода «концепция/модель», о котором я говорил кратко во введении настоящей главы. Концепция — это абстрактное (независимое от языка) описание чего-либо, а модель концепции — конкретное ее представление в форме класса С++. Уточнение концепции — это определенная концепция с некоторыми дополнительными возможностями.
Все-таки параллельное программирование представляет собой сложную тему, и в одном рецепте нельзя отразить все применяемые в этой технологии методы. Можно использовать много шаблонов проектирования и разных стратегий, подходящих для различных приложений. Если при проектировании программного обеспечения вы предполагаете, что многопоточная обработка составит значительный объем, или проектируете высокопроизводительные приложения, необходимо прочитать хорошую книгу по шаблонам многопоточной обработки. Многие проблемы, связанные с трудностями отладки многопоточных программ, могут быть успешно преодолены за счет тщательного и продолжительного проектирования.
Использование мьютексов
Концепция мьютекса проста: мьютекс это некий объект, представляющий ресурс; только один поток может его блокировать или разблокировать в данный момент времени. Он является флагом, который используется для координации доступа к ресурсу со стороны нескольких пользователей. В библиотеке Boost Threads моделью концепции мьютекса является класс boost::mutex. В примере 1 2.2 доступ для записи в классе Queue обеспечивается переменной-членом mutex.
boost::mutex mutex_;
mutex_ должен блокироваться какой-нибудь функцией-членом, которая должна изменять состояние очереди обслуживаемых элементов. Сам объект mutex_ ничего не знает о том, что он представляет. Это просто флаг блокировки/разблокировки, используемый всеми пользователями некоторого ресурса.
В примере 12.2, когда какая-нибудь функция-член класса Queue собирается изменить состояние объекта, она сначала должна заблокировать mutex_. Только один поток в конкретный момент времени может его заблокировать, что не позволяет нескольким объектам одновременно модифицировать состояние объекта Queue. Таким образом, мьютекс mutex представляет собой простой сигнальный механизм, но это нечто большее, чем просто bool или int, потому что для mutex необходим сериализованный доступ, который может быть обеспечен только ядром операционной системы. Если вы попытаетесь сделать то же самое с bool, это не сработает, потому что ничто не препятствует одновременной модификации состояния bool несколькими потоками. (В разных операционных системах это осуществляется по-разному, и именно поэтому не просто реализовать переносимую библиотеку потоков.)
Объекты mutex блокируются и разблокируются, используя несколько различных стратегий блокировки, самой простой из которых является блокировка scoped_lock. scoped_lock — это класс, при конструировании объекта которого используется аргумент типа mutex, блокируемый до тех пор, пока не будет уничтожена блокировка lock. Рассмотрим функцию-член enqueue в примере 12.2, которая показывает, как scoped_lock работает совместно с мьютексом mutex_.
void enqueue(const T& x) {
 boost::mutex::scoped_lock lock(mutex_);
 list_.push_back(x);
} // разблокировано!
Когда lock уничтожается, mutex_ разблокируется. Если lock конструируется для объекта mutex, который уже заблокирован другим потоком, текущий поток переходит в состояние ожидания до тех пор, пока lock не окажется доступен.
Такой подход поначалу может показаться немного странным: а почему бы мьютексу mutex не иметь методы lock и unlock? Применение класса scoped_lock, который обеспечивает блокировку при конструировании и разблокировку при уничтожении, на самом деле более удобно и менее подвержено ошибкам. Когда вы создаете блокировку, используя scoped_lock, мьютекс блокируется на весь период существования объекта scoped_lock, т.е. вам не надо ничего разблокировать в явной форме на каждой ветви вычислений. С другой стороны, если вам приходится явно разблокировать захваченный мьютекс, необходимо гарантировать перехват любых исключений, которые могут быть выброшены в вашей функции (или где-нибудь выше ее в стеке вызовов), и гарантировать разблокировку mutex. При использовании scoped_lock, если выбрасывается исключение или функция возвращает управление, объект scoped_lock автоматически уничтожается и mutex разблокируется.
Использование мьютекса позволяет сделать всю работу, однако хочется немного большего. При таком подходе нет различия между чтением и записью, что существенно, так как неэффективно заставлять потоки ждать в очереди доступа к ресурсу, когда многие из них выполняют только операции чтения, для которых не требуется монопольный доступ. Для этого в библиотеке Boost Threads предусмотрен класс read_write_mutex. Пример 12.3 показывает, как можно реализовать пример 12.2, используя read_write_mutex с функцией-членом front, которая позволяет вызывающей программе получить копию первого элемента очереди без его выталкивания.
Пример 12.3. Использование мьютекса чтения/записи
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/thread/read_write_mutex.hpp>
#include <string>
template<typename T>
class Queue {
 public:
 Queue() : // Использовать мьютекс чтения/записи и придать ему приоритет
           // записи
 rwMutex_(boost::read_write_scheduling_policy::writer_priority) {}
 ~Queue() {}
 void enqueue(const T& x) {
  // Использовать блокировку чтения/записи, поскольку enqueue
  // обновляет состояние
  boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
  list_.push_back(x);
 }
 T dequeue() {
  // Снова использовать блокировку для записи
  boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
  if (list_.empty())
   throw "empty!";
  T tmp = list_.front();
  list_.pop_front();
  return(tmp);
 }
 T getFront() {
  // Это операция чтения, поэтому требуется блокировка только для чтения
  boost::read_write_mutex::scoped_read_lock.readLock(rwMutex_);
  if (list_.empty())
   throw "empty!";
  return(list_.front());
 }
private:
 std::list<T> list_;
 boost::read_write_mutex rwMutex_;
};
Queue<std::string> queueOfStrings;
void sendSomething() {
 std::string s;
 for (int i = 0, i < 10; ++i) {
  queueOfStrings.enqueue("Cyrus");
 }
}
void checkTheFront() {
 std::string s;
 for (int i=0; i < 10; ++i) {
  try {
   s = queueOfStrings.getFront();
  } catch(...) {}
 }
}
int main() {
 boost::thread thr1(sendSomething);
 boost::thread_group grp;
 grp.сreate_thread(checkTheFront);
 grp.create_thread(checkTheFront);
 grp.сreate_thread(checkTheFront);
 grp_create_thread(checkTheFront);
 thr1.join();
 grp.join_all();
}
Здесь необходимо отметить несколько моментов. Обратите внимание, что теперь я использую read_write_mutex.
boost::read_write_mutex rwMutex_;
При использовании мьютексов чтения/записи блокировки тоже выполняются иначе. В примере 12.3, когда мне нужно заблокировать Queue для записи, я создаю объект класса scoped_write_lock.
boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
А когда мне просто требуется прочитать Queue, я использую scoped_read_lock.
boost::read_write_mutex::scoped_read_lock readLock(rwMutex_);
Блокировки чтения/записи удобны, но они не предохраняют вас от серьезных ошибок. На этапе компиляции не делается проверка ресурса, представленного мьютексом rwMutex_, гарантирующая отсутствие изменения ресурса при блокировке только для чтения. Вы сами должны позаботиться о том, чтобы поток мог модифицировать состояние объекта только при блокировке для записи, поскольку компилятор это не будет делать.
Точная последовательность выполнения блокировок определяется политикой их планирования; эту политику вы задаете при конструировании объекта mutex. В библиотеке Boost Threads предусматривается четыре политики.
reader_priority
Потоки, ожидающие выполнения блокировки для чтения, ее получат раньше потоков, ожидающих выполнения блокировки для записи.
writer_priority
Потоки, ожидающие выполнения блокировки для записи, ее получат раньше потоков, ожидающих выполнения блокировки для чтения.
alternating_single_read
Чередуются блокировки для чтения и для записи. Один читающий поток получает возможность блокировки для чтения, когда подходит «очередь» читающих потоков. Эта политика в целом отдает приоритет записывающим потокам. Например, если мьютекс заблокирован для записи и имеется несколько потоков, ожидающих блокировки для чтения, а также один поток, ожидающий блокировки для записи, сначала будет выполнена одна блокировка для чтения, затем блокировка для записи и после нее — все остальные блокировки для чтения. Подразумевается, что за это время не будет новых запросов на блокировку.
alternating_many_reads
Чередуются блокировки для чтения и для записи. Выполняются все блокировки для чтения, когда подходит «очередь» читающих потоков. Другими словами, эта политика приводит к опустошению очереди всех потоков, ожидающих блокировки для чтения, в промежутке между блокировками для записи.
Каждая из этих политик имеет свои достоинства и недостатки, и их влияние будет сказываться по-разному в различных приложениях. Необходимо тщательно подойти к выбору политики, потому что если просто обеспечить приоритет для чтения или записи, это приведет к зависанию, которое я более подробно описываю ниже.
Опасности
При программировании многопоточной обработки возникает три основные проблемы: взаимная блокировка (deadlock), зависание (starvation) и состояния состязания (race conditions — условия гонок). Существуют различные по сложности методы устранения этих проблем, но их рассмотрение выходит за рамки данного рецепта. Я дам описание каждой их этих проблем, чтобы вы знали, чего следует остерегаться, но если вы планируете разработку многопоточного приложения, вам необходимо сначала выполнить некоторое предварительную работу по шаблонам многопоточной обработки.
Взаимная блокировка связана с наличием, по крайней мере, двух потоков и двух ресурсов. Пусть имеется два потока, А и В, и два ресурса, X и Y, причем поток А блокирует ресурс X, а В блокирует Y. Взаимная блокировка возникает в том случае, когда А пытается заблокировать Y, а В пытается заблокировать X. Если при работе потоков не предусмотреть какой-либо способ устранения взаимных блокировок, они будут ждать бесконечно.
Библиотека Boost Threads позволяет избегать взаимных блокировок благодаря уточнению концепций мьютекса и блокировки. Пробный мьютекс (try mutex) — это мьютекс, который используется для определения возможности блокировки путем выполнения пробной блокировки (try lock); она может быть успешной или нет, но не блокирует ресурс, а ждет момента, когда блокировка станет возможной. Применяя модели этих концепций в форме классов try_mutex и scoped_try_lock, вы можете в своей программе идти дальше и выполнять какие-то другие действия, если доступ к требуемому ресурсу заблокирован. Существует еще одно уточнение концепции пробной блокировки, называемое временной блокировкой (timed lock). Я не рассматриваю здесь подробно временные блокировки; детальное их описание вы найдете в документации библиотеки Boost Threads.
Например, в классе Queue из примера 12.2 требуется использовать мьютекс для пробной блокировки с возвратом функцией dequeue значения типа bool, показывающего, может или не может быть извлечен из очереди первый элемент. В этом случае при применении функции dequeue не приходится ждать блокировки очереди. Ниже показано, как можно переписать функцию dequeue.
bool dequeue(T& x) {
 boost::try_mutex::scoped_try_lock lock(tryMutex_);
 if (!lock.locked())
  return(false);
 else {
  if (list_.empty()) throw "empty!";
  x = list_.front();
  list_.pop_front();
  return(true);
 }
}
private:
 boost::try_mutex tryMutex_;
 // ...
Используемые здесь мьютекс и блокировка отличаются от тех, которые применялись в примере 12.2. Убедитесь, что используемые вами имена классов мьютекса и блокировки правильно квалифицированы, в противном случае вы получите не то, на что рассчитываете.
При сериализации доступа к чему-либо вы заставляете пользователей этого ресурса выстраиваться друг за другом и дожидаться свой очереди. Если положение пользователей ресурса в очереди остается неизменным, каждый из них имеет шанс получения доступа к ресурсу. Однако если некоторым пользователям разрешается сокращать свою очередь, то до находящихся в конце очередь может никогда не дойти. Возникает зависание.
При использовании мьютекса mutex пользователи ресурса, которые находятся в состоянии ожидания, образуют группу, а не последовательность. Нельзя сказать, что существует определенный порядок между потоками, ожидающими возможности выполнения блокировки. Для мьютексов чтения/записи в библиотеке Boost Threads используется четыре политики планирования блокировок, которые были описаны ранее. Поэтому при использовании мьютексов чтения/записи необходимо понимать смысл различных политик планирования и действий ваших потоков. Если вы используете политику writer_priority и у вас много потоков, создающих блокировки для записи, ваши читающие потоки будут зависать; то же самое произойдет при применении политики reader_priority, поскольку эти политики планирования всегда отдают предпочтение одному из двух типов блокировки. Если в ходе тестирования вы понимаете, что один из типов потоков продвигается в очереди недостаточно, рассмотрите возможность перехода на применение политики alternating_many_reads или alternating_single_read. Тип политики задается при конструировании мьютекса чтения/записи.
Наконец, состояние состязания возникает в том случае, когда в программе делается предположение об определенном порядке выполнения блокировок или об их атомарности, что оказывается неверным. Например, рассмотрим пользователя класса Queue, который опрашивает первый элемент очереди и при определенном условии извлекает его из очереди с помощью функции dequeue.
if (q.getFront() == "Cyrus") {
 str = q.dequeue();
 // ...
Этот фрагмент программного кода хорошо работает в однопоточной среде, потому что q не может быть модифицирован в промежутке между первой и второй строкой. Однако в условиях многопоточной обработки, когда практически в любой момент другой поток может модифицировать q, следует исходить из предположения, что совместно используемые объекты модифицируются, когда поток не блокирует доступ к ним. После строки 1 другой поток, работая параллельно, может извлечь следующий элемент из q при помощи функции dequeue, что означает получение в строке 2 чего-то неожиданного или совсем ничего. Как функция getFront, так и функция dequeue блокирует один объект mutex, используемый для модификации q, но между их вызовами мьютекс разблокирован, и, если другой поток находится в ожидании выполнения блокировки, он может это сделать до того, как получит свой шанс строка 2.
Проблема состояния состязания в этом конкретном случае решается путем гарантирования сохранения блокировки на весь период выполнения операции. Создайте функцию-член dequeueIfEquals, которая извлекает следующий объект из очереди, если он равен аргументу. Функция dequeueIfEquals может использовать блокировку, как и всякая другая функция.
T dequeueIfEquals(const T& t) {
 boost::mutex::scoped_lock lock(mutex_);
 if (list_.front() == t)
 // ...
Существуют состояния состязания другого типа, но этот пример должен дать общее представление о том, чего следует остерегаться. По мере увеличения количества потоков и совместно используемых ресурсов состояния состязания оказываются более изощренными и обнаруживать их сложнее. Поэтому следует быть особенно осторожным на этапе проектирования, чтобы не допускать их.
В многопоточной обработке самое сложное — гарантировать сериализованный доступ к ресурсам, потому что если это сделано неправильно, отладка становится кошмаром. Поскольку многопоточная программа по своей сути недетерминирована (так как потоки могут выполняться в различной очередности и с различными квантами времени при каждом новом выполнении программы), очень трудно точно обнаружить место и способ ошибочной модификации чего-либо. Здесь еще в большей степени, чем в однопоточном программировании, надежный проект позволяет минимизировать затраты на отладку и переработку.
12.3. Уведомление одного потока другим
Проблема
Используется шаблон, в котором один поток (или группа потоков) выполняет какие-то действия, и требуется сделать так, чтобы об этом узнал другой поток (или группа потоков). Может использоваться главный поток, который передает работу подчиненным потокам, или может использоваться одна группа потоков для пополнения очереди и другая для удаления данных из очереди и выполнения чего-либо полезного.
Решение
Используйте объекты mutex и condition, которые объявлены в boost/thread/mutex.hpp и boost/thread/condition.hpp. Можно создать условие (condition) для каждой ожидаемой потоками ситуации и при возникновении такой ситуации уведомлять все ее ожидающие потоки. Пример 12.4 показывает, как можно обеспечить передачу уведомлений в модели потоков «главный/подчиненные».
Пример 12.4. Передача уведомлений между потоками
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/thread/condition.hpp>
#include <boost/thread/mutex.hpp>
#include <list>
#include <string>
class Request { /*...*/ };
// Простой класс очереди заданий; в реальной программе вместо этого класса
// используйте std::queue
template<typename T>
class JobQueue {
public:
 JobQueue() {}
 ~JobQueue() {}
 void submitJob(const T& x) {
  boost::mutex::scoped_lock lock(mutex_);
  list_.push_back(x);
  workToBeDone_.notify_one();
 }
 T getJob() {
  boost::mutex::scoped_lock lock(mutex_);
  workToBeDone_.wait(lock); // Ждать удовлетворения этого условия, затем
                            // блокировать мьютекс
  T tmp = list_.front();
  list_.pop_front();
  return(tmp);
 }
private:
 std::list<T> list_;
 boost::mutex mutex_;
 boost::condition workToBeDone_;
};
JobQueue<Request> myJobQueue;
void boss() {
 for (;;) {
  // Получить откуда-то запрос
  Request req;
  myJobQueue.submitJob(req);
 }
}
void worker() {
 for (;;) {
  Request r(myJobQueue.getJob());
  // Выполнить какие-то действия с заданием...
 }
}
int main() {
 boost::thread thr1(boss);
 boost::thread thr2(worker);
 boost::thread thr3(worker);
 thr1.join();
 thr2.join();
 thr3.join();
}
Обсуждение
Объект условия использует мьютекс mutex и позволяет дождаться ситуации, когда он становится заблокированным. Рассмотрим пример 12.4, в котором представлена модифицированная версии класса Queue из примера 12.2. Я модифицировал очередь Queue, получая более специализированную очередь, а именно JobQueue, объекты которой являются заданиями, поступающими в очередь со стороны главного потока и обрабатываемыми подчиненными потоками.
Самое важное изменение класса JobQueue связано переменной-членом workToBeDone_ типа condition. Эта переменная показывает, имеется или нет задание в очереди. Когда потоку требуется получить элемент из очереди, он вызывает функцию getJob, которая пытается захватить мьютекс и затем дожидаться возникновения новой ситуации, что реализуют следующие строки.
boost::mutex::scoped_lock lock(mutex_);
workToBeDone_.wait(lock);
Первая строка блокирует мьютекс обычным образом. Вторая строка разблокирует мьютекс и переводит его в состояние ожидания или в неактивное состояние до тех пор, пока не будет удовлетворено условие. Разблокирование мьютекса позволяет другим потокам использовать этот мьютекс; один из них должен установить ожидаемое условие, в противном случае другие потоки не смогут блокировать мьютекс, пока один поток ожидает возникновения необходимого условия.
В функции submitJob после помещения задания во внутренний список я добавил следующую строку.
workToBeDone_.notify_one();
В результате «удовлетворяется» условие, в ожидании которого находится getJob. Формально это означает, что если существуют какие-нибудь потоки, вызвавшие функцию wait для этого условия, то один из них перейдет в состояние выполнения. Для функции getJob это означает продолжение работы, приостановленной в следующей строке:
workToBeDone_.wait(lock);
Но это еще не все. Функция wait делает две вещи: она дожидается вызова в каком-нибудь потоке функции notify_one или notify_all для данного условия, затем она пытается блокировать соответствующий мьютекс. Поэтому, когда submitJob вызывает notify_all, фактически происходит следующее: ожидающий поток переходит в состояние выполнения и на следующем шаге пытается блокировать мьютекс, который все еще блокирует функция submitJob, поэтому он вновь переходит в состояние ожидания, пока не завершит работу функция submitJob. Таким образом, condition::wait требует, чтобы мьютекс был блокирован при его вызове, когда он оказывается разблокированным и затем вновь заблокированным при удовлетворении условия.
Для уведомления всех потоков, ожидающих удовлетворения некоторого условия, следует вызывать функцию notify_all. Она работает так же, как notify_one, за исключением того, что в состояние выполнения переходят все потоки, ожидающие это условие. Однако теперь все они будут пытаться выполнить блокировку, поэтому характер последующих действий зависит от типа мьютекса и типа используемой блокировки.
Применение условия позволяет управлять ситуацией более тонко, чем при использовании одних только мьютексов и блокировок. Рассмотрим представленный ранее класс Queue. Потоки, ожидающие получение элемента из очереди, находятся в состоянии ожидания до тех пор, пока они не смогут установить блокировку для записи и затем извлечь элемент из очереди. Может показаться, что это будет хорошо работать без применения какого-либо механизма сигнализации, но так ли на самом деле? А что произойдет, когда очередь окажется пустой? У вас нет большого выбора при реализации функции dequeue, если вы ждете удовлетворения некоторого условия: проверка наличия элементов в очереди и, если они отсутствуют, возврат управления; использование другого мьютекса, который блокируется при пустой очереди и разблокируется, когда очередь содержит данные (не подходящее решение) или возврат специального значения, когда очередь оказывается пустой. Все это проблематично или неэффективно. Если вы просто возвращаете управление, когда очередь пустая, выбрасывая исключение или возвращая специальное значение, то вашим клиентам придется постоянно проверять поступающие значения. Это означает бесполезную трату времени.
Объект condition позволяет пользовательским потокам находиться в неактивном состоянии, поэтому процессор может выполнять что-то другое, когда условие не удовлетворяется. Представим веб-сервер, использующий пул рабочих потоков, обрабатывающих поступающие запросы. Значительно лучше иметь дочерние потоки, находящиеся в состоянии ожидания, когда нет никакой активности, чем заставлять их выполнять бесконечный цикл или «засыпать» и «просыпаться» периодически для проверки очереди.
12.4. Однократная инициализация совместно используемых ресурсов
Проблема
Имеется несколько потоков, использующих один ресурс, который необходимо инициализировать только один раз.
Решение
Либо инициализируйте этот ресурс до запуска потоков, либо, если первое невозможно, используйте функцию call_once, определенную в <boost/thread/once.hpp>, и тип once_flag. Пример 12.5 показывает, как можно использовать call_once.
Пример 12.5. Однократная инициализация
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/thread/once.hpp>
// Класс, обеспечивающий некоторое соединение, которое должно быть
// инициализировано только один раз
struct Conn {
 static void init() {++i_;}
 static boost::once_flag init_;
 static int i_;
 // ...
};
int Conn::i_ = 0;
boost::once_flag Conn::init_ = BOOST_ONCE_INIT;
void worker() {
 boost::call_once(Conn::init, Conn::init_);
 // Выполнить реальную работу...
}
Conn с; // Возможно, вы не захотите использовать глобальную переменную,
        // тогда см. следующий рецепт
int main() {
 boost::thread_group grp;
 for (int i=0; i < 100; ++i) grp.create_thread(worker);
 grp.join_all();
 std::cout << с.i_ << '\n'; // c.i = i
}
Обсуждение
Совместно используемый ресурс должен где-то инициализироваться, и, возможно, вы захотите, чтобы это сделал тот поток, который первым стал его использовать. Переменная типа once_flag (реальный ее тип зависит от платформы) и функция call_once могут предотвратить повторную инициализацию объекта. Вам придется сделать две вещи.
Во-первых, проинициализируйте вашу переменную once_flag с помощью макропеременной BOOST_ONCE_INIT. Значение этой макропеременной зависит от платформы. В примере 12.5 класс Conn представляет собой некоторое соединение (базы данных, сокета, оборудования и т.д.), которое я хочу инициализировать лишь однажды, несмотря на то, что несколько потоков могут пытаться сделать то же самое. Подобная ситуация возникает довольно часто, когда требуется динамически загружать библиотеку, имя которой может быть задано, например, в конфигурационном файле приложения. Флаг once_flag — это переменная статического класса, потому что мне требуется только однократная инициализация независимо от количества существующих экземпляров этого класса. Поэтому я следующим образом устанавливаю этот флаг в начальное значение BOOST_ONCE_INIT.
boost::once_flag Conn::initFlag_ = BOOST_ONCE_INIT;
Затем в моей рабочей функции я вызываю call_once, которая синхронизирует доступ к моему инициализированному флагу и, следовательно, предотвращает параллельное выполнение другой инициализации. Я передаю в call_once два аргумента:
boost::call_once(Conn::init, Conn::initFlag_);
Первым аргументом является адрес функции, которая будет выполнять инициализацию. Второй аргумент — это флаг. В данном случае несколько потоков могут попытаться выполнить инициализацию, но только первый в этом преуспеет.
12.5. Передача аргумента функции потока
Проблема
Требуется передать аргумент в вашу функцию потока, однако средствами библиотеки Boost Threads предусматривается передача только функторов без аргументов.
Решение
Создайте адаптер функтора, который принимает ваши параметры и возвращает функтор без параметров. Адаптер функтора можно использовать там, где должен был бы быть функтор потока. Пример 12.6 показывает, как это можно сделать.
Пример 12.6. Передача аргументов функции потока
#include <iostream>
#include <string>
#include <functional>
#include <boost/thread/thread.hpp>
// typedef используется для того, чтобы приводимые ниже объявления лучше
// читались
typedef void (*WorkerFunPtr)(const std::string&);
template<typename FunT, // Тип вызываемой функции
 typename ParamT>       // тип ее параметра
struct Adapter {
 Adapter(FunT f, ParamT& p) : // Сконструировать данный адаптер и
  f_(f), p_(&p) {}            // установить члены на значение функции и ее
                              // аргумента
 void operator()() { // Просто вызов функции с ее аргументом
  f_(*p_);
 }
private:
 FunT f_;
 ParamT* p_; // Использовать адрес параметра. чтобы избежать лишнего
             // копирования
};
void worker(const std::string& s) {
 std::cout << s << '\n';
}
int main() {
 std::string s1 = "This is the first thread!";
 std::string s2 = "This is the second thread!";
 boost::thread thr1(Adapter<WorkerFunPtr, std::string>(worker, s1));
 boost::thread thr2(Adapter<WorkerFunPtr, std::string>(worker, s2));
 thr1.join();
 thr2.join();
}
Обсуждение
Здесь приходится решать принципиальную проблему, причем характерную не только для потоков или проекта Boost, а общую проблему, возникающую при необходимости передачи функтора с одной сигнатурой туда, где требуется другая сигнатура. Решение состоит в создании адаптера.
Синтаксис может показаться немного путаным, но фактически в примере 12.6 создается временный функтор, который может вызываться конструктором потока как функция без аргументов (требуется именно такая функция). Но прежде всего используйте typedef, чтобы указатель функции лучше воспринимался в тексте.
typedef void (*WorkerFunPtr)(const std::string&);
Это создает тип WorkerFunPtr, который является указателем на функцию, принимающую по ссылке аргумент типа string и возвращающую тип void. После этого я создал шаблон класса Adapter. Он обеспечивает инстанцирование динамического функтора. Обратите внимание на конструктор:
template<Typename FunT,
 typename ParamT>
struct Adapter {
 Adapter(FunT f, ParamT& p) : f_(f), p_(&p) {}
 // ...
Конструктор только инициализирует два члена, которые могут быть любого типа, но нам нужно, чтобы это был указатель на функцию и некоторый параметр p любого типа. Ради повышения эффективности я сохраняю адрес параметра, а не его значение.
Теперь рассмотрим следующую строку главного потока.
boost::thread thr1(Adapter<WorkerFunPtr, std::string>(worker, s1))
Аргумент конструктора thr1 представляет собой реализацию шаблона класса Adapter, использующую в качестве параметров два типа WorkerFunPtr и std::string. Это именно те два типа, которые являются членами адаптера f_ и p_. Наконец, Adapter перегружает operator(), поэтому он может вызываться как функция. Его вызов означает просто выполнение следующей функции.
f_(*p_);
Применяя шаблон класса Adapter, можно передавать аргументы функциям потока, причем делается это за счет лишь небольшого усложнения синтаксиса. Если требуется передавать еще один аргумент, просто добавьте дополнительный тип и переменную-член в шаблон Adapter. Этот подход привлекателен тем, что позволяет создавать набор шаблонов классов обобщенного адаптера и использовать их в различных контекстах.
Глава 13
Интернационализация
13.0. Введение
В данной главе приводятся решения некоторых задач, которые обычно возникают при интернационализации программ С++. Обеспечение возможности работы программы в различных регионах (это обычно называется локализацией), как правило, требует решения двух задач: форматирования строк, воспринимаемых пользователем, в соответствии с местными соглашениями (например, даты, времени, денежных сумм и чисел) и обеспечения работы с различными символьными наборами. В настоящей главе рассматривается в основном первая проблема и только кратко вторая, потому что имеется немного возможностей по стандартизации поддержки различных символьных наборов из-за того, что такая поддержка во многом зависит от реализации.
Большая часть программного обеспечения будет работать в странах, отличных от той, где они были написаны. Для поддержки этой практики стандартная библиотека C++ имеет несколько средств, способствующих написанию программного кода, предназначенного для работы в различных странах. Однако они спроектированы не так. как многие другие средства стандартной библиотеки, например строки, файловый ввод-вывод, контейнеры, алгоритмы и т.п. Например, класс, представляющий локализацию, имеет имя locale и содержится в заголовочном файле <lосаlе>. Класс locale предоставляет средства для записи и чтения потоков с применением специфичного для данной местности форматирования и получения таких сведений о локализации, как, например, ее символ валюты или формат даты. Однако стандартом предусматривается обеспечение только одной локализации, и этой локализацией является «C»-локализация, или классическая локализация. Классическая локализация использует стандарт ANSI С: принятые в американском варианте английского языка соглашения по форматированию и 7-битовой код ASCII. И от реализации зависит, будут ли обеспечены экземпляры locale для других языков и регионов.
Заголовочный файл <locale> имеет три основные части. Во-первых, это класс locale (локализация). Он инкапсулирует все поддерживаемые в C++ особенности локализованного поведения и обеспечивает точки входа для получения различной информации о локализации, необходимой для выполнения локализованного форматирования. Во-вторых, самыми маленькими элементами локализации и конкретными классами, с которыми вы будете работать, являются классы, называемые фасетами (facets). Примером фасета является, например, класс time_put, предназначенный для записи даты в поток. В-третьих, каждый фасет принадлежит к некоторой категории, которая объединяет связанные фасеты в одну группу. Например, имеются числовая, временная и денежная категории (только что упомянутый мною фасет time_put относится к временной категории). Я кратко описываю категории в данной главе, однако действительную пользу они приносят при осуществлении более изощренных действий, связанных с локализацией.
Каждая программа на C++ имеет, по крайней мере, одну локализацию, называемую глобальной локализацией (она часто реализуется как глобальный статический объект). По умолчанию это будет классическая локализация «С», пока вы не измените ее на что- нибудь другое. Один из конструкторов locale позволяет инстанцировать локализацию, предпочитаемую пользователем, хотя точное определение «предпочитаемой» пользователем локализации полностью зависит от реализации.
В большинстве случаев локализации используются при записи и чтении потоков. Это является основной темой настоящей главы.
13.1. Жесткое кодирование строк в коде Unicode
Проблема
Требуется в исходном файле жестко закодировать строки в коде Unicode, т.е. используя расширенный набор символов.
Решение
Начинайте строку с префикса L и затем вводите символы в своем редакторе исходных текстов, как вы это обычно делаете при написании строк, или используйте шестнадцатеричные значения, представляющие нужный вам символ в коде Unicode. Пример 13.1 демонстрирует оба способа кодирования таких строк.
Пример 13.1. Жесткое кодирование строк в коде Unicode
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main() {
 // Создать несколько строк с символами кода Unicode
 wstring ws1 = L"Infinity: \u221E";
 wstring ws2 = L"Euro: €"
 wchar_t w[] = L"Infinity: \u221E";
 wofstream out("tmp\\unicode.txt");
 out << ws2 << endl;
 wcout << ws2 << endl;
}
Обсуждение
Основной вопрос, возникающий при жестком кодировании строк в коде Unicode, связан с выбором способа ввода строки в редакторе исходных текстов. В C++ предусмотрен тип расширенного набора символов wchar_t, который может хранить строки в коде Unicode. Точное представление wchar_t зависит от реализации, однако часто используется формат UTF-32. Класс wstring определяется в <string> как последовательность символов типа wchar_t, подобно тому как класс string представляет собой последовательность символов типа char. (Строго говоря, тип wstring определяется, конечно, с помощью typedef как basic_string<wchar_t>.)
Самый простой способ ввода символов в коде Unicode — это использование префикса L перед строковым литералом, как показано в примере 13.1.
wstring ws1 = L"Infinity, \u2210"; // Использовать сам код
wstring ws2 = L"Euro: €"; // или просто ввести символ
Теперь можно записать эти строки с расширенным набором символов в поток с расширенным набором символов.
wcout << ws1 << endl; // wcout - версия cout для расширенного набора символов
Их можно записывать также в файлы:
wofstream out("tmp\\unicode.txt");
out << ws2 << endl;
При работе с различными кодировками наибольшую ловкость приходится проявлять не для ввода правильных символов в ваши исходные файлы, а при определении типа символьных данных, получаемых из базы данных, по запросу HTTP, из пользовательского ввода и т.д., что выходит за рамки стандарта C++. Стандарт C++ не устанавливает никаких специальных требований, кроме того, что операционная система может использовать для исходных файлов любую кодировку, если она поддерживает, по крайней мере, 96 символов, используемых в языке С++. Для символов, не попадающих в этот набор, называемый основным исходным набором символов, стандартом предусматривается возможность их получения с помощью escape-последовательностей \uXXXX или \UXXXXXXXX, где X — шестнадцатеричная цифра.
13.2. Запись и чтение чисел
Проблема
Требуется записать число в поток в форматированном виде в соответствии с местными соглашениями.
Решение
Закрепите (imbue) текущую локализацию за потоком, в который вы собираетесь писать данные, и запишите в него числа, как это сделано в примере 13.2, или можете установить глобальную локализацию и затем создать поток. Последний подход рассматривается в обсуждении.
Пример 13.2. Запись чисел с использованием локализованного форматирования
#include <iostream>
#include <locale>
#include <string>
using namespace std;
// На заднем плане существует глобальная локализация, установленная средой
// этапа выполнения. По умолчанию это локализация "С". Вы можете ее
// заменить локализацией locale::global(const locale&).
int main() {
 locale loc(""); // Создать копию пользовательской локализации
 cout << "Locale name = " << loc.name() << endl;
 cout.imbue(loc); // Уведомить cout о необходимости применения
                  // пользовательской локализации при форматировании
 cout << "pi in locale " << cout.getloc().name() << " is << 3.14 << endl;
}
Обсуждение
Пример 13.2 показывает, как можно использовать пользовательскую локализацию для форматирования числа с плавающей точкой. Это делается в два этапа: сначала создается экземпляр класса locale, который затем закрепляется за потоком с помощью функции imbue.
Сначала в примере 13.2 создается loc, который является копией пользовательской локализации. Это необходимо делать, используя конструктор locale, принимающий пустую строку (а не конструктор по умолчанию).
locale loc("");
Отличие небольшое, но важное, и я вскоре вернусь к нему. При создании здесь объекта locale создается копия «пользовательской локализации», которая зависит от реализации. Это значит, что, если машина сконфигурирована на применение американского варианта английского языка, функция locale::name() может возвращать такие строковые имена локализации, как «en_US», «English_United States.1252», «english-american» и т.д. Реальная строка определяется реализацией, а по стандарту C++ достаточно иметь только одну локализацию — «C»-локализацию.
Для сравнения отметим, что конструктор по умолчанию класса locale возвращает копию текущей глобальной локализации. Всякая выполняемая программа, написанная на С++, имеет один глобальный объект locale (возможно, реализованный как статическая переменная где-то в библиотеке этапа выполнения; детали его реализации зависят от используемой платформы). По умолчанию это будет локализация С, и вы можете заменить ее локализацией locale::global(locale& loc). Когда потоки создаются, они используют глобальную локализацию, существующую на момент их создания; это означает, что cin, cout, cerr, wcin, wcout и wcerr используют локализацию С, поэтому приходится явным образом ее менять, если требуется, чтобы форматирование подчинялось соглашениям, принятым в определенной местности.
Имена локализаций не стандартизованы. Однако обычно они имеют следующий формат.
<язык>_<страна>.<кодовая_страница>
Язык задается полным названием, например «Spanish», или двухбуквенным кодом, например «sp»; страна задается своим названием, например «Colombia», или двухбуквенным кодом страны, например «СО», а кодовая страница задается своим обозначением, например 1252. Обязательно должен быть указан только язык. Поэкспериментируйте, явно задавая локализации в различных системах, чтобы почувствовать характер отличий имен при применении разных компиляторов. Если вы используете неверное имя локализации, будет выброшено исключение runtime_error. Пример 13.3 показывает, как можно явно задавать имена локализаций.
Пример 13.3. Явное именование локализаций
#include <iostream>
#include <fstream>
#include <locale>
#include <string>
using namespace std;
int main() {
 try {
  locale loc("");
  cout << "Locale name = " << loc.name() << endl;
  locale locFr("french");
  locale locEn("english-american");
  locale locBr("portuguese-brazilian");
  cout.imbue(locFr); // Уведомить cout о необходимости применения
                     // французского форматирования
  cout << "3.14 (French) = " << 3.14 << endl;
  cout << "Name = " << locFr.name() << endl;
  cout.imbue(locEn); // Теперь перейти на английский (американский
                     // вариант)
  cout << "3.14 (English) = " << 3.14 << endl;
  cout << "Name = " << locEn.name() << endl;
  cout.imbue(locBr); // Уведомить cout о необходимости применения
                     // бразильского форматирования
  cout << "3.14 (Brazil) = " << 3.14 << endl;
  cout << "Name = " << locBr.name() << endl;
 } catch (runtime_error& e) {
  // Если используется неверное имя локализации, выбрасывается исключение
  // runtime_error.
  cerr << "Error: " << e.what() << endl;
 }
}
Результат выполнения этой программы в системе Windows при использовании Visual C++ 7.1 выглядит следующим образом.
Locale name = English_United States.1252
3.14 (French) = 3,14
Name = French_France.1252
3.14 (English) = 3.14
Name = English_United States.1252
3.14 (Brazil) = 3,14
Name = Portuguese_Brazil.1252
Отсюда видно, что моя машина локализована на американский вариант английского языка с использованием кодовой страницы 1252. Этот пример также показывает, как выводится число «пи» при использовании двух других локализаций. Обратите внимание, что во французском и бразильском вариантах применяется запятая вместо десятичной точки. Разделитель тысяч тоже другой: во французском и португальском вариантах используется пробел вместо запятой, поэтому число 1,000,000.25, представленное в американском формате, имело бы вид 1 000 000,25 в формате французской и португальской локализации.
В большинстве случаев все же не стоит создавать локализации, явно задавая их имена. Чтобы использовать локализации для печати чисел, дат, денежных и каких-либо других значений, просто достаточно инстанцировать локализацию, используя пустую строку и закрепляя ее за потоком.
Правила применения локализаций могут показаться немного путанными, поэтому я кратко изложу основные моменты.
• Используемая по умолчанию глобальная локализация является локализацией «С», потому что стандартом гарантируется существование в любой реализации только этой локализации.
• Все стандартные потоки создаются с применением глобальной локализации при запуске программы, и этой локализацией является локализация «С».
• Копию пользовательской текущей локализации можно создать, передавая пустую строку конструктору locale, например locale("").
• Объект locale для именованной локализации можно создать, передавая строку, идентифицирующую локализацию, например locale("portuguese-brazilian"). Однако эти строки не стандартизованы.
• После получения объекта locale, представляющего стандартную пользовательскую локализацию или именованную локализацию, можно установить глобальную локализацию с помощью функции locale::global. Все создаваемые после этого потоки будут использовать глобальную локализацию.
• Для потока локализацию можно задать явно при помощи функции-члена imbue.
При написании программного обеспечения, учитывающего местные особенности, применяйте локализованное форматирование только к данным, которые пользователь видит. То есть если вам требуется отобразить число в формате, привычном для пользователя, инстанцируйте локализацию и закрепите ее за потоком, чтобы число отображалось правильно. Однако, если вы записываете данные в файл или в какую-то другую промежуточную сериализованную память, используйте локализацию С, обеспечивая переносимость. Если ваша программа явным образом изменяет глобальную локализацию, вам необходимо явно закрепить ее за потоками, использующими локализацию С. Вы это можете сделать двумя способами: создавая локализацию с именем «С» или вызывая функцию locale::classic().
ofstream out("data.dat");
out.imbue(locale::classic());
out << pi << endl; // Записать, используя локализацию С
Считываются числа аналогично. Например, для чтения числа с использованием французской локализации и записи его с использованием локализации С выполните следующее.
double d;
cin.imbue(locale("french"));
cin >> d;
cout << "In English: " << d;
Если вы выполните эту программу и введете 300,00, она распечатает 300.
Чтобы поток подчинялся местным соглашениям по выводу чисел, явно закрепите за потоком объект locale целевой локализации с помощью функции imbue. Если требуется во всех созданных потоках использовать конкретную локализацию, сделайте ее глобальной. Значения денежных значений обрабатываются немного по-другому; см. рецепт 13.4, где показано, как можно записывать и считывать денежные значения.
Смотри также
Рецепт 13.4.
13.3. Запись и чтение дат и времен
Проблема
Требуется отобразить или прочитать значения дат и времен, используя местные соглашения по форматированию.
Решение
Используйте тип time_t и tm struct из <ctime>, а также фасеты даты и времени, предусмотренные в <locale>, для записи и чтения дат и времен (фасеты вскоре будут рассмотрены при обсуждении примера). См. пример 13.4.
Пример 13.4. Запись и чтение дат
#include <iostream>
#include <ctime>
#include <locale>
#include <sstream>
#include <iterator>
using namespace std;
void translateDate(istream& in, ostream& out) {
 // Создать считывающий дату объект
 const time get<char>& dateReader =
  use_facet<time_get<char> >(in.getloc());
 // Создать объект состояния который будет использован фасетом для
 // уведомления нас о возникновении проблемы
 ios_base::iostate state = 0;
 // Маркер конца
 istreambuf_iterator<char> end;
 tm t; // Структура для представления времени (из <ctime>)
 // Теперь, когда все подготовлено, считать дату из входного потока
 // и поместить ее в структуру времени.
 dateReader.get_date(in, end, in, state, &t);
 // В данный момент дата находится в структуре tm. Вывести ее в поток,
 // используя соответствующую локализацию. Убедитесь, что выводятся только
 // достоверные данные из t.
 if (state == 0 || state == ios_base::eofbit) { // Чтение выполнено успешно.
  const Time_put<char>& dateWriter =
   use_facet<time_put<char> >(out.getloc());
  char fmt[] = "%x";
  if (dateWriter.put{out, out, out.fill(),
   &t, &fmt[0], &fmt[2]).failed())
   cerr << "Unable to write to output stream.\n";
 } else {
  cerr << "Unable to read cin!\n";
 }
}
int main() {
 cin.imbue(locale("english"));
 cout.imbue(locale("german"));
 translateDate(cin, cout);
}
Эта программа выдает следующий результат
3/28/2005
28.03.2005
Обсуждение
Для правильной записи и чтения значений даты и времени необходимо знать некоторые детали проекта класса locale. Прочтите введение в эту главу, если вы еще не знакомы с концепциями локализаций и фасетов.
В C++ нет стандартного класса для представления даты и времени, а наиболее подходящими для этого типами являются time_t и структура tm из <ctime>. Если требуется записывать и считывать даты с использованием средств стандартной библиотеки, вам придется любое нестандартное представление даты преобразовывать в структуру tm. Это имеет смысл, поскольку используемые вами реализации, вероятно, уже имеют встроенную поддержку форматирования дат с учетом местных особенностей.
Ранее я говорил, что фасет определяет некоторый аспект локализации, отражающий ее особенности. Более конкретно, фасет — это константная инстанциация шаблона класса символьного типа, поведение которого зависит от класса локализации, используемого при конструировании. В примере 13.4 я следующим образом создаю экземпляр фасета time_get.
const time_get<char*>& dateReader =
 use_facet<time_get<char> >(in.getloc());
Шаблон функции use_facet находит заданный фасет для заданной локализации. Все стандартные фасеты являются шаблонами классов, которые принимают параметр символьного типа, и, поскольку мною считываются и записываются символы типа char, я инстанцирую мой класс time_get для char. Стандарт требует, чтобы реализация обеспечивала специализацию шаблона для char и wchar_t, поэтому они гарантированно существуют (хотя не гарантируется поддержка заданной локализации, кроме локализации С). Созданный мною объект time_get имеет спецификатор const, потому что предусмотренная реализацией функциональность локализации это набор правил форматирования различного вида данных в разных локализациях, и эти правила не могут редактироваться пользователем, поэтому состояние заданного фасета не должно изменяться в программном коде, где он используется.
Локализация, передаваемая мною в функцию use_facet, связана с потоком, в который я собираюсь записывать данные. Функция getloc() объявляется в ios_base; она возвращает локализацию, связанную с потоком ввода или вывода. Наилучший подход — применение локализации, уже связанной с потоком, который вы собираетесь использовать для ввода или вывода данных; передача в качестве параметра или каким-либо другим способом имени локализации легко приводит к ошибкам.
После создания объекта, который будет выполнять реальное чтение, мне необходимо обеспечить контроль состояния потока.
ios_base::iostate state = 0;
Сами фасеты не модифицируют состояние потока (например, устанавливая stream::failbit = 1); вместо этого они установят соответствующее значение в вашем объекте состояния, показывая, что дату нельзя считывать. Это объясняется тем, что чтение форматированного значения терпит неудачу не обязательно из-за потока; поток ввода символов может быть в полном порядке, однако его чтение с использованием нужного вам формата может оказаться невозможным.
Реальное значение даты хранится в структуре tm. Вам требуется только создать локальную переменную типа tm и передать ее адрес фасету time_get или time_put.
Считав дату, я могу проверить значение переменной, которую я использую для контроля состояния потока. Если это значение равно нулю или ios_base::eofbit, то это говорит о том, что поток находится в нормальном состоянии и что моя дата была считана без проблем. Поскольку в примере 13.4 мне нужно было записать дату в другой поток, пришлось создать объект, используемый именно для этой цели. Я делаю это следующим образом.
const time_put<char>& dateWriter =
use_facet<time_put<char> >(out.getloc());
Это работает так же, как и предыдущая инстанциация класса time_get, но в другом направлении. После этого я создал строку форматирования (используя синтаксис, подобный применяемому в функции printf), которая будет печатать дату. «%x» выводит дату, а «%X» выводит время. Однако следует быть осторожным: в этом примере считывается только дата, поэтому члены структуры tm, относящиеся ко времени, в этот момент имеют неопределенные значения.
Теперь можно писать данные в поток вывода. Это делается следующим образом.
if (dateWriter.put(out, // Итератор потока вывода
 out,                   // Лоток вывода
 out.fill(),            // Использовать символ заполнителя
 &t,                    // Адрес структуры tm
 &fmt[0],               // Начало и конец строки форматирования
 &fmt[2]
).failed())             // iter_type.failed() показывает, была или
                        // нет ошибка при записи
Функция time_put::put записывает дату в переданный ей поток вывода, используя локализацию, с которой был создан объект time_put. time_put::put возвращает итератор ostreambuf_iterator, который имеет функцию-член failed, позволяющую зафиксировать ситуацию, когда итератор оказывается испорченным.
get_date не единственная функция-член, которую можно использовать для получения компонент даты из потока. Ниже перечислены некоторые из них.
get_date
Получает дату из потока, используя местные правила форматирования.
get_time
Получает время из потока, используя местные правила форматирования.
get_weekday
Получает название дня недели, например Monday, lundi, понедельник.
get_year
Получает год, используя местные правила форматирования.
Может быть полезной также функция-член date_order. Она возвращает перечисление (time_base::dateorder из <locale>), которое определяет порядок месяца, дня и года в дате. Эта функция может помочь в тех случаях, когда вам приходится анализировать вывод даты, полученной функцией time_get::put. Пример 13.5 показывает, как можно проверять порядок элементов, составляющих дату.
Пример 13.5. Определение последовательности элементов в дате
#include <iostream>
#include <locale>
#include <string>
using namespace std;
int main() {
 cin.imbue(locale("german"));
 const time_get<char>& dateReader =
  use_facet<time_get<char> >(cin.getloc());
 time_base::dateorder d = dateReader.date_order();
 string s;
 switch (d) {
 case time_base::no_order:
  s = "No order";
  break;
 case time_base::dmy:
  s = "day/month/year";
  break;
 case time_base::mdy:
  s = "month/day/year";
  break;
 case time_base::ymd:
  s = "year/month/day";
  break;
 case time_base::ydm:
  s = "year/day/month";
  break;
 }
 cout << "Date order for locale " << cin.getloc().name()
  << " is " << s << endl;
}
Имеется еще одно средство, которое может оказаться полезным при инстанцировании фасетов: has_facet. Шаблон этой функции возвращает значение типа bool, показывающее, определен или нет нужный вам фасет в заданной локализации. Поэтому для надежности используйте has_facet во всех случаях, когда вы инстанцируете фасет. Если она возвращает значение «ложь», вы всегда можете перейти к используемой по умолчанию классической локализации С, поскольку ее наличие гарантировано в реализации, отвечающей требованиям стандарта. has_facet применяется следующим образом.
if (has_facet<time_put<char> >(loc)) {
 const time_put<char>& dateWriter =
  use_facet<time_put<char> >(loc);
Разобравшись однажды в синтаксисе классов time_get и time_put, вы поймете, что использовать их достаточно просто. Как всегда, можно воспользоваться typedef, чтобы свести к минимуму количество неприятных угловых скобок.
typedef time_put<char> TimePutNarrow;
typedef time_get<char> TimeGetNarrow;
// ...
const TimeGetNarrow& dateReader = use_facet<TimeGetNarrow>(loc);
Процедура записи и чтения дат в локализованных форматах немного утомительна, однако, после того как вы один раз разберетесь в требованиях класса локализации locale, вы сможете это делать эффективно и быстро. Глава 5 полностью посвящена датам и временам, поэтому более детальные сведения по форматированию вывода дат и времен вы найдете в рецепте 5.2.
Смотри также
Глава 5 и рецепт 5.2.
13.4. Запись и чтение денежных значений
Проблема
Требуется записать в поток или прочитать из него денежное значение.
Решение
Используйте фасеты money_put и money_get для записи или чтения денежных значений, как показано в примере 13.6.
Пример 13.6. Запись и чтение денежных значений
#include <iostream>
#include <locale>
#include <string>
#include <sstream>
using namespace std;
long double readMoney(istream& in, bool intl = false) {
 long double val;
 // Создать фасет для чтения
 const money_get<char>& moneyReader =
  use_facet<money_get<char> >(in.getloc());
 // Маркер конца
 istreambuf iterator<char> end;
 // Переменная состояния для обнаружения ошибок
 ios_base::iostate state = 0;
 moneyReader.get(in, end, intl, in, state, val);
 // если что-то не получилось, будет установлен бит неудачного завершения
 if (state != 0 && !(state & ios_base::eofbit))
  throw "Couldn't read money!\n";
 return(val);
}
void writeMoney(ostream& out, long double val, bool intl = false) {
 // Создать фасет для записи
 const money_put<char>& moneyWriter =
  use_facet<money_put<char> >(out.getloc());
 // Записать данные в поток. Вызвать failed() (возвращает итератор
 // ostreambuf_iterator), чтобы можно было обнаружить ошибку.
 if (moneyWriter.put(out, intl, out, out.fill(), val).failed())
  throw "Couldn't write money!\n";
}
int main() {
 long double val = 0;
 float exchangeRate = 0.775434f; // Курс доллара по отношению к евро
 locale locEn("english");
 locale locFr("french");
 cout << "Dollars: ";
 cin.imbue(locEn);
 val = readMoney(cin, false);
 cout.imbue(locFr);
 // Установить флаг showbase, чтобы выводить символ валюты
 cout.setf(ios_base::showbase);
 cout << "Euros: ";
 writeMoney(cout, val = exchangeRate, true);
}
Если выполнить программу примера 13.6, можно получить следующий результат.
Dollars: $100
Euros: EUR77,54
Обсуждение
Фасеты money_put и money_get записывают форматированные денежные значения в поток и считывают их из потока. Они работают почти так же, как фасеты даты/времени и числовые фасеты, описанные в предыдущих рецептах. Стандарт требует, чтобы были их реализации для стандартных символов и расширенного набора символов, например money_put<char> и money_put<wchar_t>. Как и для других фасетов, функции записи и чтения многословны, но, применив их несколько раз, легко запоминаешь параметры. money_get и money_put используют класс moneypunct, содержащий информацию о форматировании.
Сначала рассмотрим запись денежных значений в поток. Отображение денежной суммы состоит из нескольких частей: знака валюты, знака плюс или минус, разделителя тысяч и десятичной точки. Все они, кроме десятичной точки, могут отсутствовать.
Вы создаете объект money_put с типом символа и локализацией следующим образом.
const money_put<char>& moneyWriter =
 use_facet<money_put<char> >(out.getloc());
Стандарт требует наличия версий как для char, так и для wchar_t. Разумно использовать локализацию потока, в который осуществляется запись, чтобы избежать несогласованности, возникающей при попытке синхронизации потока и объекта money_put. На следующем шаге вызовите метод put для записи денежного значения в поток вывода.
if (moneyWriter.put(out, // Итератор вывода
 intl,                   // bool: использовать формат intl?
 out,                    // ostream&
 out.fill(),             // использовать символ заполнителя
 val)                    // денежное значение, тип long double
.failed()) throw "Couldn't write money!\n";
Функция money_put::put записывает денежное значение в переданный ей поток вывода, используя локализацию, с которой был создан объект money_put. money_put::put возвращает итератор ostreambuf_iterator, который ссылается на позицию за последним выведенным символом; этот итератор имеет функцию-член failed, позволяющую зафиксировать ситуацию, когда итератор оказывается испорченным.
Все параметры money_put::put не требуют дополнительных пояснений, кроме, возможно, второго (аргумент intl в примере). Он имеет тип bool и показывает, будет использоваться символ валюты (например, $, €) или трехбуквенное международное обозначение валюты (например, USD, EUR). Для использования символа валюты установите его в значение false, а для использования международного обозначения валюты — в значение true.
При записи денежных значений в поток вывода можно задавать некоторые параметры потока, которые управляют форматированием. Ниже описывается каждый параметр и объясняется его воздействие на вывод денежного значения.
ios_base::internal
Если при форматировании денежного значения задается пробел или пустое значение, будет использован символ заполнителя (а не пробел). Ниже при обсуждении moneypunct приводятся дополнительные сведения по шаблонам форматирования.
ios_base::left и ios_base::right
Выравнивает денежное значение влево или вправо; при этом остальные позиции в пределах заданной ширины заполняются символом заполнителя (см. описание следующего параметра, width). Это удобно, потому что облегчает табуляцию денежного значения.
ios_base::width
Значения, выдаваемые функцией money_put, подчиняются стандартным правилам управления шириной поля потока. По умолчанию эти значения выравниваются влево. Если поле больше, чем размер значения, используется символ заполнителя, указанный при вызове функции money_put.
ios_base::showbase
Если этот флаг имеет значение «истина», символ валюты выводится, в противном случае он не выводится.
Как я говорил ранее, функции money_get и money_put используют класс moneypunct, в котором фактически хранится информация о форматировании. Вам не стоит беспокоиться о классе moneypunct, если вы не заняты реализацией стандартной библиотеки, но вы можете использовать его для исследования параметров форматирования, применяемых в конкретной локализации, moneypunct содержит такие сведения, как используемый символ валюты, символ, используемый в качестве десятичной точки, формат положительных и отрицательных значений и т.д. В примере 13.7 представлена короткая программа, печатающая информацию о формате денежных значений, который используется в заданной локализации.
Пример 13.7. Вывод информации о форматировании денежных значений
#include <iostream>
#include <locale>
#include <string>
using namespace std;
string printPattern(moneypunct<char>::pattern& pat) {
 string s(pat.field); // pat.field имеет тип char[4]
 string r;
 for (int i = 0; i < 4; ++i) {
  switch (s[i]) {
  case moneypunct<char>::sign:
   r += "sign ";
   break;
  case moneypunct<char>::none:
   r += "none ";
   break;
  case moneypunct<char>::space:
   r += "space ";
   break;
  case moneypunct<char>::value:
   r += "value ";
   break:
  case moneypunct<char>::symbol:
   r += "symbol ";
   break;
  }
 }
 return(r);
}
int main() {
 locale loc("danish");
 const moneypunct<char>& punct =
  use_facet<moneypunct<char> >(loc),
 cout << "Decimal point: " << punct.decimal_point() << '\n'
  << "Thousands separator. " << punct.thousands_sep() << '\n'
  << "Currency symbol: " << punct.curr_symbol() << '\n'
  << "Positive sign: " << punct.positive_sign() << '\n'
  << "Negative sign: " << punct.negative_sign() << '\n'
  << "Fractional digits: " << punct.frac_digits() << '\n'
  << "Positive format: "
  << printPattern(punct pos_format()) << '\n'
  << "Negative format: "
  << printPattern(punct.neg_format()) << '\n';
 // Группировки описываются символьной строкой, но осмысленными
 // являются числовые значения символов, а не собственно символы
 string s = punct.grouping();
 for (string::iterator p = s.begin(); p != s.end(); ++p)
  cout << "Groups of: " << (int)*p << '\n';
}
Назначение большинства этих методов самоочевидно, но некоторые методы требуют дополнительных пояснений. Во-первых, метод grouping возвращает строку символов, которая интерпретируется как строка целочисленных значений. Каждый символ описывает свою группу цифр в числе, начиная с правой стороны числа. И если в какой-то позиции строки нет значения, то используется значение в предыдущей позиции. Другими словами, для стандартного американского формата в позиции 0 этой строки будет значение 3, что означает три цифры для группы с индексом 0. Поскольку других значений нет, все группы с индексом, большим нуля, должны также состоять из трех цифр.
pos_format и neg_format возвращают объект типа moneypunct<T>::pattern, который имеет член field типа T[4], где T — символьный тип. Каждый элемент поля field содержит один из элементов перечисления moneypunct<T>::part, который имеет пять возможных значений: none, space, symbol, sign и value. Строковое представление денежного значения состоит из четырех частей (т.е. массив с четырьмя элементами) Обычно части денежного значения образуют последовательность symbol space sign value (символ валюты пробел знак значение), что означало бы вывод, например, значения $ -32.00. Часто знак плюс заменяется пустой строкой, поскольку значение без знака обычно рассматривается как положительное значение. Признак отрицательного числа может содержать несколько символов, как, например, «()», и в этом случае первый символ выдается в части symbol формата отрицательного числа (neg_format), а другой символ выдается в конце, поэтому отрицательные числа могут иметь, например, такой вид: $(32.00).
Большую часть времени вам не придется беспокоиться по поводу получения информации о форматировании, содержащейся в moneypunct. Однако если вам необходимо выполнить большой объем формирования денежных значений в различных локализациях, то имеет смысл поэкспериментировать и познакомиться с особенностями форматирования в различных локализациях.
Смотри также
Рецепты 13.2 и 13.3.
13.5. Сортировка локализованных строк
Проблема
Имеется последовательность строк, содержащая символы не в коде ASCII, и требуется ее отсортировать с учетом местных особенностей.
Решение
В класс локализации встроена поддержка операций сравнения символов в заданной локализации путем перегрузки оператора operator<. При вызове любой стандартной функции, принимающей функтор сравнения, можно использовать в качестве такого функтора экземпляр класса локализации. (См. пример 13.8.)
Пример 13.8. Сортировка с учетом местных особенностей
#include <iostream>
#include <locale>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
bool localelessThan(const string& s1, const string& s2) {
 const collate<char>& col =
  use_facet<collate<char> >(locale()); // Использовать глобальную
                                       // локализацию
 const char* pb1 = s1.data();
 const char* pb2 = s2.data();
 return (col.compare(pb1, pb1 + s1.size(),
  pb2, pb2 + s2.size()) < 0);
}
int main() (
 // Создать две строки, одна с немецким символом
 string s1 = "diät";
 string s2 = "dich";
 vector<string> v;
 v.push_back(s1);
 v.push_back(s2);
 // Сортировать, не используя заданную локализацию, т.е. Применяя
 // правила текущей глобальной локализации
 sort(v.begin(), v.end());
 for (vector<string>::const_iterator p = v.begin();
  p != v.end(); ++p)
  cout << *p << endl;
 // Установить в качестве глобальной немецкую локализацию и затем
 // сортировать
 locale::global(locale("german"));
 sort(v.begin(), v.end(), localelessThan);
 for (vector<string>::const_iterator p = v.begin();
  p != v.end(); ++p)
  cout << *p << endl;
}
Первый вариант обеспечивает сортировку по коду ASCII, и поэтому результат будет выглядеть следующим образом.
dich
diät
Вторая сортировка использует правильный порядок букв немецкого алфавита, и поэтому результат будет противоположным.
diät
dich
Обсуждение
Сортировка усложняется, когда вы работаете с различными локализациями, но стандартная библиотека решает эту проблему. Фасет collate обеспечивает функцию-член compare, которая работает как strcmp: она возвращает значение -1, если первая строка меньше второй, значение 0, если они равны, и значение 1, если первая строка больше второй. В отличие от strcmp, функция collate::compare использует определенную в целевой локализации упорядоченность символов.
В примере 13.8 приводится функция localeLessThan, которая возвращает True, если согласно глобальной локализации первый аргумент меньше второго. Самым важным здесь моментом является вызов функции сравнения.
col.compare(pb1,  // Указатель на первый символ
 pb1 + s1.size(), // Указатель на позицию за последним символом
 pb2,
 pb2 + s2.size());
Выполнение примера 13.8 на вашем компьютере может дать результат как совпадающий, так и не совпадающий с приведенным мною, — это зависит от используемого в вашей реализации набора символов. Однако, если требуется обеспечить сравнение строк с учетом местных особенностей, вам следует использовать collate::compare. Конечно, стандарт не требует, чтобы реализация поддерживала какую-либо локализацию, кроме локализации «C», поэтому не забудьте протестировать все используемые вами локализации.
Глава 14
XML
14.0. Введение
Язык XML играет важную роль во многих областях, в том числе при хранении и поиске информации, в издательском деле и при передаче данных по сетям; в данной главе мы научимся работать с XML в С++. Поскольку эта книга больше посвящена С++, чем XML, я полагаю, вы уже имеете некоторый опыт применения различных технологий, связанных с XML, например SAX, DOM, XML Schema, XPath и XSLT. He стоит беспокоиться из-за того, что вы не являетесь экспертом во всех этих областях; приводимые в данной главе рецепты достаточно независимы друг от друга, поэтому вы можете пропустить некоторые из них и все-таки понять остальные. Во всяком случае, каждый рецепт дает краткое описание концепций XML и используемого ими инструментария.
Если вы имеете достаточный опыт программирования на другом языке, например на Java, вы можете предположить, что средства обработки документов XML входят в состав стандартной библиотеки С++. К сожалению, XML делал только первые шаги, когда стандарт C++ был уже принят, и хотя добавление средств обработки документов XML в новую версию стандартной библиотеки C++ вызывает большой интерес, в настоящее время вам придется полагаться на несколько доступных в C++ великолепных библиотек XML, поставляемых независимыми разработчиками.
Возможно, перед началом чтения рецептов вы захотите скачать из Интернета и установить библиотеки, которые будут рассмотрены в настоящей главе. В табл. 14.1 приводятся домашние страницы каждой библиотеки, а в табл. 14.2 указано назначение каждой библиотеки и ссылки на рецепты, в которых они используются. В таблицах не указаны точные версии различных спецификаций и рекомендаций XML, реализованные каждой библиотекой, поскольку эта информация, вероятно, изменится в ближайшем будущем.
Табл. 14.1. Библиотеки C++ для XML
Имя библиотеки	Домашняя страница
TinyXml	www.grinninglizard.com/tinyxml
Xerxes	xml.apache.crg/xerces-c
Xalan	xml.apache.org/xalan-c
Pathan 1	software.decisionsoft.com/pathanIntro.html
Boost.Serialization	www.boost.org/libs/serialization
Табл. 14.2. Назначение библиотек
Имя библиотеки	Назначение	Рецепты
TinyXml	DOM (нестандартная версия)	Рецепт 14.1
Xerxes	SAX2, DOM, XML Schema	Рецепты 14.2-14.8
Xalan	XSLT, XPath	Рецепты 14.7-14.8
Pathan	XPath	Рецепт 14.8
Boost.Serialization	Сериализация XML	Рецепт 14.9
14.1. Синтаксический анализ простого документа XML
Проблема
Имеется некоторая совокупность данных, хранимых в документе XML. Требуется выполнить синтаксический анализ документа и превратить эти данные в объекты C++. Документ XML имеет достаточно небольшой размер и может поместиться в оперативной памяти, причем в документе не используется внутреннее определение типа документа (Document Type Definition — DTD) и отсутствуют пространства имен XML.
Решение
Используйте библиотеку TinyXml. Во-первых, определите объект типа TiXmlDocument и вызовите его метод LoadFile(), передавая полное имя файла вашего XML-документа в качестве его аргумента. Если LoadFile() возвращает значение «true», то это означает, что анализ вашего документа завершился успешно. В этом случае вызовите метод RootElement() для получения указателя на объект типа TiXmlElement, представляющего корневой элемент документа. Этот объект имеет иерархическую структуру, которая соответствует структуре вашего документа XML; выполняя проход по этой структуре, вы можете извлечь информацию о документе и использовать ее для создания набора объектов С++.
Например, предположим, что у вас имеется XML-документ animals.xml, описывающий некоторое количество животных цирка, как показано в примере 14.1. Корень документа имеет имя animalList и содержит несколько дочерних элементов animal, каждый из которых представляет одно животное, принадлежащее цирку Feldman Family Circus. Предположим также, что у вас имеется класс C++ с именем Animal, и вам нужно сконструировать вектор std::vector, состоящий из объектов Animal, представляющих животных, перечисленных в документе.
Пример 14.1. Документ XML со списком животных цирка
<?xml version="1.0" encoding="UTF-8"?>
<!- Животные цирка Feldman Family Circus -->
<animalList>
 <animal>
  <name>Herby</name>
  <species>elephant</species>
  <dateOfBirth>1992-04-23</dateOfBirth>
  <veterinarian name="Dr. Hal Brown" phone="(801)595-9627"/>
  <trainer name="Bob Fisk" phone=(801)881-2260"/>
 </animal>
 <animal>
  <name>Sheldon</name>
  <species>parrot</species>
  <dateOfBirth>1998-09-30</dateOfBirth>
  <veterinarian name="Dr Kevin Wilson" phone="(801)466-6498"/>
  <trainer name="Eli Wendel" phone="(801)929-2506"/>
 </animal>
 <animal>
  <name>Dippy</name>
  <species>penguin</species>
  <dateOfBirth>2001-06-08</dateOfBirth>
  <veterinarian name= "Dr. Barbara Swayne" phone="(801)459-7746"/>
  <trainer name="Ben Waxman" phone="(801)882-3549"/>
 </animal>
</animalList>
Пример 14.2 показывает, как может выглядеть определение класса Animal. Animal имеет пять данных-членов, соответствующих кличке, виду, дате рождения, ветеринару и дрессировщику животного. Кличка и вид животного представляются строками типа std::string, дата его рождения представляется типом boost::gregorian::date из Boost.Date_Time, а его ветеринар и дрессировщик представляются экземплярами класса Contact, который определен также в примере 14.2. Пример 14.3 показывает, как можно использовать TinyXml для синтаксического анализа документа animals.xml, просмотра разобранного документа и заполнения вектора std::vector объектов Animal, используя извлеченные из документа данные.
Пример 14.2. Заголовочный файл animal.hpp
#ifndef ANIMALS_HPP_INCLUDED
#define ANIMALS_HPP_INCLUDED
#include <ostream>
#include <string>
#include <stdexcept> // runtime_error
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/regex.hpp>
// Представляет ветеринара или дрессировщика
class Contact {
public:
 Contact() {}
 Contact(const std::string& name, const std::string& phone) :
  name_(name) {
  setPhone(phone);
 }
 std::string name() const { return name_; }
 std::string phone() const { return phone_; }
 void setName(const std::string& name) { name_ = name; }
 void setPhone(const std::string& phone) {
  using namespace std;
  using namespace boost;
  // Используйте Boost.Regex, чтобы убедиться, что телефон
  // задач в форме (ddd)ddd-dddd
  static regex pattern("\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}");
  if (!regex_match(phone, pattern)) {
   throw runtime_error(string("bad phone number:") + phone);
  }
  phone_ = phone;
 }
private:
 std::string name_;
 std::string phone_;
};
// Сравнить на равенство два объекта класса Contact; используется в рецепте
// 14.9 (для полноты следует также определить operator!=)
bool operator--(const Contact& lhs, const Contact& rhs) {
 return lhs.name() == rhs.name() && lhs.phone() == rhs.phone();
}
// Записывает объект класса Contact в поток ostream
std::ostream& operator(std::ostream& out, const Contact& contact) {
 out << contact.name() << " " << contact.phone(); return out;
}
// Класс Animal представляет животное
class Animal {
public:
 // Конструктор по умолчанию класса Animal; этот конструктор будет вами
 // использоваться чаще всего Animal() {}
 // Конструирование объекта Animal с указанием свойств животного;
 // этот конструктор будет использован в рецепте 14.9
 Animal(const std::string& name,
  const std::string& species, const std::string& dob,
  const Contact& vet, const Contact& trainer) :
  name_(name), species_(species), vet_(vet), trainer_(trainer) {
   setDateOfBirth(dob)
  }
 // Функции доступа к свойствам животного
 std::string name() const { return name_; }
 std::string species() const { return species_; }
 boost::gregorian::date dateOfBirth() const { return dob_; )
 Contact veterinarian() const { return vet_; }
 Contact trainer() const { return trainer_; }
 // Функции задания свойств животного
 void setName(const std::string& name) { name_ = name; }
 void setSpecies(const std::string& species) { species_ = species; }
 void setDateOfBirth(const std::string& dob) {
  dob_ = boost::gregorian::from_string(dob);
 }
 void setVeterinarian(const Contact& vet) { vet_ = vet; }
 void setTrainer(const Contact& trainer) { trainer_ = trainer; }
private:
 std::string name_;
 std::string species_;
 boost::gregorian::date dob_;
 Contact vet_;
 Contact trainer_;
};
// Сравнение на равенство двух объектов Animal; используется в рецепте 14.9
// (для полноты следует также определить operator!=)
bool operator==(const Animal& lhs, const Animal& rhs) {
 return lhs.name() == rhs.name() && lhs.species() == rhs.species() &&
  lhs.dateOfBirth() == rhs.dateOfBirth() &&
  lhs.veterinarian() == rhs.veterinarian() &&
  lhs.trainer() == rhs.trainer();
}
// Записывает объект Animal в поток ostream
std::ostream& operator<<(std::ostream& out, const Animal& animal) {
 out << "Animal {\n"
  << " name=" << animal.name() << ";\n"
  << " species=" << animal.species() << ";\n"
  << date-of-birth=" << animal.dateOfBirth() << ";\n"
  << " veterinarian=" << animal.veterinarian() << ";\n"
  << " trainer=" << animal.trainer() << ";\n"
  << "}";
 return out;
}
#endif // #ifndef ANIMALS_HPP_INCLUDED
Пример 14.3. Синтаксический анализ animals.xml с помощью TinyXml
#include <exception>
#include <iostream>  // cout
#include <stdexcept> // runtime_error
#include <cstdlib>   // EXIT_FAILURE
#include <cstring>   // strcmp
#include <vector>
#include <tinyxml.h>
#include "animal.hpp"
using namespace std;
// Извлекает текстовое содержимое элемента XML
const char* textValue("TiXmlElement* e) {
 TiXmlNode* first = fi->FirstChild();
 if (first != 0 && first == e->LastChild() &&
  first->Type() == TiXmlNode::TEXT) {
  // элемент «е» имеет один дочерний элемент типа TEXT;
  // возвратить дочерний элемент
  return first->Value();
 } else {
  throw runtime_error(string("bad ") + e->Value() + " element");
 }
}
// Конструирует объект класса Contact из элементов ветеринара или
// дрессировщика ("veterinarian" или "trainer")
Contact nodeToContact(TiXmlElement* contact) {
 using namespace std;
 const char *name, *phone;
 if (contact->FirstChild() == 0 &&
  (name = contact->Attribute("name")) &&
  (phone = contact->Attribute("phone"))) {
  // Элемент contact не имеет дочерних элементов и имеет атрибуты имени
  // и телефона ("name" и "phone"); используйте эти значения для
  // конструирования объекта Contact
  return Contact(name, phone);
 } else {
  throw runtime_error(string("bad ") + contact->Value() + " element");
 }
}
// Конструирует объект Animal из элемента животного ("animal")
Animal nodeToAnimal(TiXmlElement* animal) {
 using namespace std;
 // Убедиться, что animal соответствует элементу "animal"
 if (strcmp(animal->Value(), "animal") != 0) {
  throw runtime_error(string("bad animal: ") + animal->Value());
 }
 Animal result; // Возвратить значение
 TiXmlElement* element = animal->FirstChildElement();
 // Прочитать элемент клички животного
 if (element && strcmp(element->Value(), "name") == 0) {
  // Первым дочерним элементом объекта animal является кличка (элемент
  // name"); используйте ее текстовое значение для установки клички
  // в объекте result
  result.setName(textValue(element));
 } else {
  throw runtime_error("no name attribute");
 }
 // Прочитать элемент вида животного
 element = element->NextSiblingElement();
 if (element && strcmp(element->Value(), species") == 0) {
  // Вторым дочерним элементом animal является вид животного
  // (элемент "species"); используйте его текстовое значение для
  // установки вида в объекте result
  result.setSpecies(textValue(element));
 } else {
  throw runtime_error(""no species attribute");
 }
 // Прочитать элемент даты рождения
 element = element->NextSiblingElement();
 if (element && strcmp(element->Value(), "dateOfBirth") == 0) {
  // Третьим дочерним элементом animal является дата рождения
  // (элемент "dateOfBirth"));
  // используйте его текстовое значение для установки даты
  // рождения в объекте result
  result.setDateOfBirth(textValue(element));
 } else {
  throw runtime_error("no dateOfBirth attribute");
 }
 // Прочитать элемент ветеринара
 element = element->NextSiblingElement();
 if (strcmp(element->Value(), "veterinarian") == 0) {
  // Четвертым дочерним элементом animal является ветеринар (элемент
  // "veterinarian"); используйте его для конструирования объекта
  // Contact и установки имени ветеринара в объекте result
  result.setVeterinarian(nodeToContact(element));
 } else {
  throw runtime_error("no veterinarian attribute");
 }
 // Прочитать элемент дрессировщика
 element = element->NextSiblingElement();
 if (strcmp(element->Value(), "trainer") == 0) {
  // Пятым элементом animal является дрессировщик (элемент "trainer");
  // используйте его для конструирования объекта
  // Contact и установки дрессировщика в объекте result
  result.setTrainer(nodeToContact(element));
 } else {
  throw runtime_error("no trainer attribute");
 }
 // Убедиться в отсутствии других дочерних элементов
 element = element->NextSiblingElement();
 if (element != 0) {
  throw runtime_error(
   string("unexpected element:") + element->Value()
  );
 }
 return result;
}
int main() {
 using namespace std;
 try {
  vector<Animal> animalList;
  // Обработать "animals.xml"
  TiXmlDocument doc("animals.xml");
  if (!doc.LoadFile())
   throw runtime_error("bad parse");
  // Убедиться, что корневым является список животных
  TiXmlElement* root = doc.RootElement();
  if (strcmp(root->Value(), "animalList") != 0) {
   throw runtime_error(string("bad root: ") + root->Value());
  }
  // Просмотреть все дочерние элементы корневого элемента, заполняя
  // список животных
  for (TiXmlElement* animal = root->FirstChildElement();
   animal; animal = animal->NextSiblingElement()) {
   animalList.push_back(nodeToAnimal(animal));
  }
  // Напечатать клички животных
  for (vector<Animal>::size_type i = 0, n = animalList.size(); i < n; ++i) {
   cout << animalList[i] << "\n";
  }
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
TinyXml (буквально «крошечный XML») очень хорошо подходит в тех случаях, когда требуется выполнять несложную обработку документов XML. Дистрибутив исходных текстов этой библиотеки небольшой, ее легко построить и интегрировать в проекты, и она имеет очень простой интерфейс. Она также имеет очень либеральную лицензию. Главными ограничениями TinyXml являются невосприимчивость к пространствам имен XML, невозможность контроля DTD или схемы, а также невозможность анализа документов XML с внутренним DTD. Если вам требуется какая-то из этих функций или какая-нибудь XML-технология, как, например, XPath или XSLT, то необходимо воспользоваться другими библиотеками, рассмотренными в данной главе.
На выходе парсера TinyXml получается документ XML в виде дерева, узлы которого представляют элементы, текст, комментарии и другие компоненты документа XML. Корень дерева представляет собственно документ XML. Такое иерархическое представление документа называется объектной моделью документа (Document Object Model - DOM). Модель DOM, полученная парсером TinyXml, аналогична модели, разработанной консорциумом W3C (World Wide Web Consortium), хотя она и не полностью соответствует спецификации W3C. Вследствие приверженности библиотеки TinyXml принципам минимализма модель TinyXml DOM проще W3С DOM, однако она обладает меньшими возможностями.
Получить доступ к узлам дерева, представляющего документ XML, можно с помощью интерфейса TiXmlNode, который содержит методы, обеспечивающие доступ к родительскому узлу, последовательный доступ ко всем дочерним узлам, удаление и добавление дочерних узлов. Каждый узел является экземпляром некоторого производного типа; например, корень дерева является экземпляром TiXmlDocument, узлы элементов являются экземплярами TiXmlElement, а узлы, представляющие текст, являются экземплярами TiXmlText. Тип TiXmlNode можно определить с помощью его метода Туре(); зная тип узла, вы можете получить конкретное его представление с помощью таких методов, как toDocument(), toElement() и toText(). Эти производные типы содержат дополнительные методы, характерные для узлов конкретного типа.
Теперь несложно разобраться с примером 14.3. Во-первых, функция textValue() извлекает текстовое содержимое из элементов, содержащих только текст, например name, species или dateOfBirth. В этом случае данная функция сначала убеждается, что имеется только один дочерний элемент и что он является текстовым узлом. Она затем получает текст дочернего элемента, вызывая метод Value(), который возвращает текстовое содержимое текстового узла или узла комментария, имя тега узла элемента и имя файла корневого узла.
На следующем шаге функция nodeToContact() получает узел, соответствующий элементу veterinarian или trainer, и конструирует объект Contact из значений атрибутов name и phone, получаемых с помощью метода Attribute().
Аналогично функция nodeToAnimal() получает узел, соответствующий элементу животного element, и конструирует объект Animal. Это делается путем прохода по дочерним узлам с помощью метода NextSiblingElement(), извлекая при этом содержащиеся в каждом элементе данные и устанавливая соответствующее свойство объекта Animal. Данные извлекаются, используя функцию textValue() для элементов name, species и dateOfBirth и функцию nodeToContact() для элементов veterinarian и trainer.
В функции main я сначала конструирую объект TiXmlDocument соответствующий файлу animals.xml, и выполняю его синтаксический разбор с помощью метода LoadFile(). Затем я получаю элемент TiXmlElement, соответствующий корню документа, вызывая метод RootElement(). На следующем шаге я просматриваю все дочерние узлы корневого элемента, конструируя объект Animal из каждого элемента animal с помощью функции nodeToAnimal(). Наконец, я прохожу по всем объектам Animal, записывая их в стандартный вывод.
В примере 14.3 не проиллюстрирована одна функция библиотеки TinyXml, а именно метод SaveFile() класса TiXmlDocument, который записывает в файл документ, представляемый объектом TiXmlDocument. Это позволяет выполнить синтаксический разбор документа XML, модифицировать его, используя интерфейс DOM, и сохранить модифицированный документ. Документ TiXmlDocument можно создать даже с чистого листа и затем сохранить его на диске.
// Создать документ hello.xml, состоящий
// из единственного элемента "hello"
TiXmlDocument doc;
TiXmlElement root("hello");
doc.InsertEndChild(root);
doc.SaveFile("hello.xml");
Смотри также
Рецепты 14.3 и 14.4.
14.2. Работа со строками Xerces
Проблема
Требуется обеспечить надежную и простую работу со строками с расширенным набором символов, используемыми библиотекой Xerces. В частности, необходимо уметь сохранять строки, возвращаемые функциями библиотеки Xerces, а также выполнять преобразования между строками Xerces и строками стандартной библиотеки С++.
Решение
Сохранять строки с расширенным набором символов, возвращаемые функциями библиотеки Xerces, можно с помощью шаблона std::basic_string, специализированного типом с расширенным набором символов XMLCh библиотеки Xerces.
typedef std::basic_string<XMLCh> XercesString;
Для выполнения преобразований между строками Xerces и строками, состоящими из стандартных символов, используйте перегруженный статический метод transcode() из класса xercesc::XMLString, который определен в заголовочном файле xercesc/util/XMLString.hpp.
В примере 14.4 определяются две перегруженные вспомогательные функции, toNative и fromNative, которые используют transcode для преобразования строк со стандартными символами в строки Xerces и обратно. Каждая функция имеет две версии: одна принимает строку в C-стиле, а другая принимает строку стандартной библиотеки С++. Для выполнения преобразований между строками Xerces и строками со стандартными символами вполне достаточно иметь эти служебные функции; после того как вы определили эти функции, вам уже никогда не потребуется вызывать непосредственно transcode.
Пример 14.4. Заголовочный файл xerces_strings.hpp, используемый для выполнения преобразований между строками Xerces и строками со стандартными символами
#ifndef XERCES_STRINGS_HPP_INCLUDED
#define XERCES_STRINGS_HPP_INCLUDED
#include <string>
#include <boost/scoped_array.hpp>
#include <xercesc/util/XMLString.hpp>
typedef std::basic_string<XMLCh> XercesString;
// Преобразует строку со стандартными символами
// в строку с расширенным набором символов
inline XercesString fromNative(const char* str) {
boost::scoped_array<XMLCh> ptr(xercesc::XMLString::transcode(str));
 return XercesString(ptr.get());
}
// Преобразует строку со стандартными символами
// в строку с расширенным набором символов.
inline XercesString fromNative(const std::string& str) {
 return fromNative(str.c_str());
}
// Преобразует строку с расширенным набором символов
// в строку со стандартными символами.
inline std::string toNative(const XMLCh* str) {
boost::scoped_array<char> ptr(xercesc::XMLString::transcode(str));
 return std::string(ptr.get());
}
// Преобразует строку с расширенным набором символов в строку со стандартными символами.
inline std::string toNative(const XercesString& str) {
 return toNative(str.c_str());
}
#endif // #ifndef XERCES_STRINGS_HPP_INCLUDED
Для выполнения преобразований между строками Xerces и std::wstring просто используйте конструктор std::basic_string, передавая ему два итератора. Например, можно определить следующие две функции.
// Преобразует строку Xerces в строку std::wstring
std::wstring xercesToWstring(const XercesString& str) {
 return std::wstring(str.begin(), str.end());
}
// Преобразует строку std::wstring в строку XercesString
XercesString wstringToXerces(const std::wstring& str) {
 return XercesString(str.begin(), str.end());
}
В этих функциях используется тот факт, что wchar_t и XMLCh являются интегральными типами, каждый из которых может неявно преобразовываться в другой; это должно работать независимо от размера wchar_t, пока не используются значения, выходящие за диапазон XMLCh. Вы можете определить подобные функции, принимающие в качестве аргументов строки в C-стиле, используя конструктор std::basic::string, которому передаются в качестве аргументов массив символов и длина.
Обсуждение
Для представления строк в коде Unicode библиотека Xerces использует последовательности символов XMLCh, завершаемые нулем. Тип XMLCh вводится с помощью typedef как интегральный тип, зависящий от реализации и содержащий не менее 16 бит, которых достаточно для представления символов почти любого языка. Xerces применяет символьную кодировку UTF-16, что подразумевает теоретическую возможность представления некоторых символов в коде Unicode в виде последовательности из нескольких символов XMLCh; однако практически можно считать, что каждый символ XMLCh непосредственно представляет один символ в коде Unicode, т.е. имеет числовое значение символа Unicode.
Одно время тип XMLCh определялся с помощью typedef как wchar_t, что позволяло легко сохранять копию строки Xerces как std::wstring. Однако в настоящее время Xerces определяет XMLCh на всех платформах с помощью typedef как unsigned short. Кроме всего прочего это означает, что на некоторых платформах типы XMLCh и wchar_t имеют разный размер. Поскольку Xerces может изменить в будущем определение XMLCh, нельзя рассчитывать на то, что XMLCh будет идентичен какому-то конкретному типу. Поэтому, если требуется сохранить копию строки Xerces, следует использовать тип std::basic_string<XMLCh>.
При использовании Xerces вам придется часто выполнять преобразования между строками со стандартными символами и строками Xerces; для этой цели в Xerces предусмотрена перегруженная функция transcode(). transcode() может преобразовать строку Unicode в строку со стандартными символами, использующую «родную» кодировку символов, или строку с «родной» кодировкой со стандартными символами в строку Unicode. Однако смысл родной кодировки точно не определен, поэтому если вы программируете в среде, в которой часто используется несколько кодировок символов, то вам придется все взять в свои руки и выполнять преобразования особым образом, используя либо фасет std::codecvt, либо подключаемые службы перекодировки (pluggable transcoding services) библиотеки Xerces, описанные в документации Xerces. Однако во многих случаях вполне достаточно использовать transcode().
Память под возвращаемые функцией transcode() строки, завершающиеся нулем, динамически выделяется при помощи оператора new в форме массива; вам придется строку удалять самому, используя оператор delete[]. Это создает небольшую проблему управления памяти, поскольку обычно требуется копировать строку или записывать ее в поток до ее удаления, а эти операции могут выбросить исключение. Я решаю эту проблему в примере 14.4 с помощью шаблона boost::scoped_array, который динамически выделяет память под массив и автоматически удаляет его при выходе из области видимости, даже если выбрасывается исключение. Например, рассмотрим реализацию функции fromNative.
inline XercesString fromNative(const char* str) {
 boost::scoped_array<XMLCh> ptr(xercesc::XMLString::transcode(str));
 return XercesString(ptr.get());
}
Здесь ptr становится обладателем возвращенной функцией transcode() строки с нулевым завершающим символом и освобождает ее, даже если конструктор XercesString выбрасывает исключение std::bad_alloc.
14.3. Синтаксический анализ сложного документа XML
Проблема
Имеется некоторый набор данных, хранимых в документе XML, внутри которого используется DTD или применяются пространства имен XML. Требуется выполнить синтаксический анализ документа и превратить содержащиеся в нем данные в набор объектов C++.
Решение
Используйте реализацию Xerces в виде программного интерфейса SAX2 (простой программный интерфейс для XML, версия 2.0). Во-первых, создайте класс, производный от xercesc::ContentHandler; этот класс будет получать уведомления с информацией о структуре и содержимом вашего документа XML по мере его анализа. Затем при желании можно создать класс, производный от xercesc::ErrorHandler, для получения предупреждений и сообщений об ошибках. Сконструируйте парсер типа xercesc::SAX2XMLReader, зарегистрируйте экземпляры классов вашего обработчика, используя методы парсера setContentHandler() и setErrorHandler(). Наконец, вызовите метод парсера parse(), передавая в качестве аргумента полное имя файла, в котором содержится ваш документ.
Например, пусть требуется выполнить синтаксический анализ документа XML animals.xml, приведенного в примере 14.1, и сконструировать вектор std::vector объектов Animal, представляющих животных, перечисленных в этом документе. (Определение класса Animal дается в примере 14.2.) В примере 14.3 я показываю, как можно это сделать, используя TinyXml. Для усложнения задачи добавим в документ пространства имен, как показано в примере 14.5.
Пример 14.5. Список цирковых животных, в котором используются пространства имен XML
<?xml version="1.0" encoding="UTF-8"?>
<!- Животные цирка Feldman Family Circus с использованием пространств имен -->
<ffc:animalList xmlns:ffc="http://www.feldman-family-circus.com">
 <ffc:animal>
  <ffc:name>Herby</ffc:name>
  <ffc:species>elephant</ffc:species>
  <ffc:dateOfBirth>1992-04-23</ffc:dateOfBirth>
  <ffc:veterinarian name="Dr. Hal Brown" phone="(801)595-9627"/>
  <ffc:trainer name="Bob Fisk" phone="(801)881-2260"/>
 </ffc:animal>
 <!- и т.д. -->
</ffc:animalList>
Для анализа этого документа с помощью SAX2 определите ContentHandler, как показано в примере 14.6, и ErrorHandler, как показано в примере 14.7. Затем сконструируйте SAX2XMLReader, зарегистрируйте ваши обработчики и запустите парсер. Это проиллюстрировано в примере 14.8.
Пример 14.6. Применение SAX2 ContentHandler для синтаксического анализа документа animals.xml
#include <stdexcept> // runtime_error
#include <vector>
#include <xercesc/sax2/Attributes.hpp>
#include <xercesc/sax2/DefaultHandler.hpp> // Содержит реализации без
                                           // операций для различных
                                           // обработчиков, используемых
#include "xerces_strings.hpp"              // в примере 14.4
#include "animal.hpp"
using namespace std;
using namespace xercesc;
// Возвращает экземпляр Contact, построенный
// на основе заданного набора атрибутов
Contact contactFromAttributes(const Attributes &attrs) {
 // Для повышения эффективности хранить часто используемые строки
 // в статических переменных
 static XercesString name = fromNative("name");
 static XercesString phone = fromNative("phone");
 Contact result;   // Возвращаемый объект Contact.
 const XMLCh* val; // Значение атрибута name или phone.
 // Установить имя объекта Contact.
 if ((val = attrs.getValue(name.c_str())) != 0) {
  result.setName(toNative(val));
 } else {
  throw runtime_error("contact missing name attribute");
 }
 // Установить номер телефона для объекта Contact.
 if ((val = attrs.getValue(phone.c_str())) != 0) {
  result.setPhone(toNative(val));
 } else {
  throw runtime_error("contact missing phone attribute");
 }
 return result;
}
// Реализует обратные вызовы, которые получают символьные данные и
// уведомления о начале и конце элементов
class CircusContentHandler : public DefaultHandler {
public:
 CircusContentHandler(vector<Animal>& animalList) :
  animalList_(animalList) {}
 // Если текущий элемент представляет ветеринара или дрессировщика
 // используйте attrs для конструирования объекта Contact для текущего
 // Animal; в противном случае очистите currentText_, подготавливая
 // обратный вызов characters()
 void startElement(
  const XMLCh *const uri,       // URI пространства имен
  const XMLCh *const localname, // имя тега без префикса NS
  const XMLCh *const qname,     // имя тега + префикс NS
  const Attributes &attrs)      // атрибуты элементов
 {
  static XercesString animalList = fromNative("animalList");
  static XercesString animal = fromNative("animal");
  static XercesString vet = fromNative("veterinarian");
  static XercesString trainer = fromNative("trainer");
  static XercesString xmlns =
   fromNative("http://www.feldman-family-circus.com");
  // проверить URI пространства имен
  if (uri != xmlns)
   throw runtime_error(
    string("wrong namespace uri ") + toNative(uri)
   );
  if (localname == animal) {
   // Добавить в список объект Animal; это будет
   // "текущий объект Animal"
   animalList_.push_back(Animal());
  } else if (localname != animalList) {
   Animal& animal = animalList_.back();
   if (localname == vet) {
    // Мы встретили элемент "ветеринар".
    animal.setVeterinarian(contactFromAttributes(attrs));
   } else if (localname == trainer) {
    // Мы встретили элемент "дрессировщик".
    animal.setTrainer(contactFromAttributes(attrs));
   } else {
    // Мы встретили элемент "кличка", "вид животного" или
    // "дата рождения". Их содержимое будет получено
    // при обратном вызове функции characters().
    currentText_.clear();
   }
  }
 }
 // Если текущий элемент представляет кличку, вид животного или дату
 // рождения, используйте хранимый в currentText_ текст для установки
 // соответствующего свойства текущего объекта Animal.
 void endElement(
  const XMLCh *const uri,       // URI пространства имен
  const XMLCh *const localname, // имя тега без префикса NS
  const XMLCh *const qname)     // имя тега + префикс NS
 {
  static XercesString animalList = fromNative("animal-list");
  static XercesString animal = fromNative("animal");
  static XercesString name = fromNative("name");
  static XercesString species = fromNative("species");
  static XercesString dob = fromNative("dateOfBirth");
  if (localname!= animal && localname!= animalList) {
   // currentText_ содержит текст элемента, который был
   // добавлен. Используйте его для установки свойств текущего
   // объекта Animal.
   Animal& animal = animalList_.back();
   if (localname == name) {
    animal setName(toNative(currentText_));
   } else if (localname == species) {
    animal.setSpecies(toNative(currentText_));
   } else if (localname == dob) {
    animal.setDateOfBirth(toNative(currentText_));
   }
  }
 }
 // Получает уведомления, когда встречаются символьные данные
 void characters(const XMLCh* const chars,
  const unsigned int length) {
  // Добавить символы в конец currentText_ для обработки методом
  // endElement()
  currentText_.append(chars, length);
 }
private:
 vector<Animal>& animalList_;
 XercesString currentText_;
};
Пример 14.7. SAX2 ErrorHandler
#include <stdexcept> // runtime_error
#include <xercesc/sax2/DefaultHandler.hpp>
// Получает уведомления об ошибках.
class CircusErrorHandler : public DefaultHandler {
public:
 void warning(const SAXParseException& e) {
  /* нет действий */
 }
 void error(const SAXParseExceptionf& e) {
  throw runtime_error(toNative(e.getMessage()));
 }
 void fatalError(const SAXParseException& e) { error(e); }
};
Пример 14.8. Синтаксический анализ документа animals.xml при помощи программного интерфейса SAX2
#include <exception>
#include <iostream> // cout
#include <memory>   // auto_ptr
#include <vector>
#include <xercesc/sax2/SAX2XMLReader.hpp>
#include <xercesc/sax2/XMLReaderFactory.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include "animal.hpp"
#include "xerces_strings.hpp" // Пример 14.4
using namespace std;
using namespace xercesc;
// Утилита RAII инициализирует парсер и освобождает ресурсы
// при выходе из области видимости
class XercesInitializer {
public:
 XercesInitializer() { XMLPlatformUtils::Initialize(); }
 ~XercesInitializer() { XMLPlatformUtils::Terminate(); }
private:
 // Запретить копирование и присваивание
 XercesInitializer(const XercesInitializer&);
 XercesInitializer& operator=(const XercesInitializer&);
};
int main() {
 try {
  vector<Animal> animalList;
  // Инициализировать Xerces и получить парсер
  XercesInitializer init;
  auto_ptr<SAX2XMLReader>
   parser(XMLReaderFactory::createXMLReader());
  // Зарегистрировать обработчики
  CircusContentHandler content(animalList);
  CircusErrorHandler error;
  parser->setContentHandler(&content);
  parser->setErrorHandler(&error);
  // Выполнить синтаксический анализ документа XML
  parser->parse("animals.xml");
  // Напечатать клички животных
  for (vector<Animal>::size_type i = 0;
   n = animalList.size(); i < n; ++i) {
   cout << animalList[i] << "\n";
  }
 } catch (const SAXException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const XMLException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
Некоторые парсеры XML выполняют синтаксический анализ документа XML и возвращают его пользователю в виде сложного объекта С++. Именно это делает парсер TinyXml и парсер W3C DOM, который будет рассмотрен в следующем рецепте. В отличие от них парсер SAX2 использует ряд функций обратного вызова для передачи пользователю информации о документе XML по ходу его анализа. Функции обратного вызова сгруппированы в несколько интерфейсов обработчиков: ContentHandler получает уведомления об элементах, атрибутах и о тексте документа XML, ErrorHandler получает предупреждения и сообщения об ошибках, a DTDHandler получает уведомления о DTD документа XML.
Проектирование парсера, использующего функции обратного вызова, имеет несколько важных преимуществ. Например, можно выполнять синтаксический анализ очень больших документов, которые не помещаются в памяти. Кроме того, это может сэкономить процессорное время, потому что не надо выполнять многочисленные операции динамического выделения памяти, необходимые для конструирования узлов внутреннего представления документа XML, и потому что пользователь может создавать свое представление данных документа непосредственно, а не во время прохождения дерева документа, как я это делал в примере 14.3.
Пример 14.8 достаточно простой: я получаю парсер SAX2, регистрирую ContentHandler и ErrorHandler, анализирую документ animals.xml и печатаю список объектов Animal, заполненный обработчиком ContentHandler. Следует отметить два интересных момента: во-первых, функция XMLReaderFactory::createXMLReader() возвращает экземпляр SAX2XMLReader, память под который выделяется динамически и должна освобождаться пользователем в явной форме; для этой цели я использую std::auto_ptr, чтобы обеспечить удаление парсера даже в случае возникновения исключения. Во-вторых, среда Xerces должна быть инициализирована, используя xercesc::XMLPlatformUtils::Initialize(), и очищена при помощи xercesc::XMLPlatformUtils::Terminate(). Я инкапсулирую эту инициализацию и очистку в классе XercesInitializer, который вызывает XMLPlatformUtils::Initialize() в своем конструкторе и XMLPlatformUtils::Terminate() в своем деструкторе. Это гарантирует вызов Terminate(), даже если выбрасывается исключение. Это пример метода захвата ресурса при инициализации (Resource Acquisition Is Initialization — RAII), который был продемонстрирован в примере 8.3.
Давайте теперь посмотрим, как класс CircusContentHandler из примера 14.6 реализует интерфейс SAX2 ContentHandler. Парсер SAX 2 вызывает метод startElement() при каждой встрече открывающего тега элемента. Если элементу приписано пространство имен, первый аргумент, uri, будет содержать URI пространства имен элемента, а второй аргумент, localname, будет содержать ту часть имени тега элемента, которая идет за префиксом пространства имен. Если элемент не имеет пространства имен, эти два аргумента будут иметь пустые строки. Третий аргумент содержит имя тега элемента, если с элементом не связывается пространство имен; в противном случае этот аргумент может содержать либо имя тега элемента в том виде, в каком оно встречается в анализируемом документе, либо пустую строку. Четвертым аргументом является экземпляр класса Attributes, представляющего набор атрибутов элемента.
В приведенной в примере 14.6 реализации startElement() я игнорирую элемент animalList. Когда я встречаю элемент animal, я добавляю новый объект Animal в список животных; назовем его текущим объектом Animal и предоставим право установки свойств этого Animal обработчикам других элементов. Когда я встречаю элемент veterinarian или trainer, я вызываю функцию contactFromAttributes для конструирования экземпляра Contact из набора атрибутов элемента и затем использую этот объект Contact для установки свойств ветеринара и дрессировщика в текущем элементе Animal. Когда я встречаю элемент name, species или dateOfBirth, я очищаю переменную-член currentText_, которая будет использоваться для хранения текстового содержимого этого элемента.
Парсер SAX2 вызывает метод characters() для передачи символьных данных, содержащихся в элементе. Этот парсер может передавать символы элемента с помощью нескольких вызовов метода characters(); пока не встретится закрывающий тег, нельзя быть уверенным в передаче всех символьных данных. Поэтому в реализации characters() я просто добавляю полученные символы в конец переменной-члена currentText_, которую я использую для установки клички, вида и даты рождения Animal сразу после встречи закрывающего тега для элемента name, species или dateOfBirth.
Парсер SAX2 вызывает метод endElement() при выходе из каждого элемента. Его аргументы имеют тот же смысл, который имеют первые три аргумента метода startElement(). В реализации endElement(), приведенной в примере 14.6, я игнорирую все элементы, отличные от name, species и dateOfBirth. Когда происходит обратный вызов, соответствующий одному из этих элементов, сигнализирующий о сделанном только что выходе парсера из элемента, я использую символьные данные, сохраненные в currentText_ для установки клички, вида и даты рождения текущего объекта Animal.
Несколько важных особенностей SAX2 не проиллюстрировано в примерах 14.6, 14.7 и 14.8. Например, класс SAX2XMLReader содержит перегрузку метода parse(), которая принимает в качестве аргумента экземпляр xercesc::InputSource вместо строки в С-стиле. InputSource является абстрактным классом, инкапсулирующим источник символьных данных; конкретные его подклассы, в том числе xercesc::MemBufInputSource и xercesc::URLInputSource, позволяют парсеру SAX2 анализировать документ XML, который находится не в локальной файловой системе.
Более того, интерфейс ContentHandler содержит много дополнительных методов, например startDocument() и endDocument(), которые сигнализируют о начале и конце документа XML, и setLocator(), который позволяет задать объект Locator, отслеживающий текущую позицию анализируемого файла. Существуют также другие интерфейсы обработчиков, включая DTDHandler и EntityResolver (соответствующие базовой спецификации SAX 2.0), а также DeclarationHandler и LexicalHandler (соответствующие стандартизованным расширениям SAX 2.0).
Кроме того, можно в одном классе реализовать несколько интерфейсов обработчиков. Это можно легко сделать в классе xercesc::DefaultHandler, потому что он является производным от всех интерфейсов обработчиков и содержит реализации своих виртуальных функций, в которых не выполняется никаких действий. Следовательно, я мог бы добавить методы из CircusErrorHandler в CircusContentHandler и следующим образом модифицировать пример 14.8.
// Зарегистрировать обработчики
CircusContentHandler handler(animalList);
parser->setContentHandler(&handler);
parser->setErrorHandler(&handler);
Пример 14.8 имеет еще одну, последнюю особенность, которую вы должны были заметить: обработчик CircusContentHandler не проверяет корректность структуры экземпляра анализируемого документа, т.е. не убеждается в том, что корневым является элемент animalList или что все дочерние элементы корня являются элементами animal. Это сильно отличается от примера 14.3. Например, функция main() из примера 14.3 проверяет то, что элементом верхнего уровня является animalList, а функция nodeToAnimal() проверяет то, что ее аргументы представляют элемент animal, содержащий точно пять дочерних элементов типа name, species, dateOfBirth, veterinarian и trainer.
Пример 14.6 можно модифицировать, чтобы он выполнял подобного рода проверки. Например, обработчик ContentHandler в примере 14.9 удостоверяется в том, что корневым элементом документа является animalList и что его дочерние элементы имеют тип animal, а дочерние элементы элемента animal не содержат других элементов. Это можно сделать с помощью трех флагов типа boolean, parsingAnimalList_, parsingAnimal_ и parsingAnimalChild_, которые регистрируют анализируемую в данный момент область документа. Методы startElement() и endElement() просто обновляют эти флаги и проверяют их согласованность, делегируя задачу обновления текущего объекта Animal вспомогательным методам startAnimalChild() и endElementChild(), реализация которых очень напоминает реализацию методов startElement() и endElement() из примера 14.6.
Пример 14.9. Обработчик SAX2 ContentHandler документа animals.xml, который проверяет структуру документа
// Реализует функции обратного вызова, которые получают символьные данные и
// уведомляют о начале и конце элементов
class CircusContentHandler : public DefaultHandler {
public:
 CircusContentHandler(vector<Animal>& animalList)
  : animalList_(animalList), // заполняемый список
  parsingAnimalList_(false), // состояние анализа
  parsingAnimal_(false),     // состояние анализа
  parsingAnimalChild_(false) // состояние анализа
  {}
 // Получает уведомления от парсера при каждой встрече начала
 // какого-нибудь элемента
 void startElement(
  const XMLCh *const uri,       // uri пространства имен
  const XMLCh *const localname, // простое имя тега
  const XMLCh *const qname,     // квалифицированное имя тега
  const Attributes &attrs)      // Набор атрибутов
 {
  static XercesString animalList = fromNative("animalList");
  static XercesString animal = fromNative("animal");
  static XercesString xmlns =
   fromNative("http://www.feldman-family-circus.com");
  // Проверяет uri пространства имен
  if (uri != xmlns)
   throw runtime_error(
    string("wrong namespace uri: ") + toNative(uri)
   );
  // (i)   Обновить флаги parsingAnimalList_, parsingAnimal_
  //       и parsingAnimalChild_, которые показывают, в какой части
  //       документа мы находимся
  // (ii)  Убедиться, что элементы имеют правильную вложенность
  //
  // (iii) Делегировать основную работу методу
  // startAnimalChild()
  if (!parsingAnimalList_) {
   // Мы только что встретили корень документа
   if (localname == animalList) {
    parsingAnimalList_ = true; // Обновить состояние анализа.
   } else {
    // Неправильная вложенность
    throw runtime_error(
     string("expected 'animalList', got ") + toNative(localname)
    );
   }
  } else if (!parsingAnimal_) {
   // Мы только что встретили новое животное
   if (localname == animal) {
    parsingAnimal_ = true; // Обновить состояние
                           // анализа.
    animalList_.push_back(Animal()); // Добавить в список объект
                                     // Animal.
   } else {
    // Неправильная вложенность
    throw runtime error(
     string("expected 'animal', got ") + toNative(localname)
    );
   }
  } else {
   // Вы находимся в середине анализа элемента, описывающего
   // животного.
   if (parsingAnimalChild_) {
    // Неправильная вложенность
    throw runtime_error("bad animal element");
   }
   // Обновить состояние анализа
   parsingAnimalChild_ = true;
   // Пусть startAnimalChild() выполнит реальную работу
   startAnimalChild(uri, localname, qname, attrs);
  }
 }
 void endElement(
  const XMLCh *const uri,       // uri пространства имен
  const XMLCh *const localname, // простое имя тега
  const XMLCh *const qname )    // квалифицированное имя тега
 {
  static XercesString animalList = fromNative("animal-list");
  static XercesString animal = fromNative("animal");
  // Обновить флаги parsingAnimalList, parsingAnimal_
  // и parsingAnimalChild_; делегировать основную работу
  // endAnimalChild()
  if (localname == animal) {
   parsingAnimal_ = false;
  } else if (localname == animalList) {
   parsingAnimalList_ = false;
  } else {
   endAnimalChild(uri, localname, qname);
   parsingAnimalChild_ = false;
  }
 }
 // Получает уведомления о встрече символьных данных
 void characters(const XMLCh* const chars, const unsigned int length) {
  // Добавляет символы в конец currentText_ для обработки методом
  // endAnimalChild()
  currentText.append(chars, length);
 }
private:
 // Если текущий элемент представляет ветеринара или дрессировщика,
 // используйте attrs для конструирования объекта Contact для
 // текущего Animal; в противном случае очистите currentText_,
 // подготавливая обратный вызов characters()
 void startAnimalChild(
  const XMLCh *const uri,       // uri пространства имен
  const XMLCh *const localname, // простое имя тега
  const XMLCh *const qname,     // квалифицированное имя тега
  const Attributes &attrs )     // Набор атрибутов
 {
  static XercesString vet = fromNative("veterinarian");
  static XercesString trainer = fromNative("trainer");
  Animal& animal = animalList_.back();
  if (localname == vet) {
   // Мы встретили элемент "ветеринар".
   animal.setVeterinarian(contactFromAttributes(attrs));
  } else if (localname == trainer) {
   // Мы встретили элемент "дрессировщик".
   animal.setTrainer(contactFromAttributes(attrs));
  } else {
   // Мы встретили элемент "кличка , "вид" или
   // "дата рождения". Его содержимое будет передано функцией
   // обратного вызова characters().
   currentText_.clear();
  }
 }
 // Если текущий элемент представляет кличку, вид или дату рождения,
 // используйте текст, находящийся в currentText_, для установки
 // соответствующего свойства текущего объекта
 Animal. void endAnimalChild(
  const XMLCh *const uri,       // uri пространства имен
  const XMLCh *const localname, // простое имя тега
  const XMLCh *const qname)     // квалифицированное имя тега
 {
  static XercesString name = fromNative("name");
  static XercesString species = fromNative("species");
  static XercesString dob = fromNative("dateOfBirth");
  // currentText_ содержит текст элемента, который только что
  // закончился. Используйте его для установки свойств текущего
  // объекта Animal.
  Animal& animal = animalList_.back();
  if (localname == name) {
   animal.setName(toNative(currentText_));
  } else if (localname == species) {
   animal.setSpecies(toNative(currentText_));
  } else if (localname == dob) {
   animal.setDateOfBirth(toNative(currentText_));
  }
 }
 vector<Animal>& animalList_; // заполняемый список
 bool parsingAnimalList_;     // состояние анализа
 bool parsingAnimal_;         // состояние анализа
 bool parsingAnimalChild_;    // состояние анализа
 XercesString currentText_;   // символьные данные текущего
                              // текстового узла
};
Из сравнения примера 14.9 с примером 14.6 видно, насколько сложным может быть проверка структуры документа с помощью функций обратного вызова. Более того, в примере 14.6 не делается столько проверок, как в примере 14.3: здесь, например, не проверяется порядок следования дочерних элементов элемента животного. К счастью, существует гораздо более простой способ проверки структуры документа с использованием SАХ2, как вы это увидите в рецептах 14.5 и 14.6.
Смотри также
Рецепты 14.1, 14.4, 14.5 и 14.6.
14.4. Манипулирование документом XML
Проблема
Требуется представить документ XML в виде объекта С++, чтобы можно было манипулировать его элементами, атрибутами, текстом, DTD, инструкциями обработки и комментариями
Решение
Используйте реализованную в Xerces модель W3C DOM. Во-первых, используйте класс xercesc::DOMImplementationRegistry для получения экземпляра xercesc::DOMImplementation, затем используйте DOMImplementation для создания экземпляра парсера xercesc::DOMBuilder. На следующем шаге зарегистрируйте экземпляр xercesc::DOMErrorHandler для получения уведомлений об ошибках, обнаруженных в ходе анализа, и вызовите метод парсера parseURI(), передавая в качестве аргумента URI документа XML или полное имя файла. Если анализ документа завершается успешно, метод parseURI возвратит указатель на объект DOMDocument, представляющий документ XML. Затем вы можете использовать функции, определенные в спецификации W3C DOM для просмотра и манипулирования документом.
Обработав документ, вы можете сохранить его в файле, получая DOMWriter из DOMImplementation и вызывая его метод writeNode() с передачей указателя на DOMDocument в качестве аргумента.
Пример 14.10 показывает, как можно использовать DOM для синтаксического анализа документа animals.xml, приведенного в примере 14.1, затем найти и удалить узел, относящийся к слону Herby, и сохранить модифицированный документ.
Пример 14.10. Применение DOM для загрузки, модификации и затем сохранения документа XML
#include <exception>
#include <iostream> // cout
#include <xercesc/dom/DOM.hpp>
#include <xercesc/framework/LocalFileFomatTarget.hpp>
#include <xercesc/sax/SAXException.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include "animal.hpp"
#include "xerces_strings.hpp"
using namespace std;
using namespace xercesc;
/*
 * Определить XercesInitializer, как это сделано в примере 14.8
 */
// Утилита RAII, которая освобождает ресурс при выходе из области видимости.
template<typename T>
class DOMPtr {
public:
 DOMPtr(T* t) : t_(t) {}
 ~DOMPtr() { t_->release(); }
 T* operator->() const { return t_; }
private:
 // запретить копирование и присваивание
 DOMPtr(const DOMPtr&);
 DOMPtr& operator=(const DOMPtr&);
 T* t_;
};
// Сообщает об ошибках, обнаруженных в ходе синтаксического анализа с
// использованием DOMBuilder.
class CircusErrorHandler : public DOMErrorHandler {
public:
 bool handleFrror(const DOMError& e) {
  std::cout << toNative(e.getMessage()) << "\n";
  return false;
 }
};
// Возвращает значение элемента "name", дочернего по отношению к элементу
// "animal".
const XMLCh* getAnimalName(const DOMElement* animal) {
 static XercesString name = fromNative("name");
 // Просмотреть дочерние элементы объекта animal
 DOMNodeList* children = animal->getChildNodes();
 for (size_t i = 0, len = children->getLength(); i < Len; ++i) {
  DOMNode* child = children->item(i);
  if (child->getNodeType() == DOMNode::ELEMENT_NODE &&
   static_cast<DOMElement*>(child)->getTagName() == name) {
   // Мы нашли элемент "name".
   return child->getTextContent();
  }
 }
 return 0;
}
int main() {
 try {
  // Инициализировать Xerces и получить DOMImplementation;
  // указать, что требуется функция загрузки и сохранения (Load and
  // Save - LS)
  XercesInitializer init;
  DOMImplementation* impl =
   DOMImplementationRegistry::getDOMImplementation(fromNative("LS").c_str()
  );
  if (impl == 0) {
   cout << "couldn't create DOM implementation\n";
   return EXIT_FAILURE;
  }
  // Сконструировать DOMBuilder для анализа документа animals.xml.
  DOMPtr<DOMBuilder> parser =
   static_cast<DOMImplementationLS*>(impl)->
    createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0);
  // Подключить пространства имен (они не требуются в этом примере)
  parser->setFeature(XMLUni::fgDOMNamespaces, true);
  // Зарегистрировать обработчик ошибок
  CircusErrorHandler err;
  parser->setErrorHandler(&err);
  // Выполнить синтаксический анализ animals.xml; здесь можно
  // использовать URL вместо имени файла
  DOMDocument* doc =
   parser->parseURI("animals.xml");
  // Найти элемент слона Herby: сначала получить указатель на элемент
  // "animalList".
  DOMElement* animalList = doc->getDocumentElement();
  if (animalList->getTagName() != fromNative("animalList")) {
   cout << "bad document root: "
    << toNative(animalist->getTagName()) << "\n";
   return EXIT_FAILURE;
  }
  // Затем просматривать элементы "animal", пытаясь найти элемент слона
  // Herby.
  DOMNodeList* animals =
   animaIList->getElementsByTagName(fromNative("animal").c_str());
  for (size_t i = 0,
   len = animals->getLength(); i < len; ++i) {
   DOMElement* animal =
    static_cast<DOMElement">(animals->item(i));
   const XMLCh* name = getAnimalName(animal);
   if (name != 0 && name == fromNative("Herby")) {
    // Herby найден - удалить его из документа.
    animalList->removeChild(animal);
    animal->release();
    // необязательный оператор.
    break;
   }
  }
  // Сконструировать DOMWriter для сохранения animals.xml.
  DOMPtr<DOMWriter> writer =
   static cast<DOMImplementationLS*>(impl)->createDOMWriter();
  writer->setErrorHandler(&err);
  // Сохранить animals.xml.
  LocalFileFormatTarget file("animals.xml");
  writer->writeNode(&file, *animalList);
 } catch (const SAXException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const DOMException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
Подобно парсеру TinyXml парсер Xerces DOM на выходе формирует документ XML в виде объекта C++, имеющего структуру дерева, узлы которого представляют компоненты документа. Однако парсер Xerces существенно сложнее: например, в отличие от TinyXml он «понимает» пространства имен XML и может выполнять синтаксический анализ сложных DTD. Этим парсером также формируется гораздо более детальное представление документа XML, включающее инструкции обработки и URI пространств имен, относящиеся к элементам и атрибутам. Очень важно то, что он предоставляет доступ к информации через интерфейс, описанный в спецификации W3C DOM.
Спецификация W3C, которая все еще дорабатывается, имеет несколько «уровней»; в настоящее время предусматривается три уровня. Классы DOMImplementation, DOMDocument, DOMElement и DOMNodeList, использованные в примере 14.10, описываются на уровне 1 спецификации DOM. Классы DOMBuilder и DOMWrite описываются на уровне 3 спецификации DOM как часть рекомендаций по функции загрузки и сохранения (Load и Save).
Имена классов Xerces не всегда совладают с именами интерфейсов W3C DOM, которые они реализуют; это происходит из-за того, что Xerces реализует несколько спецификаций в одном пространстве имен и использует префиксы в именах классов, чтобы избежать конфликтов имен.
Понимание примера 14.10 теперь не должно вызывать затруднений. Я начинаю с инициализации Xerces, как это делается в примере 14.8. Затем я получаю DOMImplementation из DOMImplementationRegistry, запрашивая функцию загрузки и сохранения путем передачи строки «LS» статическому методу DOMImplementationRegistry::getDOMImplementation(). На следующем шаге я получаю DOMBuilder из DOMImplementation. Мне приходится тип DOMImplementation привести к типу DOMImplementationLS, потому что функция загрузки и сохранения недоступна из интерфейса DOMImplementation согласно спецификации W3C DOM уровня 1. Первый аргумент createDOMBuilder() показывает, что возвращаемый парсер будет работать в синхронном режиме. Другой возможный режим, а именно асинхронный режим, в настоящее время не поддерживается в Xerces.
Получив DOMBuilder, я включаю поддержку пространства имен XML, регистрирую обработчик ErrorHandler и выполняю синтаксический анализ документа. Парсер возвращает документ в виде DOMDocument; используя метод getElementsByTagName() документа DOMDocument, я получаю объект DOMElement, соответствующий элементу этого документа animalList, и просматриваю его дочерние элементы, используя объект типа DOMNodeList. Когда я нахожу элемент, имеющий дочерний элемент типа name и содержащий текст «Herby», я удаляю его из документа с помощью вызова метода корневого элемента removeChild().
Подобно тому как SAX2XMLReader имеет метод parse(), принимающий экземпляр InputSource, DOMBuilder имеет метол parse(), принимающий экземпляр xercesc::DOMInputSource (т.е. экземпляр абстрактного класса, который инкапсулирует источник символьных данных). В DOMInputSource предусмотрен конкретный подкласс Wrapper4DOMInputSource, который может быть использован для преобразования произвольного InputSource в xercesc::DOMInputSource. См рецепт 14.3.
Наконец, я получаю объект DOMWriter из DOMImplementation (причем делаю это во многом точно так же, как при получении объекта DOMBuilder) и сохраняю модифицированный документ XML на диск, вызывая его метод writeNode(), передавая в качестве аргумента корневой элемент документа.
Вы должны освободить указатели, возвращаемые методами с именами вида DOMImplementation::createXXX(), путем вызова метода release(). Используйте утилиту DOMPtr из примера 14.10 для того, чтобы гарантировать освобождение такого указателя, даже если выбрасывается исключение. Необязательно явно удалять указатели, возвращаемые методами, имена которых имеют вид DOMDocument::createXXX(), хотя это можно делать, если они больше не нужны. Дополнительные сведения вы найдете в документации Xerces.
14.5. Проверка документа XML на соответствие определению DTD
Проблема
Требуется проверить документ XML на соответствие DTD.
Решение
Используйте библиотеку Xerces с парсером SAX2 (простой программный XML-интерфейс) или с парсером DOM.
Для проверки документа XML при использовании SAX2 получите SAX2XMLReader, как показано в примере 14.8. Затем включите режим проверки DTD, вызывая метод парсера setFeature() с аргументами xercesc::XMLUni::fgSAX2CoreValidation и true. Наконец, зарегистрируйте обработчик ErrorHandler для получения уведомлений о нарушении DTD и вызовите метод парсера parse(), указывая в качестве его аргумента имя вашего документа XML.
Для проверки документа XML при использовании парсера DOM сначала сконструируйте экземпляр XercesDOMParser. Затем включите режим проверки DTD, вызывая метод парсера setValidationScheme() с аргументом xercesc::XercesDOMParser::Val_Always. Наконец, зарегистрируйте обработчик ErrorHandler для получения уведомлений о нарушении DTD и вызовите метод парсера parse(), указывая в качестве его аргумента имя вашего документа XML.
Здесь я использую класс XercesDOMParser, т.е. XML-парсер, который входил в состав Xerces еще до того, как был разработан интерфейс DOMBuilder — парсера DOM уровня 3. Применение XercesDOMParser позволяет немного упростить пример, но при желании вы можете вместо него использовать DOMBuilder. См. обсуждение этого рецепта и рецепт 14.4.
Для примера предположим, что вы модифицируете документ XML animals.xml из примера 14.1 для того, чтобы он содержал ссылку на внешнее определение DTD, как показано в примерах 14.11 и 14.12. Программный код, выполняющий проверку документа с использованием программного интерфейса SAX2, приводится в примере 14.13; программный код, выполняющий проверку этого документа с использованием парсера DOM, приводится в примере 14.14.
Пример 14.11. DTD animals.dtd для файла animals.xml
<!-- DTD для животных цирка Feldman Family Circus -->
<!ELEMENT animalList (animal+)>
<!ELEMENT animal (name, species, dateOfBirth,
                  veterinarian, trainer) >
<!ELEMENT name (#PCDATA)>
<!ELEMENT species (#PCDATA)>
<!ELEMENT dateOfBirth (#PCDATA)>
<!ELEMENT veterinarian EMPTY>
<!ELEMENT trainer EMPTY>
<!ATTLIST veterinarian
 name  CDATA #REQUIRED
 phone CDATA #REQUIRED
>
<!ATTLIST trainer
 name  CDATA #REQUIRED
 phone CDATA #REQUIRED
>
Пример 14.12. Модифицированный файл animals.xml, содержащий DTD
<?xml version="1.0" encodings "UTF-8"?>
<!-- Животные цирка Feldman Family Circus с DTD. -->
<!DOCTYPE animalList SYSTEM "animals.dtd">
 <!- так же, как в примере 14.1 -->
</animalList>
Пример 14.13. Проверка документа animals.xml на соответствие DTD с использованием программного интерфейса SAX2
/*
* Операторы #include из примера 14.8, кроме включения вектора <vector> который
здесь не нужен
*/
#include <stdexcept> // runtime_error
#include <xercesc/sax2/DefaultHandler.hpp>
using namespace std;
using namespace xercesc;
/*
 * Определить XercesInitializer, как это сделано в примере 14.8, и
 * CircusErrorHandler, как это сделано в примере 14.7
 */
int main() {
 try {
  // Инициализировать Xerces и получить парсер
  SAX2 XercesInitializer init;
  auto_ptr<SAX2XMLReader>
   parser(XMLReaderFactory::createXMLReader());
  // Включить режим проверки
  parser->setFeature(XMLUni::fgSAX2CoreValidation, true);
  // Зарегистрировать обработчик ошибок для получения уведомлений о
  // нарушениях DTD
  CircusErrorHandler error;
  parser->setErrorHandler(&error);
  parser->parse("animals.xml");
 } catch (const SAXException& e) {
  cout << "xml error " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const XMLException& e) {
  cout << "xml error " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Пример 14.14. Проверка документа animals.xml на соответствие DTD animals.dtd с использованием парсера XercesDOMParser
#include <exception>
#include <iostream>  // cout
#include <stdexcept> // runtime_error
#include <xercesc/dom/DOM.hpp>
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/sax/HandlerBase.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include "xerces_strings.hpp" // Пример 14.4
using namespace std;
using namespace xercesc;
/*
 * Определить XercesInitializer, как это сделано в примере 14.8
 * и CircusErrorHandler, как это сделано в примере 14.7
 */
int main() {
 try {
  // Инициализировать Xerces и сконструировать DOM-парсер.
  XercesInitializer init;
  XercesDOMParser parser;
  // Включить режим проверки DTD
  parser.setValidationScheme(XercesDOMParser::Val_Always);
  // Зарегистрировать обработчик ошибок для получения уведомлений о
  // нарушениях схемы
  CircusErrorHandler handler;
  parser.setErrorHandler(&handler);
  // Выполнить синтаксический анализ вместе с проверкой.
  parser.parse("animals.xml");
 } catch (const SAXException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const XMLException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
Определения DTD обеспечивают простой способ наложения ограничений на документ XML. Например, в DTD можно указать, какие элементы допускаются в документе, какие атрибуты может иметь элемент и может ли конкретный элемент содержать дочерние элементы, текст или и то и другое. Можно также накладывать ограничения на тип, порядок следования и количество дочерних элементов, а также на значения атрибутов.
DTD предназначены для определения подмножества правильно сформированных документов XML, которые характерны для определенной прикладной области. Например, в примере 14.1 важно то, что каждый элемент animal имеет дочерние элементы name, species, dateOfBirth, veterinarian и trainer, а элементы name, species и dateOfBirth содержат только текст в то время, как элементы veterinarian и trainer имеют атрибуты name и phone. Более того, элемент animal не должен иметь атрибут phone, а элемент veterinarian не должен иметь дочерний элемент species.
DTD в примере 14.11 накладывает ограничения различного типа. Например, приведенное ниже объявление элемента устанавливает необходимость наличия в элементе животного дочерних элементов name, species, dateOfBirth, veterinarian и trainer, задаваемых именно в этом порядке.
<!ELEMENT animal (name, species, dateOfBirth,
                  veterinarian, trainer) >
Аналогично приведенное ниже объявление атрибута указывает на то, что элемент trainer должен иметь атрибуты name и phone, а отсутствие в DTD объявлений других атрибутов для элемента дрессировщика говорит о том, что этот элемент может иметь только два атрибута.
<!ATTLIST trainer
 name  CDATA #REQUIRED
 phone CDATA #REQUIRED
>
Документ XML, который содержит DTD и удовлетворяет его требованиям, называют достоверным (valid). XML-парсер, который обнаруживает не только синтаксические ошибки, но и проверяет достоверность документа XML. называется подтверждающим парсером (validating parser). Хотя парсеры SAX2XMLReader и XercesDOMParser не являются по умолчанию подтверждающими парсерами, в каждом из них предусмотрена функция подтверждения достоверности, которая может подключаться так, как это сделано в примерах 14.13 и 14.14. Аналогично парсер DOMBuilder, описанный в рецепте 14 4, может проверять достоверность документа XML, вызывая свой метод setFeaturе() с аргументами fgXMLUni::fgDOMValidation и true.
Классы SAX2XMLReader, DOMBuilder, DOMWriter и XercesDOMParser поддерживают ряд дополнительных функций. В SAX2XMLReader и DOMBuilder вы можете включать эти функции, используя методы setFeature() и setProperty(). Первый метод принимает строку и булево значение: второй метод принимает строку и void*. Запросить включенные функции можно с помощью методов getFeature() и getProperty(). Для удобства в Xerces предусмотрены константы с именами фикций и свойств. Класс DOMWriter поддерживает setFeature(), но не поддерживает setProperty(). Класс XercesDOMParser поддерживает оба метода, в нем предусмотрены отдельные методы по установке и получению каждой функции. В документации Xerces вы найдете полный список поддерживаемых дополнительных функций.
Смотри также
Рецепт 14.6.
14.6. Проверка документа XML на соответствие схеме
Проблема
Требуется подтвердить соответствие документа XML схеме, представленной в рекомендациях XML Schema 1.0.
Решение
Используйте библиотеку Xerces совместно с программным интерфейсом SAX2 или с парсером DOM.
Подтверждение соответствия документа XML схеме с использованием программного интерфейса SAX2 осуществляется точно так же, как подтверждение достоверности документа, содержащего DTD, когда схема содержится внутри целевого документа или когда на нее делается ссылка в этом документе. Если требуется проверить документ XML на соответствие внешней схеме, вы должны вызвать метод парсера setProperty() для включения режима подтверждения внешней схемы. В качестве первого аргумента setProperty() необходимо использовать XMLUni::fgXercesSchemaExternalSchemaLocation или XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation в зависимости оттого, используется или нет в схеме целевое пространство имен. Второй аргумент должен определять место расположения схемы, представленное значением типа const XMLCh*. Не забудьте привести тип второго аргумента к void*, как это сделано в рецепте 14.5.
Подтверждение соответствия документа XML схеме на основе использования XercesDOMParser выполняется аналогично подтверждению достоверности документа DTD, когда схема содержится внутри целевого документа или когда на нее делается ссылка в этом документе. Единственное отличие заключается в явном подключении средств поддержки схемы и пространства имен, как показано в примере 14.15.
Пример 14.15. Включение режима подтверждения схемы при использовании XercesDOMParser
XercesDOMParser parser;
parser.setValidationScheme(XercesDOMParser::Val_Always);
parser.setDoSchema(true);
parser setDoNamespaces(true);
Если требуется проверить документ XML на соответствие внешней схеме, имеющей целевое пространство имен, вызовите метод парсера setExternalSchemaLocation(), передавая в качестве аргумента место расположения вашей схемы. Если требуется проверить документ XML на соответствие внешней схеме, не имеющей целевого пространства имен, вызовите метод парсера setExternalNoNamespaceSchemaLocation().
Аналогично для проверки документа XML на соответствие схемы с использованием DOMBuilder включите функцию подтверждения достоверности следующим образом.
DOMBuilder* parser = ...;
parser->setFeature(XMLUni::fgDOMNamespaces, true);
parser->setFeature(XMLUni::fgDOMValidation, true);
parser->setFeature(XMLUni::fgXercesSchema, true);
Для подтверждения соответствия документа внешней схеме с использованием DOMBuilder установите свойство XMLUni::fgXercesSchemaExternalSchemaLocation или XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation в значение места расположения схемы.
Например, пусть требуется проверить документ animals.xml из примера 14.1, используя схему из примера 14.16. Один из способов заключается в добавлении ссылки на схему в документ animals.xml, как показано в примере 14.17. После этого вы можете проверить документ, используя программный интерфейс SAX2, как показано в примере 14.13, или используя DOM, как показано в примере 14.14 с учетом модификаций, выполненных в примере 14.15.
Пример 14.16. Схема animals.xsd для файла animals.xml
<?xml version="1.0" encoding="UTF-8"?>
<!- Схема для животных цирка Feldman Family Circus -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
 elementFormDefault="qualified">
 <xsd:element name="animalList">
  <xsd:complexType>
   <xsd:sequence>
    <xsd:element name="animal" minOccurs="0" maxOccurs="unbounded">
     <xsd:complexType>
       <xsd:sequence>
        <xsd:element name="name" type="xsd:string" />
        <xsd:element name="species" type="xsd:string"/>
        <xsd:element name="dateOfBirth" type="xsd:date"/>
        <xsd:element name="veterinarian" type="contact"/>
        <xsd:element name="trainer" type="contact"/>
       </xsd:sequence>
      </xsd:complexType>
     </xsd:element>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 <xsd:complexType name="contact">
  <xsd:attribute name="name" type="xsd:string"/>
  <xsd:attribute name="phone" type="phone"/>
 </xsd:complexType>
 <xsd:simpleType name="phone">
  <xsd:restriction base="xsd:string">
   <xsd:pattern value="\(\d{3}\)\d{3}-\d{4}"/>
  </xsd:restriction>
 </xsd:simpleType>
</xsd:schema>
Пример 14.17. Модифицированный файл animals.xml, содержащий ссылку на схему
<?xml version="1.0" encoding="UTF-8"?>
<!- Животные цирка Feldman Family Circus со схемой -->
<animalList xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemalocation="animals.xsd">
<!- Так же, как в примере 14.1 -->
</animalList>
Можно поступить по-другому: опустить ссылку на схему и включить режим подтверждения соответствия документа внешней схеме. Пример 14.18 показывает, как это можно сделать при использовании парсера DOM.
Пример 14.18. Подтверждение соответствия документа XML внешней схеме, используя DOM
/*
 * Те же самые операторы #include, которые использовались в примере 14.14
 */
using namespace std;
using namespace xercesc;
/*
 * Определить XercesInitializer, как в примере 14.8,
 * и CircusErorHandler, как в примере 14.7
 */
int main() {
 try {
  // Инициализировать Xerces и сконструировать парсер DOM.
  XercesInitializer init;
  XercesDOMParser parser;
  // Включить проверку
  parser.setValidationScheme(XercesDOMParser::Val_Always);
  parser.setDoSchema(true); parser.setDoNamespaces(true);
  parser.setExternalNoNamespaceSchemaLocation(
   fromNative("animals.xsd").c_str());
  // Зарегистрировать обработчик ошибок для получения уведомлений о
  // нарушениях схемы
  CircusErrorHandler handler;
  parser.setErrorHandler(&handler);
  // Выполнить синтаксический анализ и проверить соответствие документа
  // схеме.
  parser parse("animals.xml");
 } catch (const SAXException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const XMLException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
Подобно определениям DTD, рассмотренным в предыдущем рецепте, схемы накладывают ограничения на документы XML. Схема предназначена для определения подмножества правильно сформированных документов, характерных для определенной прикладной области. Однако схемы имеют три отличия от определений DTD. Во-первых, концепция DTD и связанное с ней понятие подтверждения достоверности (validity) определены в самой спецификации XML, в то время как схемы описаны в другой спецификации — в рекомендациях XML Schema. Во-вторых, сами схемы являются правильно сформированными документами XML, в то время как для описания определений DTD используется специальный синтаксис, продемонстрированный в примере 14.11. В-третьих, схемы существенно более выразительны, чем определения DTD. Из-за двух последних отличий считается, что схемы превосходят определения DTD.
Например, в DTD из примера 14.11 можно было лишь потребовать, чтобы элементы veterinarian имели ровно два атрибута, name и phone, значения которых состоят из символов. Напротив, схема в примере 14.16 требует, чтобы значение атрибута phone, кроме того, соответствовало регулярному выражению \(\d{3}\)\d{3}-\d{4}, т.е. чтобы оно имело вид (ddd)xxx-dddd, где d может быть любой цифрой. Аналогично обстоит дело с элементом dateOfBirth: если в DTD можно было только потребовать, чтобы этот элемент имел текстовое значение, то схема требует, чтобы текстовое значение имело вид yyyy-mm-dd, где yyyy задается в диапазоне от 0001 до 9999, mm — от 01 до 12, a dd — от 01 до 31.
Способность накладывать эти дополнительные ограничения создает большое преимущество, поскольку позволяет часть программистской работы переложить на парсер.
Смотри также
Рецепт 14.5.
14.7. Преобразование документа XML с помощью XSLT
Проблема
Требуется преобразовать документ XML, используя таблицу стилей XSLT.
Решение
Используйте библиотеку Xalan. Во-первых, сконструируйте экземпляр конвертора XSTL xalanc::XalanTransformer. Затем сконструируйте два экземпляра xalanc::XSLTInputSource (один для документа, который будет преобразован, а другой для вашей таблицы стилей) и экземпляр хаlanc::XSLTResultTarget для документа, который будет получен в результате преобразования. Наконец, вызовите метод XSLT transform(), передавая в качестве аргументов два экземпляра XSLTInputSource и один XSLTResultTarget.
Например, представим, что требуется с помощью веб-браузера просматривать список животных цирка из примера 14.1. Это легко сделать с помощью XSLT В примере 14.19 приводится таблица стилей XSLT, которая на входе принимает документ XML, такой как animals.xml, и формирует документ HTML, содержащий таблицу, в каждой строке которой описывается одно животное с указанием клички, вида, даты рождения, ветеринара и дрессировщика. Пример 14.20 показывает, как можно использовать библиотеку Xalan, чтобы воспользоваться этой таблицей стилей для документа animals.xml. В примере 14.21 приводится HTML, сгенерированный программой из примера 14.20; этот HTML переформатирован для лучшего восприятия.
Пример 14.19. Таблица стилей для animals.xml
<?xml version="1.0" encoding="utf-8"?>
<!- Таблица стилей для животных цирка Feldman Family Circus -->
<xsl:stylesheet versions="1.1"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:output method="html"/>
 <xsl:template match="/">
  <html>
   <head>
    <title>Feldman Family Circus Animals</title>
   </head>
   <body>
    <h1>Feldman Family Circus Animals</h1>
     <table cellpadding="3" border="1">
      <tr>
       <th>Name</th>
       <th>Species</th>
       <th>Date of Birth</th>
       <th>Veterinarian</th>
       <th>Trainer</th>
      </tr>
      <xsl:apply-templates match="animal">
     </xsl:apply-templates>
    </table>
   </body>
  </html>
 </xsl:template>
 <xsl:template match="animal">
  <tr>
   <td><xsl:value-of select="name"/></td>
   <td><xsl:value-of select="species"/></td>
   <td><xsl:value-of select="dateOfBirth"/></td>
   <xsl:apply-templates select="veterinarian"/>
   <xsl:apply-templates select="trainer"/>
  </tr>
 </xsl:template>
 <xsl:template match="veterinarian|trainer">
  <td>
   <table>
    <tr>
     <th>name:</th>
     <td>
      <xsl:value-of select="attribute::name"/>
     </td>
    </tr>
    <tr>
     <th>phone:</th>
     <td><xsl:value of select="attribute::phone"/></td>
    </tr>
   </table>
  </td>
 </xsl:template>
</xsl:stylesheet>
Пример 14.20. Применение таблицы стилей animals.xsl для файла animals.xml с использованием библиотеки Xalan
#include <exception>
#include <iostream> // cout
#include <xalanc/Include/PlatformDefinitions.hpp>
#include <xalanc/XalanTransformer/XalanTransformer.hpp>
#include <xalanc/XSLT/XSLTInputSource.hpp>
#include <xalanc/XSLT/XSLTResultTarget.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include "xerces_strings.hpp" // Пример 14.4
using namespace std;
using namespace xercesc;
using namespace xalanc;
// Утилита RAII, которая инициализирует парсер и освобождает ресурсы
// при выходе из области видимости
struct XalanInitializer {
 XalanInitializer() {
  XMLPlatformUtils::Initialize();
  XalanTransformer::initialize();
 }
 ~XalanInitializer() {
  XalanTransformer::terminate();
  XMLPlatformUtils::Terminate();
 }
};
int main() {
 try {
  XalanInitializer init; // Инициализировать Xalan.
  XalanTransformer xslt; // Конвертор XSLT.
  XSLTInputSource xml("animals.xml"); // Документ XML из
                                      // примера 14.1
  XSLTInputSource xsl("animals.xsl"); // Таблица стилей из
                                      // примера 14.19.
  XSLTResultTarget html("animals.html"); // Результат выполнения xslt.
  // Выполнить преобразование.
  if (xslt.transform(xml, xsl, html) != 0) {
   cout << "xml error: " << xslt.getLastError() << "\n";
  }
 } catch (const XMLException& e) {
  cout << "xml error " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Пример 14.21. Документ HTML, сгенерированный программой из примера 14.20
<html>
 <head>
  <МЕТА http-equiv="Content Type" content="text/html; charset=UTF-8">
  <title>Feldman Family Circus Animals</title>
 </head>
 <body>
  <h1>Feldman Family Circus Animals</h1>
  <table cellpadding="3" border="1">
   <tr>
    <th>Name</th>
    <th>Species</th>
    <th>Date of Birth</th>
    <th>Veterinarian</th>
    <th>Trainer</th>
   </tr>
   <tr>
    <td>Herby</td>
    <td>elephant</td>
    <td>1992-04-23</td>
    <td>
     <table>
      <tr><th>name:</th><td>Dr. Hal Brown</td></tr>
      <tr><th>phone:</th><td>(801)595-9627</td></tr>
     </table>
    </td>
    <td>
     <table>
      <tr><th>name:</th><td>Bob Fisk</td></tr>
      <tr><th>phone:</th><td>(801)881-2260</td></tr>
     </table>
    </td>
   </tr>
   <tr>
    <td>Sheldon</td>
    <td>parrot</td>
    <td>1998-09-30</td>
    <td>
     <table>
      <tr><th>name:</th><td>Dr. Kevin Wilson</td></tr>
      <tr><th>phone:</th><td>(801)466-6498</td></tr>
     </table>
    </td>
    <td>
     <table>
      <tr><th>name:</th><td>Eli Wendel</td></tr>
      <tr><th>phone:</th><td>(801)929-2506</td></tr>
     </table>
    </td>
   </tr>
   <tr>
    <td>Dippy</td>
    <td>penguin</td>
    <td>2001-06-08</td>
    <td>
     <table>
      <tr><th>name:</th><td>Dr. Barbara Swayne</td></tr>
      <tr><th>phone:</th><td>(801)459-7746</td></tr>
     </table>
    </td>
    <td>
     <table>
      <tr><th>name:</th><td>Ben Waxman</td></tr>
      <tr><th>phone:</th><td>(801)882-3549</td></tr>
     </table>
    </td>
   </tr>
  </table>
 </body>
</html>
Обсуждение
XSL-преобразование (стандарт XSLT) представляет собой язык преобразования документов XML в другие документы XML. XSLT является одним из элементов семейства спецификаций расширяемых языков описания таблиц стилей (Extensible Stylesheet Language — XSL), который обеспечивает базовые средства для визуального представления документов XML Однако XSLT полезен не только при форматировании; например, он используется веб-серверами при генерации HTML-документов «на лету» и такими системами генерации документов, как DocBook.
Преобразования XSLT представляются в виде документов XML, называемых таблицами стилей (stylesheets). Таблица стилей используется для обработки исходного документа и формирования выходного документа (result document). Таблица стилей состоит из набора шаблонов, которым соответствуют узлы исходного документа и которые применяются для получения фрагментов выходного документа. Шаблоны рекурсивно применяются к исходному документу, генерируя фрагменты выходного документа один за другим, пока не будет обнаружено ни одного соответствия. Условия соответствия записываются с помощью языка XPath, предназначенного для извлечения информационных строк, чисел, булевых значений и наборов узлов из документов XML.
Таблица стилей представленная в примере 14.19, состоит из трех шаблонов. В главном шаблоне атрибут match равен /, т.е. он соответствует корню исходною документа, а именно узлу, который является родительским узлом по отношению к корневому элементу документа и любым инструкциям обработки и комментариям верхнего уровня. При применении этого шаблона генерируется фрагмент документа HTML, содержащий заголовок «Животные цирка Feldman Family Circus» и таблицу с одной строкой, состоящей из пяти элементов th с метками Name, Species, Date of Birth, Veterinarian и trainer. Этот шаблон содержит элемент apply-templates, которому соответствует атрибут animal. Это приводит к тому, что второй шаблон таблицы стилей с атрибутом соответствия animal — будет применяться один раз к каждому элементу animal, дочернему по отношению к корневому документу, формируя строку таблицы для каждого дочернего элемента. Строка, сгенерированная для элемента animal, состоит из пяти элементов td. Первые три элемента td содержат текстовое значение дочерних элементов animal (name, species и dateOfBirth), извлекаемое с помощью инструкции XSLT value-of. Последние два элемента td содержат элементы таблицы, полученные путем применения третьего шаблона таблицы стилей с атрибутом соответствия veterinarian|trainer, применяемого к дочерним элементам животного veterinarian и trainer.
Хотя в примере 14.20 мною указаны локальные файлы для таблицы стилей, исходного документа и выходного документа, XSLTInputSources и XSLTResultTargets могут быть сконструированы из потоков стандартной библиотеки C++, позволяя XalanTransformer принимать поток ввода и генерировать результат в произвольном месте. Более того, вместо получения на входе экземпляров XSLTInputSource конвертор XalanTransformer может работать с предварительно скомпилированной таблицей стилей, представляющей экземпляр xalanc::XalanCompiledStylesheet, и с исходным документом, прошедшим обработку парсером и представленным экземпляром xalanc::XalanParsedSource. Это проиллюстрировано в примере 14.22. Если требуется применять одну таблицу стилей к нескольким исходным документам, гораздо более эффективный результат получается при использовании XalanCompiledStylesheet, чем XSLTInputSource.
Пример 14.22. Выполнение преобразования XSLT с применением предварительно откомпилированной таблицы стилей
/*
 * те же операторы #include, которые использовались в примере 14.20
 */
using namespace std;
using namespace xercesc;
using namespace xalanc;
/*
 * Определить XalanInitializer так же, как в примере 14.20
 */
int main() {
 try {
  XalanInitializer init; // Инициализировать Xalan
  XalanTransformer xslt; // Конвертор XSLT.
  XSLTResultTarget html("animals.html"); // Результат работы xslt.
  // Выполнить синтаксический анализ исходного документа
  XSLTInputSource xml("animals.xml");
  XalanParsedSource* parsedXml = 0;
  if (xslt.parseSource(xml, parsedXml) != 0) {
   cout << "xml error: " << xslt.getLastError() << "\n";
  }
  // Компилировать таблицу стилей.
  XSLTInputSource xsl("animals.xsl");
  XalanCompiledStylesheet* compiledXsl = 0;
  if (xslt.compileStylesheet(xsl, compiledXsl) != 0) {
   cout << "xml error: " << xslt.getLastError() << "\n";
  }
  // Выполнить преобразование.
  if (xslt.transform(xml, xsl, html)) {
   cout << "xml error: " << xslt.getLastFrror() << "\n";
  }
 } catch (const XMLException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Смотри также
Рецепт 14.8.
14.8. Вычисление XPath-выражения
Проблема
Требуется извлечь информацию из документа XML, обработанного парсером, путем вычисления XPath-выражения.
Решение
Используйте библиотеку Xalan. Во-первых, выполните синтаксический анализ документа XML и получите указатель на xalanc::XalanDocument. Это можно сделать, используя экземпляры XalanSourceTreeInit, XalanSourceTreeDOMSupport и XalanSourceTreeParserLiaison, каждый из которых следующим образом определяется в пространстве имен xalanc.
#include <xercesc/framework/LocalFileInputSource.hpp>
#include <xalanc/XalanSourceTree/XalarSourceTreeDOMSupport.hpp>
#include <xalanc/XalanSourceTree/XalanSourceTreeInit.hpp>
#include <xalanc/XalanSourceTree/XalanSourceTreeParserLiaison.hpp>
...
int main() {
 ...
 // Инициализировать подсистему XalanSourceTree
 XalarSourceTreeInit init;
 XalanSourceTreeDOMSupport support;
 // Интерфейс доступа к парсеру
 XalanSourceTreeParserLiaison liaison(support);
 // Подключить DOMSupport к ParserLiaison
 support.setParserLiaison(&liaison);
 LocalFileInputSource src(место-расположения-документа);
 XalanDocument* doc = liaison.ParseXMLStream(doc);
 ...
}
Можно поступить по-другому и использовать парсер Xerces DOM для получения указателя на DOMDocument, как это сделано в примере 14.14, и затем использовать экземпляры XercesDOMSupport, XercesParserLiaison и XercesDOMWrapperParsedSource, каждый из которых определяется в пространстве имен xalanc для получения указателя на XalanDocument, соответствующего документу DOMDocument.
#include <xercesc/dom/DOM.hpp>
#include <xalanc/XalanTransformer/XercesDOMWrapperParsedSource.hpp>
#include <xalanc/XercesParserLiaison/XercesParserLiaison.hpp>
#include <xalanc/XercesParserLiaison/XercesDOMSupport.hpp>
...
int main() {
 ...
 DOMDocument* doc = ...;
 XercesDOMSupport support;
 XercesParserLiaison liaison(support);
 XercesDOMWrapperParsedSource src(doc, liaison, support);
 XalanDocument* xalanDoc = src.getDocument();
 ...
}
На следующем шаге получите указатель на узел, выполняющий роль узла контекста при вычислении выражения XPath. Это можно сделать с помощью интерфейса DOM документа XalanDocument. Сконструируйте XPathEvaluator для вычисления выражения XPath и XalanDocumentPrefixResolver для разрешения префиксов пространств имен в документе XML. Наконец, вызовите метод XPathEvaluator::evaluate(), передавая в качестве аргументов DOMSupport, контекстный узел, XPath-выражение и PrefixResolver. Результат вычисления выражения возвращается в виде объекта типа XObjectPtr; тип допустимых операций над этим объектом зависит от типа его данных XPath, который можно узнать при помощи метода getType().
Например, пусть требуется извлечь список имен животных из документа animals.xml, представленного в примере 14.1. Вы можете это сделать, выполняя синтаксический анализ документа и вычисляя XPath-выражение animalList/animal/name/child::text() с использованием корня документа в качестве контекстного узла. Это проиллюстрировано в примере 14.23.
Пример 14.23. Вычисление ХРаth-выражения, используя Xalan
#include <cstddef> // size_t
#include <exception>
#include <iostream> // cout
#include <xercesc/dom/DOM.hpp>
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/sax2/DefaultHandler.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <xalanc/DOMSupport/XalanDocumentPrefixResolver.hpp>
#include <xalanc/XalanTransformer/XercesDOMWrapperParsedSource.hpp>
#include <xalanc/XercesParserLiaison/XercesParserLiaison.hpp>
#include <xalanc/XercesParserLiaison/XercesDOMSupport.hpp>
#include <xalanc/XPath/XObject.hpp>
#include <xalanc/XPath/XPathEvaluator.hpp>
#include "animal.hpp"
#include "xerces_strings.hpp"
using namespace std;
using namespace xercesc;
using namespace xalanc;
// Утилита RAII, которая инициализирует парсер и процессор XPath, освобождая
// ресурсы при выходе из области видимости
class XPathInitializer {
public:
 XPathInitializer() {
 XMLPlatformUtils::Initialize();
 XPathEvaluator::initialize();
}
~XPathInitializer() {
 XpathEvaluator::terminate();
 XMLPlatformUtils::Terminate();
}
private:
 // Запретить копирование и присваивание
 XPathInitializer(const XPathInitializer&);
 XPathInitializer& operator=(const XPathInitializer&);
};
// Получает уведомления об ошибках
class CircusErrorHandler : public DefaultHandler {
public:
 void error(const SAXParseException& e) {
  throw runtime_error(toNative(e.getMessage()));
 }
 void fatalError(const SAXParseException& e) { error(e); }
};
int main() {
 try {
  // Инициализировать Xerces и XPath и сконструировать парсер DOM.
  XPathInitializer init;
  XercesDOMParser parser;
  // Зарегистрировать обработчик ошибок
  CircusErrorHandler error;
  parser.setErrorHandler(&error);
  // Выполнить синтаксический анализ animals.xml.
  parser.parse(fromNative("animals.xml").c_str());
  DOMDocument* doc = parser.getDocument();
  DOMElement* animalList = doc->getDocumentElement();
  // Создать XalanDocument на основе doc.
  XercesDOMSupport support;
  XercesParserLiaison liaison(support);
  XercesDOMWrapperParsedSource src(doc, liaison, support);
  XalanDocument* xalanDoc = src.getDocument();
  // Вычислить XPath-выражение для получения списка
  // текстовых узлов, содержащих имена животных
  XPathEvaluator evaluator;
  XalanDocumentPrefixResolver resolver(xalanDoc);
  XercesString xpath =
   fromNative("animalList/animal/name/child::text()");
  XObjectPtr result =
   evaluator.evaluate(
    support,       // поддержка DOM
    xalanDoc,      // контекстный узел
    xpath.c_str(), // XPath-выражение
    resolver);     // функция разрешения пространства имен
  const NodeRefListBase& nodeset = result->nodeset();
  // Просмотр списка узлов и вывод имен животных
  for (size_t i = 0, len = nodeset.getLength(); i < len; ++i) {
   const XMLCh* name = nodeset.item(i)->getNodeValue().c_str();
   std::cout << toNative(name) << "\n";
  }
 } catch (const DOMException& e) {
  cout << "xml error: " << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Обсуждение
XPath — это язык поиска по образцу (pattern matching language), предназначенный для извлечения информации из документов XML. Основная конструкция XPath — выражение пути (path expression) поддерживает иерархический синтаксис ссылок на элементы, атрибуты и текстовые узлы на основе использования их имен, атрибутов, текстового содержимого, отношений наследования и других свойств. Кроме работы с наборами узлов язык XPath может обрабатывать строки, числа и булевы значения. XPath версии 2.0, которая в настоящее время не поддерживается библиотекой Xalan, использует даже более сложную модель данных, основанную на рекомендациях XML Schema. (См. рецепт 14.5.)
XPath-выражения вычисляются в контексте узла документа XML, называемого контекстным узлом, который используется для интерпретации связанной с ним конструкции, например, parent, child и descendant. В примере 14.23 я указал корень (root) документа XML в качестве контекстного узла; этот узел является родительским по отношению к корневому элементу документа XML, а также к любой инструкции обработки и комментариям верхнего уровня. При вычислении выражения с использованием корневого узла в качестве контекстного узла выражение пути animalList/animal/name/child::text() соответствует всем текстовым узлам, дочерним по отношению к элементам name, родительским элементом которых является animal, и чьим «дедушкой» является элемент animalList.
Метод evaluate() класса XPathEvaluator возвращает XObjectPtr, представляющий результат вычисления выражения XPath. Тип данных, на который ссылается XObjectPtr, можно узнать путем его разыменования с получением XObject и вызова метода getType(); затем можно получить доступ к базовым данным при помощи вызова num(), boolean(), str() или nodeset(). Поскольку XPath-выражение в примере 14.23 представляет набор узлов, я использовал метод nodeset() для получения ссылки на NodeRefListBase, который обеспечивает доступ к узлам в наборе с помощью его методов getLength() и item(). Метод item() возвращает указатель на узел XalanNode, метод getNodeValue() которого возвращает строку с интерфейсом, похожим на интерфейс std::basic_string.
Поскольку XPath обеспечивает простой способ определения местоположения узлов в документе XML, возникает естественный вопрос о возможности применения выражений Xalan XPath для получения экземпляров xercesc::DOMNode из xercesc::DOMDocument. На самом деле это возможно, но не совсем удобно, а кроме того, по умолчанию узлы xercesc::DOMNodes, полученные таким способом, представляют дерево документа XML с возможностями только чтения, что уменьшает пользу от применения XPath в качестве средства манипулирования DOM. Существуют способы, позволяющие обойти это ограничение, однако они достаточно сложны и потенциально опасны.
К счастью, библиотека Pathan реализует XPath, совместимый с Xerces и позволяющий легко манипулировать Xerces DOM. Пример 14.24 показывает, как можно использовать Pathan для определения места расположения и удаления узла слона Herby из документа XML, приведенного в примере 14.1, с помощью вычисления XPath-выражения animalList/animal[child::name='Herby']. Сравнение этого примера с примером 14.10 ясно показывает, насколько мощным является язык XPath.
Пример 14.24. Определение местоположения узла и удаление его с использованием библиотеки Pathan
#include <exception>
#include <iostream> // cout
#include <xercesc/dom/DOM.hpp>
#include <xercesc/framework/LocalFileFormatTarget.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <pathan/XPathNamespace.hpp>
#include <pathan/XPathResult.hpp>
<include <pathan/XPathEvaluator.hpp>
#include <pathan/XPathExpression.hpp>
#include "xerces_strings.hpp" // Пример 14.4
using namespace std;
using namespace xercesc;
/*
 * Определить XercesInitializer, как это сделано в примере 14.8, а также
 * CircusFrrorHandler и DOMPtr, как это сделано в примере 14.10
 */
int main() {
 try {
  // Инициализировать Xerces и получить DOMImplementation.
  XercesInitializer init;
  DOMImplementation* impl =
   DOMImplementationRegistry::getDOMImplementation(
    fromNative("LS").c_str()
   );
  if (impl == 0) {
   cout << "couldn't create DOM implementation\n";
   return EXIT_FAILURE;
  }
  // Сконструировать DOMBuilder для синтаксического анализа
  // документа animals.xml.
  DOMPtr<DOMBuilder> parser =
   static cast<DOMImplementationLS*>(impl)-> createDOMBuilder(
    DOMImplementationLS::MODE_SYNCHRONOUS, 0
   );
  CircusErrorHandler err;
  parser->setErrorHandler(&err);
  // Выполнить синтаксический анализ
  animals.xml. DOMDocument* doc =
   parser->parseURI("animals.xml");
  DOMElement* animalList = doc->getDocumentElement();
  // Создать XPath-выражение.
  auto_ptr<XPathEvaluator>
   evaluator(XPathEvaluator::createEvaluator());
  auto_ptr<XPathNSResolver>
   resolver(evaluator->createNSResolver(animalList));
  auto_ptr<XPathExpression> xpath(
   evaluator->createExpression(FromNative(
    "animalList/animal[child::name='Herby']" ).c_str(), resolver.get()
   )
  );
  auto_ptr<XPathEvaluator> evaluator(XPathEvaluator::createEvaluator());
  auto_ptr<XPathNSResolver> resolver(evaluator->createNSResolver(animalList));
  auto_ptr<XPathExpression> xpath(evaluator->createExpression(
   fromNative("animalList/animal[child::name='Herby']").c_str(),
   resolver.get()
  ));
  // Вычислить выражение.
  XPathResult* result = xpath->evaluate(doc,
   XPathResult::ORDERED_NODE_ITERATOR_TYPE, 0
  );
  DOMNode* herby;
  if (herby = result->iterateNext()) {
   animalList->removeChild(herby);
   herby->release(); // optional
  }
  // Сконструировать DOMWriter для сохранения animals.xml
  DOMPtr<DOMWriter> writer =
   static_cast<DOMImplementationLS->(impl)->createDOMWriter();
  writer->setErrorHandler(&err);
  // Сохранить animals.xml.
  LocalFileFormatTarget file("circus.xml");
  writer->writeNode(&file, *animalList);
 } catch (const DOMException& e) {
  cout << toNative(e.getMessage()) << "\n";
  return EXIT_FAILURE;
 } catch (const XPathException &e) {
  cout << e.getString() << "\n";
  return EXIT_FAILURE;
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Пример 14.24 использует Pathan 1, который реализует рекомендации XPath 1.0; библиотекой Xalan в настоящее время поддерживается именно эта версия. Pathan 2, который в настоящее время доступен в бета-версии, обеспечивает предварительную реализацию рекомендаций XPath 2.0. Pathan 2 представляет собой более точную реализацию стандарта XPath; я рекомендую использовать Pathan 2 вместо Pathan 1, как только станет доступна не бета-версия.
Смотри также
Рецепт 14.7.
14.9. Применение XML для сохранения и восстановления набора объектов
Проблема
Требуется иметь возможность сохранения набора объектов C++ в документе XML и считывания их потом обратно в память.
Решение
Используйте библиотеку Boost Serialization. Эта библиотека позволяет сохранять и восстанавливать объекты, используя классы, называемые архивами. Для использования этой библиотеки вы должны сначала сделать каждый из ваших классов сериализуемым (serializable), что просто означает возможность записи экземпляров класса в архив (это называется сериализацией) и их обратного считывания в память (это называется десериализацией). Затем на этапе выполнения вы можете сохранить ваши объекты в архиве XML, используя оператор <<, и восстановить их, используя оператор >>.
Чтобы сделать класс сериализуемым, добавьте шаблон функции-члена serialize со следующей сигнатурой.
template<typename Archive>
void serialize(Archive& ar, const unsigned int version);
В реализации serialize необходимо обеспечить запись каждого данного-члена класса в указанный архив в виде пары «имя-значение», используя оператор &. Например, если вы хотите сериализовать и десериализовать экземпляры класса Contact из примера 14.2, добавьте функцию-член serialize, как это сделано в примере 14.25.
Пример 14.25. Добавление поддержки сериализации в класс Contact из примера 14.2
#include <boost/serialization/nvp.hpp> // пара "имя-значение"
class Contact {
 ...
private:
 friend class boost::serialization::access;
 template<typename Archive>
 void serialize(Archive& ar, const unsigned int version) {
  // Записать (или считать) каждое данное-член в виде пары имя-значение
  using boost::serialization::make_nvp;
  ar & make_nvp("name", name_);
  ar & make_nvp("phone", phone_);
 }
...
};
Аналогично можно обеспечить сериализацию класса Animal из примера 14.2, как это сделано в примере 14.26.
Пример 14.26. Добавление поддержки сериализации для класса Animal из примера 14.2
...
// Включить поддержку сериализации для boost::gregorian::date
#include <boost/date_time/gregorian/greg_serialize.hpp>
...
class Contact {
 ...
private:
 friend class boost::serialization::access;
 template<typename Archive>
 void serialize(Archive& ar, const unsigned int version) {
  // Записать (или считать) каждое данное-член в виде пары имя-значение
  using boost::serialization::make_nvp;
  ar & make_nvp("name", name_);
  ar & make_nvp("species", species_);
  ar & make_nvp("dateOfBirth", dob_);
  ar & make_nvp("veterinarian", vet_);
  ar & make_nvp("trainer", trainer_);
 }
 ...
};
Теперь вы можете сериализовать Animal, создавая архив XML типа boost::archive::xml_oarchive и записывая информацию о животном в архив, используя оператор <<. Конструктор xml_oarchive в качестве аргумента принимает std::ostream; часто этим аргументом будет поток вывода, используемый для записи в файл, однако в общем случае для записи данных может использоваться ресурс любого типа. После сериализации экземпляра Animal его можно считать обратно в память, конструируя архив XML типа boost::archive::xml_iarchive, подключая его к тому же самому ресурсу, который использовался первым архивом, и применяя оператор >>.
Пример 14.27 показывает, как можно использовать Boost.Serialization для сохранения вектора std::vector, состоящего из объектов Animal, в файле animals.xml и затем для загрузки его обратно в память. В примере 14.28 показано содержимое файла animals.xml после выполнения программы из примера 14.27.
Пример 14.27 Сериализация вектора std::vector, состоящего из объектов Animal
#include <fstream>
#include <boost/archive/xml_oarchive.hpp> // Архив для записи XML
#include <boost/archive/xml_iarchive.hpp> // Архив для чтения XML
#include <boost/serialization/vector.hpp> // Средства сериализации вектора
#include "animal.hpp" // std::vector
int main() {
 using namespace std;
 using namespace boost::archive;       // пространство имен для архивов
 using namespace boost::serialization; // пространство имен для make_nvp
 try {
  // Заполнить список животных
  vector<Animal> animalList;
  animalList.push_back(
   Animal("Herby", "elephant", "1992-04-23",
   Contact("Dr. Hal Brown", "(801)595-9627"),
   Contact("Bob Fisk", "(801)881-2260")));
  animalList.push_back(
   Animal("Sheldon", "parrot", "1998-09-30",
   Contact("Dr. Kevin Wilson", "(801)466-6498"),
   Contact("Eli Wendel", "(801)929-2506")));
  animalList.push_pack(
   Animal("Dippy", "penguin", "2001-06-08",
   Contact("Dr. Barbara Swayne", "(801)459-7746"),
   Contact("Ben Waxman", "(801)882-3549")));
  // Сконструировать выходной архив XML и сериализовать список
  ofstream fout("animals.xml");
  xml_oarchive oa(fout);
  oa << make_nvp("animalList", animalList);
  fout.close();
  // Сконструировать входной архив XML и десериализовать список
  ifstream fin("animals.xml");
  xml_iarchive ia(fin);
  vector<Animal> animalListCopy;
  ia >> make_nvp("animalList", animalListCopy);
  fin.close();
  if (animalListCopy != animalList) {
   cout << "XML serialization failed\n";
   return EXIT_FAILURE;
  }
 } catch (const exception& e) {
  cout << e.what() << "\n";
  return EXIT_FAILURE;
 }
}
Пример 14.28. Файл animals.xml после выполнения программы из примера 14.27
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE boost_serialization>
<boost_serialization signature="serialization::archive" version="3">
<animalList class_id="0" tracking_level ="0" version="0">
 <count>3</count>
 <item class_id="1" tracking_level="0" version="0">
  <name>Herby</name>
  <species>elephant</species>
  <dateOfBirth class_id="2" tracking_level="0" version="0">
   <date>19920423</date>
  </dateOfBirth>
  <veterinarian class_id="3" tracking_level="0" version="0">
   <name>Dr. Hal Brown</name>
   <phone>(801)595-9627</phone>
  </veterinarian>
  <trainer>
   <name>Bob Fisk</name>
   <phone>(801)881-2260</phone>
  </trainer>
 </item>
 <item>
  <name>Sheldon</name>
  <species>parrot</species>
  <dateOfBirth>
   <date>19980930</date>
  </dateOfBirth>
  <veterinarian>
   <name>Dr. Kevin Wilson</name>
   <phone>(801)466-6498</phone>
  </veterinarian>
  <trainer>
   <name>Eli Wendel</name>
   <phone>(801)929-2506</phone>
  </trainer>
 </item>
 <item>
  <name>Dippy</name>
  <species>penguin</species>
  <dateOfBirth>
   <date>20010608</date>
  </dateOfBirth>
  <veterinarian>
   <name>Dr. Barbara Swayne</name>
   <phone>(801)459-7746</phone>
  </veterinarian>
  <trainer>
   <name>Ben Waxman</name>
   <phone>(801)882-3549</phone>
  </trainer>
 </item>
</animalList>
Обсуждение
Библиотека Boost Serialization обеспечивает наиболее изощренный и гибкий способ сохранения и восстановления объектов C++. Она представляет собой очень сложный фреймворк. Например, она позволяет сериализовать сложные структуры данных, содержащие циклические ссылки и указатели на полиморфные объекты. Более того, применение этой библиотеки совсем не ограничивается сериализацией XML: кроме архивов XML она предоставляет несколько типов текстовых и бинарных архивов. Архивы XML и текстовые архивы являются переносимыми, т.е. данные можно сериализовать в одной системе и десериализовать в другой; бинарные архивы не переносимы, но компактны.
Нет никаких спецификаций, которым соответствовали бы документы XML, полученные при помощи Boost.Serialization, и их формат может изменяться в новых версиях Boost. Поэтому вы не можете использовать эти документы совместно с другими фреймворками сериализации С++. Тем не менее XML-сериализация приносит пользу, потому что сериализованный вывод легко воспринимается человеком и может обрабатываться инструментальными средствами, ориентированными на XML.
Примеры 14.25 и 14.26 демонстрируют интрузивную сериализацию (intrusive serialization): классы Animal и Contact были модифицированы, чтобы обеспечить их сериализацию. Boost.Serialization также поддерживает неинтрузивную сериализацию (nonintrusive serialization), обеспечивая сериализацию классов без модификации их определений при условии доступности всех состояний объекта через его открытый интерфейс. Вы уже видели пример неинтрузивной сериализации в примере 14.27: шаблон std::vector допускает сериализацию, несмотря на то что его определение не может модифицироваться конечными пользователями. Фактически все контейнеры стандартной библиотеки являются сериализуемыми; для обеспечения сериализации контейнера, определенного в стандартном заголовочном файле xxx, просто включите заголовочный файл boost/serialization/xxx.hpp. Дополнительную информацию о неинтрузивной сериализации вы можете найти в документации Boost.Serialization.
Примеры 14.25 и 14.26 иллюстрируют также двойственную роль оператора &: он действует как оператор << при сериализации объекта и как оператор >> при десериализации объекта. Это удобно, потому что позволяет реализовать сериализацию и десериализацию одной функцией. Однако в некоторых случаях неудобно использовать одну функцию для сериализации и десериализации; для этого в Boost.Serialization предусмотрен механизм разделения метода serialize() на два отдельных метода, load() и save(). Если вам необходимо воспользоваться преимуществами этой возможности, обратитесь к документации Boost.Serialization.
В примерах 14.25, 14.26 и 14.27 я использую функцию boost::serialization::make_nvp для конструирования пар вида «имя-значение». В Boost.Serialization предусмотрен также макрос BOOST_SERIALIZATION_NVP, который позволяет выполнять сериализацию переменной, указывая ее имя. Первый компонент пары будет сконструирован автоматически препроцессором, используя оператор «стрингизации» (stringizing) # для преобразования макропараметров в строковые константы.
// То же самое, что и ar & make_nvp("name_", name_);
ar & BOOST_SERIALIZATION_NVP(name_);
В этих примерах я использую make_nvp вместо BOOST_SERIALIZATION_NVP для лучшего контроля имен тегов, чтобы содержимое архива XML легче читалось.
В документации Boost.Serialization рекомендуется объявлять метод serialize() как закрытый (private) для уменьшения ошибок пользователя, когда добавляется поддержка сериализации в классы, производные от других сериализуемых классов. Для того чтобы библиотека Boost.Serialization могла вызвать метод serialize() вашего класса, вам необходимо объявить дружественным класс boost::serialization::access.
Наконец второй параметр метода serialize() в примерах 14.25 и 14.26 относится к той части Boost.Serialization, которая поддерживает управление версиями классов (class versioning). Когда объект определенного класса первый раз сохраняется в архиве, вместе с ним сохраняется также его версия; когда выполняется десериализация экземпляра класса. Boost.Serialization передает сохраненную версию методу serialize в качестве второго аргумента. Эта информация может использоваться для специализации десериализации; например, serialize мог бы загружать переменную-член только в том случае, если записанная в архив версия класса, по крайней мере, не меньше версии класса, первым объявившим эту переменную. По умолчанию класс имеет версию 0. Для задания версии класса вызовите макрос BOOST_CLASS_VERSION, который определен в заголовочном файле boost/serialization/version.hpp, передавая в качестве аргументов имя и версию класса.
Глава 15
Разные функции
15.0. Введение
В этой главе рассматриваются некоторые аспекты C++, которые плохо вписываются в тематику любой другой главы: указатели функций и членов, константные переменные и функции- члены, независимые операторы (т.е. не члены класса) и несколько других тем.
15.1. Применение указателей функций для их обратного вызова
Проблема
Планируется использование некоторой функции func1, которая на этапе выполнения должна вызывать другую функцию func2. Однако по той или иной причине нельзя внутри функции func1 жестко закодировать имя функции func2. Возможно, имя функции func2 неизвестно на этапе компиляции, или func1 относится к программному интерфейсу независимого разработчика, и она не может быть изменена и перекомпилирована В любом случае вам придется воспользоваться функцией обратного вызова (callback function).
Решение
При использовании указанных выше функций объявите func1 с указателем на функцию в качестве своего аргумента и передайте ей адрес func2 на этапе выполнения. Используйте typedef, чтобы программа легче читалась и отлаживалась. Пример 15.1 показывает, как можно реализовать функцию обратного вызова, используя указатель на функцию.
Пример 15.1. Функция обратного вызова
#include <iostream>
// Пример функции обратного вызова
bool updateProgress(int pct) {
 std::cout << pct << "% complete...\n";
 return(true);
}
// Этот typedef делает программный код более понятным
typedef bool (*FuncPtrBoolInt)(int);
// Функция, которая выполняется достаточно длительное время
void longOperation(FuncPtrBoolInt f) {
 for (long l=0; l < 100000000; l++)
 if (l % 10000000 == 0)
 f(l/1000000);
}
int main() {
 longOperation(updateProgress); // нормально
}
Обсуждение
В ситуации, которая показана в примере 15.1, применение указателя на функцию является хорошим решением, если UpdateProgress и longOperation ничего не должны знать друг о друге. Например, функцию, которая обновляет индикатор состояния процесса в диалоговом окне пользовательского интерфейса (user interface — UI), в окне консольного режима или где-то еще, не заботит контекст, в котором она вызывается. Аналогично функция longOperation может быть частью некоторого программного интерфейса загрузки данных, которого не заботит место вызова: из графического UI, из окна консольного режима или из фонового процесса.
Сначала потребуется определить сигнатуру функции, которую вы планируете вызывать, и создать для нее typedef. Оператор typedef — ваш помощник в тех случаях, когда приходится иметь дело с указателями функций, потому что они имеют не очень привлекательный синтаксис. Рассмотрим, как обычно объявляется такой указатель на примере переменной f, которая содержит адрес функции, принимающей единственный аргумент целого типа и возвращающей значения типа boolean. Это может выглядеть следующим образом
bool (*f)(int); // f - имя переменной
Вы можете справедливо возразить, что здесь нет ничего особенного и я просто излишне драматизирую ситуацию. Но что вы скажете, если требуется определить вектор vector таких указателей?
vector<bool (*)(int)> vf;
Или их массив?
bool (*af[10])(int);
Форма представления указателей на функции отличается от обычных переменных С++, которые обычно задаются в виде (квалифицированного) имени типа, за которым идет имя переменной. Поэтому они вносят путаницу при чтении программного кода.
Итак, в примере 15.1 я использовал следующий typedef.
typedef bool (*FuncPtrBoolInt)(int);
Сделав это, я могу свободно объявлять указатели функций с сигнатурой, возвращающей значение bool и принимающей единственный аргумент, как это я бы делал для параметра любого другого типа, например.
void longOperation(FuncPtrBoolInt f) { // ...
Теперь все, что надо сделать в longOperation, — это вызвать f, как если бы это была любая обычная функция.
f(l/1000000);
Таким образам, здесь f может быть любой функцией, которая принимает аргумент целого типа и возвращает bool. Предположим, что в вызывающей функции longOperation не требуется обеспечивать продвижение индикатора состояния процесса. Тогда ей можно передать указатель на функцию без операций.
bool whoCares(int i) {return(true);}
//...
longOperation(whoCares);
Более важно то, что выбор функции, передаваемой longOperation, может осуществляться динамически на этапе выполнения.
15.2. Применение указателей для членов класса
Проблема
Требуется обеспечить адресную ссылку на данное-член или на функцию-член.
Решение
Используйте имя класса и оператор области видимости (::) со звездочкой для правильного квалифицирования имени. Пример 15.2 показывает, как это можно сделать.
Пример 15.2. Получение указателя на член класса
#include <iostream>
#include <string>
class MyClass {
public:
 MyClass() : ival_(0), sval_("foo") {}
 ~MyClass() {}
 void incr() {++ival_;}
 void decr() {ival_--;}
private:
 std::string sval_;
 int ival_;
};
int main() {
 MyClass obj;
 int MyClass::* mpi = &MyClass::ival_;         // Указатели на
 std::string MyClass::* mps = &MyClass::sval_; // данные-члены
 void (MyClass::*mpf)(); // Указатель на функцию-член, у которой
                         // нет параметров и которая возвращает void
 void (*pf)(); // Обычный указатель на функцию
 int* pi = &obj.ival_; // int-указатель, ссылающийся на переменную-член
                       // типа int, - все нормально.
 mpf = &MyClass::incr; // Указатель на функцию-член. Вы не можете
                       // записать это значение в поток. Посмотрите в
                       // отладчике, как это значение выглядит.
 pf = &MyClass::incr; // Ошибка: &MyClass::inc не является экземпляром
                      // функции
 std::cout << "mpi = " << mpi << '\n';
 std::cout << "mps = " << mps << '\n';
 std::cout << "pi = " << pi << '\n';
 std::cout << "*pi = " << *pi << '\n';
 obj.*mpi = 5;
 obj.*mps = "bar";
 (obj.*mpf)(); // теперь obj.ival_ равно 6
 std::cout << "obj.ival_ = " << obj.ival_ << '\n';
 std::cout << "obj.sval_ = " << obj.sval_ << '\n';
}
Обсуждение
Указатели на члены класса выглядят и работают иначе, чем обычные указатели. Прежде всего, они имеют «смешной» синтаксис (не вызывающий смех, но странный). Рассмотрим следующую строку из примера 15.2.
int MyClass::* mpi = &MyClass::ival_;
Здесь объявляется указатель и ему присваивается значение целого типа, которым оказывается член класса MyClass. Две вещи отнимают это объявление от обычного int*. Во-первых, вам приходится вставлять имя класса и оператор области видимости между типом данного и звездочкой. Во-вторых, при выполнении операции присваивания этому указателю на самом деле не назначается какой то определенный адрес памяти. Значение &MyClass::ival_ не является каким-то конкретным значением, содержащимся в памяти; оно ссылается на имя класса, а не на имя объекта, но тогда что же это такое на самом деле? Можно представить это значение как смешение данного-члена относительно начального адреса объекта.
Переменная mpi должна использоваться совместно с экземпляром класса, к которому она применяется. Немного ниже в примере 15.2 располагается следующая строка, которая использует mpi для присваивания целого числа значению, на которое ссылается указатель mpi.
obj.*mpi = 5;
obj является экземпляром класса MyClass. Ссылка на член с использованием точки (или ->, если у вас имеется указатель на obj) и разыменование mpi позволяют вам получить ссылку на obj.ival_.
Указатели на функции-члены действуют фактически так же. В примере 15.2 объявляется указатель на функцию-член MyClass, которая возвращает void и не имеет аргументов.
void (MyClass::*mpf)();
Ему можно присвоить значение с помощью оператора адресации.
mpf = &MyClass::incr;
Для вызова функции заключите основное выражение в скобки, чтобы компилятор понял ваши намерения, например:
(obj.*mpf)();
Однако имеется одно отличие в применении указателей на данные-члены и указателей на функции члены. Если необходимо использовать обычный указатель (не на член класса) на данное-член, просто действуйте обычным образом.
int* pi = &obj.ival_;
Конечно, вы используете имя объекта, а не имя класса, потому что получаете адрес конкретного данного-члена конкретного объекта, расположенного где-то в памяти. (Однако обычно стараются адреса данных-членов класса не выдавать за его пределы, чтобы нельзя было их изменить из-за опрометчивых действий в клиентском программном коде.)
В отличие от данного члена с функцией-членом вы не можете сделать то же самое, потому что это бессмысленно. Рассмотрим указатель на функцию, имеющую такую же сигнатуру, как MyClass::incr (т.е. он возвращает void и не имеет аргументов).
void (*pf)();
Теперь попытайтесь присвоить этому указателю адрес функции-члена.
pf = &MyClass::incr; // He получится
pf = &obj.incr;      // И это не пройдет
Обе эти строки не будут откомпилированы, и на это имеются веские основания. Применение функции-члена имеет разумный смысл только в контексте объекта, поскольку, вероятнее всего, она должна ссылаться на переменные-члены. Вызов функции-члена без объекта означало бы невозможность в функции-члене использовать какие-либо члены объекта, а эта функция, по-видимому, как раз является функцией-членом, а не автономной функцией, потому что использует члены объекта.
См. также
Рецепт 15.1.
15.3. Обеспечение невозможности модификации аргумента в функции
Проблема
Вы пишете функцию и требуется гарантировать, что ее аргументы не будут модифицированы при ее вызове.
Решение
Для предотвращения изменения аргументов вашей функцией объявите ее аргументы с ключевым словом const. Короткий пример 15.3 показывает, как это можно сделать.
Пример 15.3. Гарантия невозможности модификации аргументов
#include <iostream
#include <string>
void concat(const std::string& s1, // Аргументы объявлены как константное,
 const std::string& s2,            // поэтому не могут быть изменены
 std::string& out) {
 out = s1 + s2;
}
int main() {
 std::string s1 = "Cabo ";
 std::string s2 = "Wabo";
 std::string s3;
 concat(s1, s2, s3);
 std::cout << "s1 = " << s1 << '\n';
 std::cout << "s2 = " << s2 << '\n';
 std::cout << "s3 = " << s3 << '\n';
}
Обсуждение
В примере 15.3 продемонстрировано прямое использование ключевого слова const. Существует две причины объявления параметров вашей функции с этим ключевым словом, когда вы не планируете их изменять. Во-первых, этим вы сообщаете о своих намерениях читателям вашего программного кода. Объявляя параметр как const, вы фактически говорите, что он является входным параметром. Это позволяет пользователям вашей функции писать программный код в расчете на то, что эти значения не будут изменены. Во-вторых, это позволяет компилятору запретить любые модифицирующие операции на тот случай, если вы случайно их используете. Рассмотрим небезопасную версию concat из примера 15 3.
void concatUnsafe(std::string& s1,
 std::string& s2 std::string& out) {
 out = s1 += s2; // Ну вот, записано значение в s1
}
Несмотря на мою привычку тщательно подходить к кодированию программ, я сделал глупую ошибку и написал += вместо +. В результате при вызове concatUnsafe будут модифицированы аргументы out и s1, что может оказаться сюрпризом для пользователя, который едва ли рассчитывает на модификацию одной из исходных строк.
Спасти может const. Создайте новую функцию concatSafe, объявите переменные константными, как показано в примере 15.3, и функция не будет откомпилирована.
void concatSafe(const std::string& s1,
 const std::string& s2, std::string& out) {
 out = s1 += s2; // Теперь вы получите ошибку компиляции
}
concatSafе гарантирует неизменяемость значений в s1 и s2. Эта функция делает еще кое-что: она позволяет пользователю передавать константные аргументы. Например, программный код, выполняющий конкатенацию строк, мог бы выглядеть следующим образом.
void myFunc(const std::string& s) { // Обратите внимание, что s является
                                    // константной переменной
 std::string dest;
 std::string tmp = "foo";
 concatUnsafe(s, tmp, dest); // Ошибка: s - константная переменная
                             // Выполнить какие-то действия с dest...
}
В данном случае функция myFunc не будет откомпилирована, потому что concatUnsafe не обеспечивает const'антность myFunc. myFunc гарантирует внешнему миру, что она не будет модифицировать содержимое s, т.е. все действия с s внутри тела myFunc не должны нарушать это обещание. Конечно, вы можете обойти это ограничение, используя оператор const_cast и тем самым освобождаясь от константности, но такой подход ненадежен, и его следует избегать. В этой ситуации concatSafe будет компилироваться и выполняться нормально.
Указатели вносят темные штрихи в розовую картину const. Когда вы объявляете переменную-указатель как параметр, вы имеет дело с двумя объектами: самим адресом и то, на что ссылается этот адрес. C++ позволяет использовать const для ограничения действий по отношению к обоим объектам. Рассмотрим еще одну функцию конкатенации, которая использует указатели.
void concatUnsafePtr(std::string* ps1,
 std::string* ps2, std::string* pout) {
 *pout = *ps1 + *ps2;
}
Здесь такая же проблема, как в примере с concatUnsafe, описанном ранее. Добавьте const для гарантии невозможности обновления исходных строк.
void concatSaferPtr(const std::string* ps1,
 const std::string* ps2, std::string* pout) {
 *pout = *ps1 + *ps2;
}
Отлично, теперь вы не можете изменить *ps1 и *ps2. Но вы по-прежнему можете изменить ps1 и ps2, или, другими словами, используя их, вы можете сослаться на какую-нибудь другую строку, изменяя значение указателя, но не значение, на которое он ссылается. Ничто не может помешать вам, например, сделать следующее.
void concatSaferPtr(const std:string* ps1,
 const std::string* ps2, std::string* pout) {
 ps1 = pout; // Ух!
 *pout = *ps1 + *ps2;
}
Предотвратить подобные ошибки можно с помощью еще одного const.
void concatSafestPtr(const std::string* const ps1,
 const std::string* const ps2, std::string* pout) {
 *pout = *ps1 + *ps2;
}
Применение const по обе стороны звездочки делает вашу функцию максимально надежной. В этом случае вы ясно показываете свои намерения пользователям вашей функции, и ваша репутация не пострадает в случае описки.
См. также
Рецепт 15.4.
15.4. Обеспечение невозможности модификации своих объектов в функции-члене
Проблема
Требуется вызывать функции -члены для константного объекта, но ваш компилятор жалуется на то, что он не может преобразовать тип используемого вами объекта из константного в неконстантный.
Решение
Поместите ключевое слово const справа от имени функции-члена при ее объявлении в классе и при ее определении. Пример 15.4 показывает, как это можно сделать
Пример 15.4. Объявление функции-члена константной
#include <iostream>
#include <string>
class RecordSet {
public:
 bool getFieldVal(int i, std::string& s) const;
 // ...
};
bool RecordSet::getFieldVal(int i, std::string& s) const {
 // Здесь нельзя модифицировать никакие неизменяемые
 // данные-члены (см. обсуждение)
}
void displayRecords(const RecordSet& rs) {
 // Здесь вы можете вызывать только константные функции-члены
 // для rs
}
Обсуждение
Добавление концевого const в объявление члена и в его определение заставляет компилятор более внимательно отнестись к тому, что делается с объектом внутри тела члена. Константным функциям-членам не разрешается выполнять неконстантные операции с данными-членами. Если такие операции присутствуют, компиляция завершится неудачно. Например, если бы в RecordSet::getFieldVal я обновил счетчик-член, эта функция не была бы откомпилирована (в предположении, что getFieldCount_ является переменной-членом класса RecordSet).
bool RecordSet::getFieldVal(int i, std::string& s) const {
 ++getFieldCount_; // Ошибка: константная функция-член не может
                   // модифицировать переменную-член
                   // ...
}
Это может также помочь обнаружить более тонкие ошибки, подобно тому, что делает const в роли квалификатора переменной (см. рецепт 15.3). Рассмотрим следующую глупую ошибку.
bool RecordSet::getFieldVal(int i, std::string& s) const {
 fieldArray_[i] = s; // Ой, я не это имел в виду
 // ...
}
Снова компилятор преждевременно завершит работу и выдаст сообщение об ошибке, потому что вы пытаетесь изменить переменную-член, а это не разрешается делать в константных функциях-членах. Ну, при одном исключении.
В классе RecordSet (в таком, как (схематичный) класс в примере 15.4) вам, вероятно, потребовалось бы перемещаться туда-сюда по набору записей, используя понятие «текущей» записи. Простой способ заключается в применении переменной-члена целого типа, содержащей номер текущей записи; ваши функции-члены, предназначенные для перемещения текущей записи вперед-назад, должны увеличивать или уменьшать это значение.
void RecordSet::gotoNextPecord() const {
 if (curIndex_ >= 0 && curIndex_ < numRecords_-1)
  ++curIndex_;
}
void RecordSet::gotoPrevRecord() const {
 if (curIndex_ > 0)
  --curIndex_;
}
Очевидно, что это не сработает, если эти функции-члены являются константными. Обе обновляют данное-член. Однако без этого пользователи класса RecordSet не смогут перемещаться по объекту const RecordSet. Это исключение из правил работы с константными функциями-членами является вполне разумным, поэтому C++ имеет механизм его поддержки: ключевое слово mutable.
Для того чтобы curIndex_ можно было обновлять в константной функции-члене, объявите ее с ключевым словом mutable в объявлении класса.
mutable int curIndex_;
Это позволит вам модифицировать curIndex_ в любом месте. Однако этой возможностью следует пользоваться разумно, поскольку это действует на вашу функцию так, как будто она становится с этого момента неконстантной.
Применение ключевого слова const в примере 15.4 позволяет гарантировать невозможность изменения состояния объекта в функции-члене. В целом, такой подход дает хорошие результаты, потому что сообщает пользователям класса о режиме работы функции-члена и потому что сохраняет вам репутацию, заставляя компилятор проконтролировать отсутствие в функции-члене непредусмотренных действий.
15.5. Написание оператора, не являющегося функцией-членом
Проблема
Необходимо написать бинарный оператор, и вы не можете или не хотите сделать его функцией-членом класса.
Решение
Используйте ключевое слово operator, временную переменную и конструктор копирования для выполнения основной работы и возвратите временный объект. В примере 15.5 приводится простой оператор конкатенации строк для пользовательского класса String.
Пример 15.5. Конкатенация с использованием оператора не члена
#include <iostream>
#include <cstring>
class String { // Предположим, что объявление класса String содержит,
               // по крайней мере, все, что указанно ниже
public:
 String();
 String(const char* p);
 String(const String& orig);
 ~String() {delete buf_;}
 String& append(const String& s);
 size_t length() const;
 const char* data() const;
 String& operator=(const String& orig);
 // ...
};
String operator+(const String& lhs, const String& rhs) {
 String tmp(lhs); // Сконструировать временный объект с помощью
                  // конструктора копирования
 tmp.append(rhs); // Использовать функцию-член для выполнения реальной
                  // работы
 return(tmp); // Возвратить временный объект
}
int main() {
 String s1("banana ");
 String s2("rancher");
 String s3, s4, s5, s6;
 s3 = s1 + s2;           // Работает хорошо, но с сюрпризами
 s4 = s1 + "rama";       // Автоматически конструируется "rama", используя
                         // конструктор String(const char*)
 s5 = "ham " + s2;       // Круто, то же самое можно делать даже
 s6 = s1 + "rama " + s2; // с другим операндом
 std::cout << "s3 = " << s3.data() << '\n';
 std::cout << "s4 = " << s4.data() << '\n';
 std::cout << "s5 = " << s5.data() << '\n';
 std::cout << "s6 = " << s6.data() << '\n';
}
Обсуждение
Независимый оператор объявляется и определяется подобно оператору функции-члена. В примере 15.5 я мог бы реализовать operator+ как функцию-член, объявляя ее следующим образом.
String operator+(const String& rhs);
В большинстве случаев это будет работать одинаково, независимо от того, определяется ли operator+ как функция-член или нет, однако существует, по крайней мере, две причины, по которым желательно реализовать его не как функцию-член. Первая причина концептуальная, имеет ли смысл иметь оператор, который возвращает новый, отличный от других объект? operator+, реализованный как функция-член, не проверяет и не изменяет состояние объекта. Это служебная функция общего назначения, которая в данном случае работает со строками типа String и, следовательно, не должна являться функцией членом.
Вторая причина техническая. При использовании оператора-члена вы не сможете выполнить следующую операцию (из приведенного выше примера).
s5 = "ham " + s2;
Это не сработает, потому что символьная строка не имеет operator+, который принимает String в качестве параметра. С другой стороны, если вы определили независимый operator+, который принимает два параметра типа String, ваш компилятор проверит наличие в классе String конструктора, принимающего const char* в качестве аргумента (или любой другой тип, который вы используете совместно с String), и сконструирует временный объект на этапе выполнения. Поэтому приведенная выше строка эквивалентна следующей.
s5 = String("ham ") + s2;
Компилятор позволяет вам немного сэкономить ваши действия и не вводить несколько символов за счет поиска и вызова соответствующего конструктора.
Перегрузка операторов сдвига потоков влево и вправо (<< и >>) также требует применения операторов не-членов. Например, для записи нового объекта в поток, используя сдвиг влево, вам придется следующим образом объявить operator<<:
ostream& operator<<(ostream& str, const MyClass& obj);
Конечно, вы можете создать подкласс одного из классов потока стандартной библиотеки и добавить все необходимые вам операторы сдвига влево, но будет ли такое решение действительно удачным? При таком решении только тот программный код, который использует ваш новый класс потока, сможет записывать в него объекты вашего специального класса. Если вы используете независимый оператор, любой программный код в том же самом пространстве имен сможет без проблем записать ваш объект в ostream (или считать его из istream).
15.6. Инициализация последовательности значениями, разделяемыми запятыми
Проблема
Требуется инициализировать последовательность набором значений, разделяемых запятыми, подобно тому как это делается для встроенных массивов.
Решение
При инициализации стандартных последовательностей (таких как vector и list) можно использовать синтаксис с запятыми, определяя вспомогательный класс и перегружая оператор запятой, как это продемонстрировано в примере 15.6.
Пример 15.6. Вспомогательные классы для инициализации стандартных последовательностей с применением синтаксиса с запятыми
#include <vector>
#include <iostream>
#include <iterator>
#include <algorithm>
using namespace std;
template<class Seq_T>
struct comma helper {
 typedef typename Seq_T::value_type value_type;
 explicit comma_helper(Seq_T& x) : m(x) {}
 comma_helper& operator=(const value_type& x) {
  m.clear();
  return operator+=(x);
 }
 comma_helper& operator+=(const value_type& x) {
  m.push_back(x);
  return *this;
 }
 Seq_T& m;
};
template<typename Seq_T>
comma_helper<Seq_T> initialize(Seq_T& x) {
 return comma_helper<Seq_T>(x);
}
template<class Seq_T, class Scalar_T>
comma_helper<Seq_T>& operator,(comma_helper<Seq_T>& h, Scalar_T x) {
 h += x;
 return h;
}
int main() {
 vector v;
 int a = 2;
 int b = 5;
 initialize(v) = 0, 1, 1, a, 3, b, 8, 13;
 cout << v[3] << endl; // выдает 2
 system("pause");
 return EXIT_SUCCESS;
}
Обсуждение
Часто стандартные последовательности инициализируются путем вызова несколько раз функции-члена push_back. Поскольку это приходится делать не так уж редко, я написал функцию initialize, которая помогает избавиться от этого скучного занятия, позволяя выполнять инициализацию значениями, разделяемыми запятыми, подобно тому как это делается во встроенных массивах.
Возможно, вы и не знали, что запятая является оператором, который можно переопределять. Здесь вы не одиноки — этот факт не является общеизвестным. Оператор запятой было разрешено перегружать почти только ради решения этой задачи.
В решении используется вспомогательная функция initialize, которая возвращает шаблон вспомогательной функции comma_helper. Этот шаблон содержит ссылку на последовательность и перегруженные операторы operator,, operator= и operator+=.
Такое решение требует, чтобы я определил отдельную вспомогательную функцию из-за особенностей восприятия компилятором оператора v = 1, 1, 2, ...;. Компилятор рассматривает v = 1 как недопустимое подвыражение, потому что в стандартных последовательностях не поддерживается оператор присваивания единственного значения. Функция initialize конструирует соответствующий объект comma_helper, который может хранить последовательность, используемую в перегруженном операторе присваивания и запятой.
Оператор запятой (comma operator), называемый также оператором последовательности (sequencing operator), по умолчанию рассматривает выражения слева направо, и в результате получается значение и тип самого правого значения. Однако при перегрузке operator принимает новый смысл и теряет первоначальную семантику. Здесь возникает один тонкий момент — оценка параметров слева направо теперь не гарантируется, и результат выполнения программного кода, приведенного в примере 15.7, может оказаться неожиданным.
Пример 15.7. Применение перегруженного оператора запятой, когда порядок вычисления аргументов не определен
int prompt_user() {
 cout << "give me an integer ... ";
 cin >> n;
 return n;
}
void f() {
 vector<int> v;
 // Следующий оператор может инициализировать v в неправильной
 // последовательности
 intialize(v) = prompt_user(), prompt_user();
}
В правильном варианте функции f каждый вызов prompt_user должен был бы выполняться в отдельном операторе.
Библиотека Boost Assign, написанная Торстеном Оттосеном (Thorsten Ottosen), кроме других форм инициализации стандартных коллекций поддерживает также более сложную форму инициализации списком с запятыми. Эта библиотека доступна на сайте http://www.boost.org.
Об авторах
Д. Райан Стефенс (D. Ryan Stephens) — студент, живущий в г. Темп, шт. Аризона; он занимается разработкой программного обеспечения и является автором ряда работ по программированию. Ему нравится программировать практически на любом языке, особенно на С++. В его интересы входит поиск информации и ее извлечение из данных, а также все, что связано с алгоритмами и большими наборами данных. Когда он не работает, не пишет статьи и не программирует, он играет со своими детьми, работает по дому и катается на велосипеде.
Кристофер Диггинс (Christopher Diggins), который начал заниматься программированием в очень раннем возрасте (haut comme trois pommes), является независимым разработчиком программного обеспечения и автором, пишущим в этой области. Кристофер регулярно публикует свои статьи в журнале «C++ Users Journal» и является разработчиком языка программирования Heron.
Джонатан Турканис (Jonathan Turkanis) — автор библиотеки Boost Iostreams и нескольких других библиотек C++ с открытым исходным кодом, охватывающих такие области, как «умные» указатели, отражение состояния программы на этапе выполнения, программирование обобщенных компонент и программирование, ориентированное на характерные особенности (aspect-oriented programming). Он является аспирантом Калифорнийского университета г. Беркли по специальности «математическая логика».
Джефф Когсуэлл (Jeff Cogswell) занимается разработкой программного обеспечения и живет недалеко от Цинциннати, шт. Огайо. Он программирует на C++ почти со времени появления этого языка, и им написано много работ по нему, включая две другие книги по C++. Он также любит программировать на других языках, особенно на Python. Когда не работает (что случается редко), он любит читать хороший роман или играть на гитаре.
Колофон
Наша точка зрения сложилась в результате анализа комментариев читателей, собственных экспериментов и информации, полученной по каналам распространения. Характерные обложки дополняют наш особый подход к техническим темам, внося индивидуальность и делая более живыми потенциально скучные темы.
На обложке «C++: рецепты программирования» представлена собака породы колли. Этот тип овчарки появился в гористой местности Шотландии и Британии в 1600-х годах. Одна разновидность овец в гористой Шотландии имела темные метки на морде и ногах, и поэтому таких овец называли «Colley»; это название происходит от старошотландского слова, обозначающего уголь. Современная порода колли светлее и более ширококостная, чем ее шотландские предки; она была выведена в конце 19-го столетия. В настоящее время колли, в основном, являются домашними любимцами, хотя в Соединенных Штатах они по-прежнему используются в фермерских хозяйствах.
Существует две разные породы колли: грубошерстные колли, которые использовались для охраны овец, и гладкошерстные - для сопровождения скота на рынок. Обе породы - это гибкие, стройные собаки с четко выраженной мордой и заостренными ушами. По высоте колли достигают 22-26 дюймов и весят 50-75 фунтов. Они обычно имеют белый мех с добавками другого цвета: от желто-белого и рыжего до угольно-черного.
К знаменитым колли относится, конечно, Лэсси, Бланко Линдона Джонсона и Лэдди из сериала «Симпсоны» (The Simpsons).
Мэтт Хатчинсон (Matt Hutchinson) был редактором по производству книги «С++: рецепты программирования». Издательство «Octal Publishing, Inc.» предоставляло производственные услуги. Дарен Келли (Darren Kelly), Адам Уитвер (Adam Witwer) и Клер Клутье (Claire Cloutier) обеспечивали контроль качества.
Карен Монтгомери (Karen Montgomery) разработала обложку этой книги на основе серии проектов Эдди Фридманом (Edie Freedman). Изображение на обложке взято из гравюры 19-го столетия, которая приводится в «Natural History» (Естественная история) издательского дома Cassell. Карен Монтгомери сделала макет обложки, используя InDesign CS компании Adobe и шрифт ITC Garamond той же компании.
Дэвид Футато (David Futato) разработал внутренний дизайн книги. Эта книга была переведена Кейт Фалгрен (Keith Fahlgren) в формат FrameMaker 5.5.6 с помощью утилиты преобразования форматов, которую создали Эрик Рей (Erik Ray), Джейсон Макинтош (Jason Mcintosh), Нейл Уэллс (Neil Walls) и Майк Сьерра (Mike Sierra); эта утилита использует язык Perl и XML-технологию. Для текста использован шрифт Linotype Birka, шрифт заголовков — Adobe Myriad Condensed, а шрифт программного кода — TheSans Mono Condensed компании «LucasFont». Иллюстрации, которые содержатся внутри книги, были сделаны Робертом Романо (Robert Romano), Джессамин Рид (Jessamyn Read) и Лесли Бораш (Lesley Borash) с помощью Macromedia FreeHand MX и Adobe Photoshop CS. Пиктограммы советов и предупреждений были нарисованы Кристофером Бингом (Christopher Bing). Заключение составил Мэтт Хатчинсон.
